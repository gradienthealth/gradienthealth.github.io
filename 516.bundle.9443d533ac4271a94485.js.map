{"version":3,"file":"516.bundle.9443d533ac4271a94485.js","mappings":"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","sources":["webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/helpers/sortImageIdsAndGetSpacing.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/helpers/getVolumeInfo.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/helpers/autoLoad.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/helpers/scaleArray.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/BaseStreamingImageVolume.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/StreamingImageVolume.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/cornerstoneStreamingImageVolumeLoader.ts","webpack:///../../../../cornerstone3D/packages/streaming-image-volume-loader/src/helpers/makeVolumeMetadata.ts","webpack:///../../../extensions/cornerstone/src/initWADOImageLoader.js","webpack:///../../../extensions/cornerstone/src/utils/callInputDialog.tsx","webpack:///../../../extensions/cornerstone/src/utils/getActiveViewportEnabledElement.ts","webpack:///../../../extensions/cornerstone/src/tools/CalibrationLineTool.ts","webpack:///../../../extensions/cornerstone/src/tools/ImageOverlayViewerTool.tsx","webpack:///../../../extensions/cornerstone/src/initCornerstoneTools.js","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/constants/supportedTools.js","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/Length.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/Bidirectional.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/EllipticalROI.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/CircleROI.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/ArrowAnnotate.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/CobbAngle.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/Angle.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/PlanarFreehandROI.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/RectangleROI.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/measurementServiceMappingsFactory.ts","webpack:///../../../extensions/cornerstone/src/initMeasurementService.js","webpack:///../../../extensions/cornerstone/src/initCineService.ts","webpack:///../../../extensions/cornerstone/src/utils/interleaveCenterLoader.ts","webpack:///../../../extensions/cornerstone/src/utils/getInterleavedFrames.js","webpack:///../../../extensions/cornerstone/src/utils/nthLoader.ts","webpack:///../../../extensions/cornerstone/src/utils/interleave.js","webpack:///../../../extensions/cornerstone/src/utils/getNthFrames.js","webpack:///../../../extensions/cornerstone/src/utils/interleaveTopToBottom.ts","webpack:///../../../extensions/cornerstone/src/utils/findNearbyToolData.ts","webpack:///../../../extensions/cornerstone/src/initContextMenu.ts","webpack:///../../../extensions/cornerstone/src/initDoubleClick.ts","webpack:///../../../extensions/cornerstone/src/init.tsx","webpack:///../../../extensions/cornerstone/src/utils/DicomFileUploader.ts","webpack:///../../../extensions/cornerstone/src/components/DicomUpload/DicomUploadProgressItem.tsx","webpack:///../../../extensions/cornerstone/src/components/DicomUpload/DicomUploadProgress.tsx","webpack:///../../../extensions/cornerstone/src/components/DicomUpload/DicomUpload.tsx","webpack:///../../../extensions/cornerstone/src/getCustomizationModule.ts","webpack:///../../../extensions/cornerstone/src/utils/CornerstoneViewportDownloadForm.tsx","webpack:///../../../extensions/cornerstone/src/utils/stackSync/calculateViewportRegistrations.ts","webpack:///../../../extensions/cornerstone/src/utils/stackSync/toggleStackImageSync.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/utils/selection.ts","webpack:///../../../extensions/cornerstone/src/commandsModule.ts","webpack:///../../../extensions/cornerstone/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone/src/services/ToolGroupService/ToolGroupService.ts","webpack:///../../../extensions/cornerstone/src/services/ToolGroupService/index.js","webpack:///../../../extensions/cornerstone/src/services/SyncGroupService/SyncGroupService.ts","webpack:///../../../extensions/cornerstone/src/services/SyncGroupService/index.js","webpack:///../../../extensions/cornerstone/src/utils/transitions.ts","webpack:///../../../extensions/cornerstone/src/services/SegmentationService/SegmentationService.ts","webpack:///../../../extensions/cornerstone/src/services/SegmentationService/RTSTRUCT/mapROIContoursToRTStructData.ts","webpack:///../../../extensions/cornerstone/src/services/SegmentationService/index.js","webpack:///../../../extensions/cornerstone/src/utils/getCornerstoneViewportType.ts","webpack:///../../../extensions/cornerstone/src/services/CornerstoneCacheService/CornerstoneCacheService.ts","webpack:///../../../extensions/cornerstone/src/services/CornerstoneCacheService/index.js","webpack:///../../../extensions/cornerstone/src/services/ViewportService/constants.ts","webpack:///../../../extensions/cornerstone/src/services/ViewportService/Viewport.ts","webpack:///../../../extensions/cornerstone/src/utils/getCornerstoneOrientation.ts","webpack:///../../../extensions/cornerstone/src/utils/getCornerstoneBlendMode.ts","webpack:///../../../extensions/cornerstone/src/utils/JumpPresets.ts","webpack:///../../../extensions/cornerstone/src/services/ViewportService/CornerstoneViewportService.ts","webpack:///../../../extensions/cornerstone/src/utils/dicomLoaderService.js","webpack:///../../../extensions/cornerstone/src/id.js","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/utils/getHandlesFromPoints.js","webpack:///../../../extensions/cornerstone/src/index.tsx","webpack:///../../../extensions/cornerstone/src/state.ts","webpack:///../../../extensions/cornerstone/src/utils/measurementServiceMappings/utils/getSOPInstanceAttributes.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\nimport { metaData, getConfiguration } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\ntype SortedImageIdsItem = {\n  zSpacing: number;\n  origin: Types.Point3;\n  sortedImageIds: Array<string>;\n};\n/**\n * Given an array of imageIds, sort them based on their imagePositionPatient, and\n * also returns the spacing between images and the origin of the reference image\n *\n * @param imageIds - array of imageIds\n * @param scanAxisNormal - [x, y, z] array or gl-matrix vec3\n *\n * @returns The sortedImageIds, zSpacing, and origin of the first image in the series.\n */\nexport default function sortImageIdsAndGetSpacing(\n  imageIds: Array<string>,\n  scanAxisNormal: vec3 // Get gl matrix types?\n): SortedImageIdsItem {\n  const { imagePositionPatient: referenceImagePositionPatient } = metaData.get(\n    'imagePlaneModule',\n    imageIds[0]\n  );\n\n  const refIppVec = vec3.create();\n\n  // Check if we are using wadouri scheme\n  const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n\n  vec3.set(\n    refIppVec,\n    referenceImagePositionPatient[0],\n    referenceImagePositionPatient[1],\n    referenceImagePositionPatient[2]\n  );\n\n  let sortedImageIds: string[];\n  let zSpacing: number;\n\n  function getDistance(imageId: string) {\n    const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n\n    const positionVector = vec3.create();\n\n    vec3.sub(\n      positionVector,\n      referenceImagePositionPatient,\n      imagePositionPatient\n    );\n\n    return vec3.dot(positionVector, scanAxisNormal);\n  }\n\n  /**\n   * If we are using wadors and so have all image metadata cached ahead of time,\n   * then sort by image position in 3D space, and calculate average slice\n   * spacing from the entire volume. If not, then use the sampled images (1st\n   * and middle) to calculate slice spacing, and use the provided imageId order.\n   * Correct sorting must be done ahead of time.\n   */\n  if (!usingWadoUri) {\n    const distanceImagePairs = imageIds.map((imageId) => {\n      const distance = getDistance(imageId);\n\n      return {\n        distance,\n        imageId,\n      };\n    });\n\n    distanceImagePairs.sort((a, b) => b.distance - a.distance);\n\n    sortedImageIds = distanceImagePairs.map((a) => a.imageId);\n    const numImages = distanceImagePairs.length;\n\n    // Calculated average spacing.\n    // We would need to resample if these are not similar.\n    // It should be up to the host app to do this if it needed to.\n    zSpacing =\n      Math.abs(\n        distanceImagePairs[numImages - 1].distance -\n          distanceImagePairs[0].distance\n      ) /\n      (numImages - 1);\n  } else {\n    // Using wadouri, so we have only prefetched the first, middle, and last\n    // images for metadata. Assume initial imageId array order is pre-sorted,\n    // but check orientation.\n    const prefetchedImageIds = [\n      imageIds[0],\n      imageIds[Math.floor(imageIds.length / 2)],\n    ];\n    sortedImageIds = imageIds;\n    const firstImageDistance = getDistance(prefetchedImageIds[0]);\n    const middleImageDistance = getDistance(prefetchedImageIds[1]);\n    if (firstImageDistance - middleImageDistance < 0) {\n      sortedImageIds.reverse();\n    }\n\n    // Calculate average spacing between the first and middle prefetched images,\n    // otherwise fall back to DICOM `spacingBetweenSlices`\n    const metadataForMiddleImage = metaData.get(\n      'imagePlaneModule',\n      prefetchedImageIds[1]\n    );\n    if (!metadataForMiddleImage) {\n      throw new Error('Incomplete metadata required for volume construction.');\n    }\n\n    const positionVector = vec3.create();\n\n    vec3.sub(\n      positionVector,\n      referenceImagePositionPatient,\n      metadataForMiddleImage.imagePositionPatient\n    );\n    const distanceBetweenFirstAndMiddleImages = vec3.dot(\n      positionVector,\n      scanAxisNormal\n    );\n    zSpacing =\n      Math.abs(distanceBetweenFirstAndMiddleImages) /\n      Math.floor(imageIds.length / 2);\n  }\n\n  const { imagePositionPatient: origin, sliceThickness } = metaData.get(\n    'imagePlaneModule',\n    sortedImageIds[0]\n  );\n\n  const { strictZSpacingForVolumeViewport } = getConfiguration().rendering;\n\n  // We implemented these lines for multiframe dicom files that does not have\n  // position for each frame, leading to incorrect calculation of zSpacing = 0\n  // If possible, we use the sliceThickness, but we warn about this dicom file\n  // weirdness. If sliceThickness is not available, we set to 1 just to render\n  if (zSpacing === 0 && !strictZSpacingForVolumeViewport) {\n    if (sliceThickness) {\n      console.log('Could not calculate zSpacing. Using sliceThickness');\n      zSpacing = sliceThickness;\n    } else {\n      console.log(\n        'Could not calculate zSpacing. The VolumeViewport visualization is compromised. Setting zSpacing to 1 to render'\n      );\n      zSpacing = 1;\n    }\n  }\n  const result: SortedImageIdsItem = {\n    zSpacing,\n    origin,\n    sortedImageIds,\n  };\n\n  return result;\n}\n","import { cache, utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport makeVolumeMetadata from './makeVolumeMetadata';\nimport sortImageIdsAndGetSpacing from './sortImageIdsAndGetSpacing';\n\nconst { createUint8SharedArray, createFloat32SharedArray } = utilities;\n\nfunction getVolumeInfo(imageIds: string[]) {\n  const volumeMetadata = makeVolumeMetadata(imageIds);\n\n  const {\n    BitsAllocated,\n    PixelRepresentation,\n    PhotometricInterpretation,\n    ImageOrientationPatient,\n    PixelSpacing,\n    Columns,\n    Rows,\n  } = volumeMetadata;\n\n  const rowCosineVec = vec3.fromValues(\n    ImageOrientationPatient[0],\n    ImageOrientationPatient[1],\n    ImageOrientationPatient[2]\n  );\n\n  const colCosineVec = vec3.fromValues(\n    ImageOrientationPatient[3],\n    ImageOrientationPatient[4],\n    ImageOrientationPatient[5]\n  );\n\n  const scanAxisNormal = vec3.create();\n\n  vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n\n  const { zSpacing, origin, sortedImageIds } = sortImageIdsAndGetSpacing(\n    imageIds,\n    scanAxisNormal\n  );\n\n  const numFrames = imageIds.length;\n\n  // Spacing goes [1] then [0], as [1] is column spacing (x) and [0] is row spacing (y)\n  const spacing = <Types.Point3>[PixelSpacing[1], PixelSpacing[0], zSpacing];\n  const dimensions = <Types.Point3>[Columns, Rows, numFrames];\n  const direction = [\n    ...rowCosineVec,\n    ...colCosineVec,\n    ...scanAxisNormal,\n  ] as Types.Mat3;\n  const signed = PixelRepresentation === 1;\n\n  // Check if it fits in the cache before we allocate data\n  // TODO Improve this when we have support for more types\n  // NOTE: We use 4 bytes per voxel as we are using Float32.\n  const bytesPerVoxel = BitsAllocated === 16 ? 4 : 1;\n  const sizeInBytesPerComponent =\n    bytesPerVoxel * dimensions[0] * dimensions[1] * dimensions[2];\n\n  let numComponents = 1;\n  if (PhotometricInterpretation === 'RGB') {\n    numComponents = 3;\n  }\n\n  const sizeInBytes = sizeInBytesPerComponent * numComponents;\n\n  // check if there is enough space in unallocated + image Cache\n  const isCacheable = cache.isCacheable(sizeInBytes);\n  if (!isCacheable) {\n    throw new Error(Enums.Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  cache.decacheIfNecessaryUntilBytesAvailable(sizeInBytes);\n\n  let scalarData;\n\n  switch (BitsAllocated) {\n    case 8:\n      if (signed) {\n        throw new Error(\n          '8 Bit signed images are not yet supported by this plugin.'\n        );\n      } else {\n        scalarData = createUint8SharedArray(\n          dimensions[0] * dimensions[1] * dimensions[2]\n        );\n      }\n\n      break;\n\n    case 16:\n      scalarData = createFloat32SharedArray(\n        dimensions[0] * dimensions[1] * dimensions[2]\n      );\n\n      break;\n\n    case 24:\n      // hacky because we don't support alpha channel in dicom\n      scalarData = createUint8SharedArray(\n        dimensions[0] * dimensions[1] * dimensions[2] * numComponents\n      );\n\n      break;\n  }\n\n  return {\n    metadata: volumeMetadata,\n    sortedImageIds,\n    dimensions,\n    spacing,\n    origin,\n    direction,\n    scalarData,\n    sizeInBytes,\n  };\n}\n\nexport { getVolumeInfo, getVolumeInfo as default };\n","import { getRenderingEngines, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n//import type { Types } from '@cornerstonejs/core'\n\ntype RenderingEngineAndViewportIds = {\n  renderingEngine: Types.IRenderingEngine | undefined; //Types.IRenderingEngine | undefined\n  viewportIds: Array<string>;\n};\n\n/**\n * Given a volumeId, it finds the viewports and renderingEngines that\n * include that volume, and triggers a render if renderingEngine is available.\n *\n * @param volumeId - The Id of the volume\n */\nconst autoLoad = (volumeId: string): void => {\n  const renderingEngineAndViewportIds =\n    getRenderingEngineAndViewportsContainingVolume(volumeId);\n\n  if (!renderingEngineAndViewportIds || !renderingEngineAndViewportIds.length) {\n    return;\n  }\n\n  renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {\n    if (!renderingEngine.hasBeenDestroyed) {\n      renderingEngine.renderViewports(viewportIds);\n    }\n  });\n};\n\nfunction getRenderingEngineAndViewportsContainingVolume(\n  volumeId: string\n): Array<RenderingEngineAndViewportIds> {\n  const renderingEnginesArray = getRenderingEngines();\n\n  const renderingEngineAndViewportIds = [];\n\n  for (let i = 0; i < renderingEnginesArray.length; i++) {\n    const renderingEngine = renderingEnginesArray[i];\n    const viewports = utilities.getViewportsWithVolumeId(\n      volumeId,\n      renderingEngine.id\n    );\n\n    if (viewports.length) {\n      renderingEngineAndViewportIds.push({\n        renderingEngine,\n        viewportIds: viewports.map((viewport) => viewport.id),\n      });\n    }\n  }\n\n  return renderingEngineAndViewportIds;\n}\n\nexport default autoLoad;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given a pixel array, rescale the pixel values using the rescale slope and\n * intercept and if modality is PT it uses the suv values to scale the array\n * @param array - The array to be scaled.\n * @param scalingParameters - The scaling parameters\n * @returns The array is being scaled\n */\nexport default function scaleArray(\n  array: Float32Array | Uint8Array | Uint16Array | Int16Array,\n  scalingParameters: Types.ScalingParameters\n): Float32Array | Uint8Array | Uint16Array | Int16Array {\n  const arrayLength = array.length;\n  const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;\n\n  if (scalingParameters.modality === 'PT' && typeof suvbw === 'number') {\n    for (let i = 0; i < arrayLength; i++) {\n      array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);\n    }\n  } else {\n    for (let i = 0; i < arrayLength; i++) {\n      array[i] = array[i] * rescaleSlope + rescaleIntercept;\n    }\n  }\n\n  return array;\n}\n","import {\n  Enums,\n  eventTarget,\n  metaData,\n  imageLoadPoolManager,\n  triggerEvent,\n  ImageVolume,\n  cache,\n  imageLoader,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport type { Types } from '@cornerstonejs/core';\nimport { scaleArray, autoLoad } from './helpers';\n\nconst requestType = Enums.RequestType.Prefetch;\nconst { getMinMax } = csUtils;\n\n/**\n * Streaming Image Volume Class that extends ImageVolume base class.\n * It implements load method to load the imageIds and insert them into the volume.\n *\n */\nexport default class BaseStreamingImageVolume extends ImageVolume {\n  private framesLoaded = 0;\n  private framesProcessed = 0;\n  protected numFrames: number;\n  protected cornerstoneImageMetaData = null;\n\n  loadStatus: {\n    loaded: boolean;\n    loading: boolean;\n    cancelled: boolean;\n    cachedFrames: Array<boolean>;\n    callbacks: Array<(...args: unknown[]) => void>;\n  };\n\n  constructor(\n    imageVolumeProperties: Types.IVolume,\n    streamingProperties: Types.IStreamingVolumeProperties\n  ) {\n    super(imageVolumeProperties);\n    this.imageIds = streamingProperties.imageIds;\n    this.loadStatus = streamingProperties.loadStatus;\n    this.numFrames = this._getNumFrames();\n\n    this._createCornerstoneImageMetaData();\n  }\n\n  /**\n   * Returns the number of frames stored in a scalarData object. The number of\n   * frames is equal to the number of images for 3D volumes or the number of\n   * frames per time poins for 4D volumes.\n   * @returns number of frames per volume\n   */\n  private _getNumFrames(): number {\n    const { imageIds, scalarData } = this;\n    const scalarDataCount = this.isDynamicVolume() ? scalarData.length : 1;\n\n    return imageIds.length / scalarDataCount;\n  }\n\n  private _getScalarDataLength(): number {\n    const { scalarData } = this;\n    return this.isDynamicVolume()\n      ? (<Types.VolumeScalarData[]>scalarData)[0].length\n      : (<Types.VolumeScalarData>scalarData).length;\n  }\n\n  /**\n   * Creates the metadata required for converting the volume to an cornerstoneImage\n   */\n  private _createCornerstoneImageMetaData() {\n    const { numFrames } = this;\n\n    if (numFrames === 0) {\n      return;\n    }\n\n    const bytesPerImage = this.sizeInBytes / numFrames;\n    const scalarDataLength = this._getScalarDataLength();\n    const numComponents = scalarDataLength / this.numVoxels;\n    const pixelsPerImage =\n      this.dimensions[0] * this.dimensions[1] * numComponents;\n\n    const { PhotometricInterpretation, voiLut, VOILUTFunction } = this.metadata;\n\n    let windowCenter = [];\n    let windowWidth = [];\n\n    if (voiLut && voiLut.length) {\n      windowCenter = voiLut.map((voi) => {\n        return voi.windowCenter;\n      });\n\n      windowWidth = voiLut.map((voi) => {\n        return voi.windowWidth;\n      });\n    }\n\n    const color = numComponents > 1 ? true : false; //todo: fix this\n\n    this.cornerstoneImageMetaData = {\n      bytesPerImage,\n      numComponents,\n      pixelsPerImage,\n      windowCenter,\n      windowWidth,\n      color,\n      // we use rgb (3 components) for the color volumes (and not rgba), and not rgba (which is used\n      // in some parts of the lib for stack viewing in CPU)\n      rgba: false,\n      spacing: this.spacing,\n      dimensions: this.dimensions,\n      photometricInterpretation: PhotometricInterpretation,\n      voiLUTFunction: VOILUTFunction,\n      invert: PhotometricInterpretation === 'MONOCHROME1',\n    };\n  }\n\n  /**\n   * Converts imageIdIndex into frameIndex which will be the same\n   * for 3D volumes but different for 4D volumes\n   */\n  private _imageIdIndexToFrameIndex(imageIdIndex: number): number {\n    return imageIdIndex % this.numFrames;\n  }\n\n  /**\n   * Return all scalar data objects (buffers) which will be only one for\n   * 3D volumes and one per time point for 4D volumes\n   * images of each 3D volume is stored\n   * @returns scalar data array\n   */\n  public getScalarDataArrays(): Types.VolumeScalarData[] {\n    return this.isDynamicVolume()\n      ? <Types.VolumeScalarData[]>this.scalarData\n      : [<Types.VolumeScalarData>this.scalarData];\n  }\n\n  private _getScalarDataByImageIdIndex(\n    imageIdIndex: number\n  ): Types.VolumeScalarData {\n    if (imageIdIndex < 0 || imageIdIndex >= this.imageIds.length) {\n      throw new Error('imageIdIndex out of range');\n    }\n\n    const scalarDataArrays = this.getScalarDataArrays();\n    const scalarDataIndex = Math.floor(imageIdIndex / this.numFrames);\n\n    return scalarDataArrays[scalarDataIndex];\n  }\n\n  protected invalidateVolume(immediate: boolean): void {\n    const { imageData, vtkOpenGLTexture } = this;\n    const { numFrames } = this;\n\n    for (let i = 0; i < numFrames; i++) {\n      vtkOpenGLTexture.setUpdatedFrame(i);\n    }\n\n    imageData.modified();\n\n    if (immediate) {\n      autoLoad(this.volumeId);\n    }\n  }\n\n  /**\n   * It cancels loading the images of the volume. It sets the loading status to false\n   * and filters any imageLoad request in the requestPoolManager that has the same\n   * volumeId\n   */\n  public cancelLoading = (): void => {\n    const { loadStatus } = this;\n\n    if (!loadStatus || !loadStatus.loading) {\n      return;\n    }\n\n    // Set to not loading.\n    loadStatus.loading = false;\n    loadStatus.cancelled = true;\n\n    // Remove all the callback listeners\n    this.clearLoadCallbacks();\n\n    // Create a filter function which only keeps requests\n    // which do not match this volume's Id\n    const filterFunction = ({ additionalDetails }) => {\n      return additionalDetails.volumeId !== this.volumeId;\n    };\n\n    // Instruct the request pool manager to filter queued\n    // requests to ensure requests we no longer need are\n    // no longer sent.\n    imageLoadPoolManager.filterRequests(filterFunction);\n  };\n\n  /**\n   * Clear the load callbacks\n   */\n  public clearLoadCallbacks(): void {\n    this.loadStatus.callbacks = [];\n  }\n\n  /**\n   * It triggers a prefetch for images in the volume.\n   * @param callback - A callback function to be called when the volume is fully loaded\n   * @param priority - The priority for loading the volume images, lower number is higher priority\n   * @returns\n   */\n  public load = (\n    callback: (...args: unknown[]) => void,\n    priority = 5\n  ): void => {\n    const { imageIds, loadStatus, numFrames } = this;\n\n    if (loadStatus.loading === true) {\n      console.log(\n        `loadVolume: Loading is already in progress for ${this.volumeId}`\n      );\n      return; // Already loading, will get callbacks from main load.\n    }\n\n    const { loaded } = this.loadStatus;\n    const totalNumFrames = imageIds.length;\n\n    if (loaded) {\n      if (callback) {\n        callback({\n          success: true,\n          framesLoaded: totalNumFrames,\n          framesProcessed: totalNumFrames,\n          numFrames,\n          totalNumFrames,\n        });\n      }\n      return;\n    }\n\n    if (callback) {\n      this.loadStatus.callbacks.push(callback);\n    }\n\n    this._prefetchImageIds(priority);\n  };\n\n  protected getImageIdsRequests = (\n    imageIds: string[],\n    scalarData: Types.VolumeScalarData,\n    priority: number\n  ) => {\n    const { loadStatus } = this;\n    const { cachedFrames } = loadStatus;\n\n    const { vtkOpenGLTexture, imageData, metadata, volumeId } = this;\n    const { FrameOfReferenceUID } = metadata;\n\n    // SharedArrayBuffer\n    const arrayBuffer = scalarData.buffer;\n    const numFrames = imageIds.length;\n\n    // Length of one frame in voxels\n    const length = scalarData.length / numFrames;\n    // Length of one frame in bytes\n    const lengthInBytes = arrayBuffer.byteLength / numFrames;\n\n    let type;\n\n    if (scalarData instanceof Uint8Array) {\n      type = 'Uint8Array';\n    } else if (scalarData instanceof Float32Array) {\n      type = 'Float32Array';\n    } else if (scalarData instanceof Uint16Array) {\n      type = 'Uint16Array';\n    } else if (scalarData instanceof Int16Array) {\n      type = 'Int16Array';\n    } else {\n      throw new Error('Unsupported array type');\n    }\n\n    const totalNumFrames = this.imageIds.length;\n    const autoRenderOnLoad = true;\n    const autoRenderPercentage = 2;\n\n    let reRenderFraction;\n    let reRenderTarget;\n\n    if (autoRenderOnLoad) {\n      reRenderFraction = totalNumFrames * (autoRenderPercentage / 100);\n      reRenderTarget = reRenderFraction;\n    }\n\n    function callLoadStatusCallback(evt) {\n      // TODO: probably don't want this here\n\n      if (autoRenderOnLoad) {\n        if (\n          evt.framesProcessed > reRenderTarget ||\n          evt.framesProcessed === evt.totalNumFrames\n        ) {\n          reRenderTarget += reRenderFraction;\n          autoLoad(volumeId);\n        }\n      }\n\n      if (evt.framesProcessed === evt.totalNumFrames) {\n        loadStatus.callbacks.forEach((callback) => callback(evt));\n\n        const eventDetail = {\n          FrameOfReferenceUID,\n          volumeId: volumeId,\n        };\n\n        triggerEvent(\n          eventTarget,\n          Enums.Events.IMAGE_VOLUME_LOADING_COMPLETED,\n          eventDetail\n        );\n      }\n    }\n\n    const updateTextureAndTriggerEvents = (\n      volume: BaseStreamingImageVolume,\n      imageIdIndex,\n      imageId\n    ) => {\n      const frameIndex = this._imageIdIndexToFrameIndex(imageIdIndex);\n\n      cachedFrames[imageIdIndex] = true;\n      this.framesLoaded++;\n      this.framesProcessed++;\n\n      vtkOpenGLTexture.setUpdatedFrame(frameIndex);\n      imageData.modified();\n\n      const eventDetail: Types.EventTypes.ImageVolumeModifiedEventDetail = {\n        FrameOfReferenceUID,\n        imageVolume: volume,\n      };\n\n      triggerEvent(\n        eventTarget,\n        Enums.Events.IMAGE_VOLUME_MODIFIED,\n        eventDetail\n      );\n\n      if (this.framesProcessed === totalNumFrames) {\n        loadStatus.loaded = true;\n        loadStatus.loading = false;\n\n        // TODO: Should we remove the callbacks in favour of just using events?\n        callLoadStatusCallback({\n          success: true,\n          imageIdIndex,\n          imageId,\n          framesLoaded: this.framesLoaded,\n          framesProcessed: this.framesProcessed,\n          numFrames,\n          totalNumFrames,\n        });\n        loadStatus.callbacks = [];\n      } else {\n        callLoadStatusCallback({\n          success: true,\n          imageIdIndex,\n          imageId,\n          framesLoaded: this.framesLoaded,\n          framesProcessed: this.framesProcessed,\n          numFrames,\n          totalNumFrames,\n        });\n      }\n    };\n\n    const successCallback = (\n      imageIdIndex: number,\n      imageId: string,\n      scalingParameters\n    ) => {\n      const frameIndex = this._imageIdIndexToFrameIndex(imageIdIndex);\n\n      // Check if there is a cached image for the same imageURI (different\n      // data loader scheme)\n      const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);\n\n      // Check if the image was already loaded by another volume and we are here\n      // since we got the imageLoadObject from the cache from the other already loaded\n      // volume\n      const cachedVolume = cache.getVolumeContainingImageId(imageId);\n\n      // check if the load was cancelled while we were waiting for the image\n      // if so we don't want to do anything\n      if (loadStatus.cancelled) {\n        console.warn(\n          'volume load cancelled, returning for imageIdIndex: ',\n          imageIdIndex\n        );\n        return;\n      }\n\n      // if it is not a cached image or volume\n      if (\n        !cachedImage?.image &&\n        !(cachedVolume && cachedVolume.volume !== this)\n      ) {\n        return updateTextureAndTriggerEvents(this, imageIdIndex, imageId);\n      }\n\n      // it is either cachedImage or cachedVolume\n      const isFromImageCache = !!cachedImage;\n\n      const cachedImageOrVolume = cachedImage || cachedVolume.volume;\n\n      this.handleImageComingFromCache(\n        cachedImageOrVolume,\n        isFromImageCache,\n        scalingParameters,\n        scalarData,\n        frameIndex,\n        arrayBuffer,\n        updateTextureAndTriggerEvents,\n        imageIdIndex,\n        imageId,\n        errorCallback\n      );\n    };\n\n    function errorCallback(error, imageIdIndex, imageId) {\n      this.framesProcessed++;\n\n      if (this.framesProcessed === totalNumFrames) {\n        loadStatus.loaded = true;\n        loadStatus.loading = false;\n\n        callLoadStatusCallback({\n          success: false,\n          imageId,\n          imageIdIndex,\n          error,\n          framesLoaded: this.framesLoaded,\n          framesProcessed: this.framesProcessed,\n          numFrames,\n          totalNumFrames,\n        });\n\n        loadStatus.callbacks = [];\n      } else {\n        callLoadStatusCallback({\n          success: false,\n          imageId,\n          imageIdIndex,\n          error,\n          framesLoaded: this.framesLoaded,\n          framesProcessed: this.framesProcessed,\n          numFrames,\n          totalNumFrames,\n        });\n      }\n\n      const eventDetail = {\n        error,\n        imageIdIndex,\n        imageId,\n      };\n\n      triggerEvent(eventTarget, Enums.Events.IMAGE_LOAD_ERROR, eventDetail);\n    }\n\n    function handleArrayBufferLoad(scalarData, image, options) {\n      if (!(scalarData.buffer instanceof ArrayBuffer)) {\n        return;\n      }\n\n      const offset = options.targetBuffer.offset; // in bytes\n      const length = options.targetBuffer.length; // in frames\n      const pixelData = image.pixelData\n        ? image.pixelData\n        : image.getPixelData();\n\n      try {\n        if (scalarData instanceof Float32Array) {\n          const bytesInFloat = 4;\n          const floatView = new Float32Array(pixelData);\n          if (floatView.length !== length) {\n            throw 'Error pixelData length does not match frame length';\n          }\n          // since set is based on the underlying type,\n          // we need to divide the offset bytes by the byte type\n          scalarData.set(floatView, offset / bytesInFloat);\n        }\n        if (scalarData instanceof Int16Array) {\n          const bytesInInt16 = 2;\n          const intView = new Int16Array(pixelData);\n          if (intView.length !== length) {\n            throw 'Error pixelData length does not match frame length';\n          }\n          scalarData.set(intView, offset / bytesInInt16);\n        }\n        if (scalarData instanceof Uint16Array) {\n          const bytesInUint16 = 2;\n          const intView = new Uint16Array(pixelData);\n          if (intView.length !== length) {\n            throw 'Error pixelData length does not match frame length';\n          }\n          scalarData.set(intView, offset / bytesInUint16);\n        }\n        if (scalarData instanceof Uint8Array) {\n          const bytesInUint8 = 1;\n          const intView = new Uint8Array(pixelData);\n          if (intView.length !== length) {\n            throw 'Error pixelData length does not match frame length';\n          }\n          scalarData.set(intView, offset / bytesInUint8);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }\n\n    // 4D datasets load one time point at a time and the frameIndex is\n    // the position of the imageId in the current time point while the\n    // imageIdIndex is its absolute position in the array that contains\n    // all other imageIds. In a 4D dataset the frameIndex can also be\n    // calculated as `imageIdIndex % numFrames` where numFrames is the\n    // number of frames per time point. The frameIndex and imageIdIndex\n    // will be the same when working with 3D datasets.\n    const requests = imageIds.map((imageId, frameIndex) => {\n      const imageIdIndex = this.getImageIdIndex(imageId);\n\n      if (cachedFrames[imageIdIndex]) {\n        this.framesLoaded++;\n        this.framesProcessed++;\n        return;\n      }\n\n      const modalityLutModule =\n        metaData.get('modalityLutModule', imageId) || {};\n\n      const generalSeriesModule =\n        metaData.get('generalSeriesModule', imageId) || {};\n\n      const scalingParameters: Types.ScalingParameters = {\n        rescaleSlope: modalityLutModule.rescaleSlope,\n        rescaleIntercept: modalityLutModule.rescaleIntercept,\n        modality: generalSeriesModule.modality,\n      };\n\n      if (scalingParameters.modality === 'PT') {\n        const suvFactor = metaData.get('scalingModule', imageId);\n\n        if (suvFactor) {\n          this._addScalingToVolume(suvFactor);\n          scalingParameters.suvbw = suvFactor.suvbw;\n        }\n      }\n\n      const isSlopeAndInterceptNumbers =\n        typeof scalingParameters.rescaleSlope === 'number' &&\n        typeof scalingParameters.rescaleIntercept === 'number';\n\n      /**\n       * So this is has limitation right now, but we need to somehow indicate\n       * whether the volume has been scaled with the scaling parameters or not.\n       * However, each slice can have different scaling parameters but it is rare\n       * that rescale slope and intercept be unknown for one slice and known for\n       * another. So we can just check the first slice and assume that the rest\n       * of the slices have the same scaling parameters. Basically it is important\n       * that these two are numbers and that means the volume has been scaled (\n       * we do that automatically in the loader). For the suvbw, we need to\n       * somehow indicate whether the PT image has been corrected with suvbw or\n       * not, which we store it in the this.scaling.PT.suvbw.\n       */\n      this.isPreScaled = isSlopeAndInterceptNumbers;\n\n      const options = {\n        // WADO Image Loader\n        targetBuffer: {\n          // keeping this in the options means a large empty volume array buffer\n          // will be transferred to the worker. This is undesirable for streaming\n          // volume without shared array buffer because the target is now an empty\n          // 300-500MB volume array buffer. Instead the volume should be progressively\n          // set in the main thread.\n          arrayBuffer:\n            arrayBuffer instanceof ArrayBuffer ? undefined : arrayBuffer,\n          offset: frameIndex * lengthInBytes,\n          length,\n          type,\n        },\n        skipCreateImage: true,\n        preScale: {\n          enabled: true,\n          // we need to pass in the scalingParameters here, since the streaming\n          // volume loader doesn't go through the createImage phase in the loader,\n          // and therefore doesn't have the scalingParameters\n          scalingParameters,\n        },\n      };\n\n      // Use loadImage because we are skipping the Cornerstone Image cache\n      // when we load directly into the Volume cache\n      const callLoadImage = (imageId, imageIdIndex, options) => {\n        return imageLoader.loadImage(imageId, options).then(\n          (image) => {\n            // scalarData is the volume container we are progressively loading into\n            // image is the pixelData decoded from workers in cornerstoneDICOMImageLoader\n            handleArrayBufferLoad(scalarData, image, options);\n            successCallback(imageIdIndex, imageId, scalingParameters);\n          },\n          (error) => {\n            errorCallback.call(this, error, imageIdIndex, imageId);\n          }\n        );\n      };\n\n      return {\n        callLoadImage,\n        imageId,\n        imageIdIndex,\n        options,\n        priority,\n        requestType,\n        additionalDetails: {\n          volumeId: this.volumeId,\n        },\n      };\n    });\n\n    return requests;\n  };\n\n  private handleImageComingFromCache(\n    cachedImageOrVolume,\n    isFromImageCache: boolean,\n    scalingParameters: any,\n    scalarData: Types.VolumeScalarData,\n    frameIndex: number,\n    arrayBuffer: ArrayBufferLike,\n    updateTextureAndTriggerEvents: (\n      volume: BaseStreamingImageVolume,\n      imageIdIndex: any,\n      imageId: any\n    ) => void,\n    imageIdIndex: number,\n    imageId: string,\n    errorCallback: (error: any, imageIdIndex: any, imageId: any) => void\n  ) {\n    const imageLoadObject = isFromImageCache\n      ? cachedImageOrVolume.imageLoadObject\n      : cachedImageOrVolume.convertToCornerstoneImage(imageId, imageIdIndex);\n\n    imageLoadObject.promise\n      .then((cachedImage) => {\n        const imageScalarData = this._scaleIfNecessary(\n          cachedImage,\n          scalingParameters\n        );\n        // todo add scaling and slope\n        const { pixelsPerImage, bytesPerImage } = this.cornerstoneImageMetaData;\n        const TypedArray = scalarData.constructor;\n        let byteOffset = bytesPerImage * frameIndex;\n\n        // create a view on the volume arraybuffer\n        const bytePerPixel = bytesPerImage / pixelsPerImage;\n\n        if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {\n          byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;\n        }\n\n        // @ts-ignore\n        const volumeBufferView = new TypedArray(\n          arrayBuffer,\n          byteOffset,\n          pixelsPerImage\n        );\n        volumeBufferView.set(imageScalarData);\n        updateTextureAndTriggerEvents(this, imageIdIndex, imageId);\n      })\n      .catch((err) => {\n        errorCallback.call(this, err, imageIdIndex, imageId);\n      });\n  }\n\n  /**\n   * It returns the imageLoad requests for the streaming image volume instance.\n   * It involves getting all the imageIds of the volume and creating a success callback\n   * which would update the texture (when the image has loaded) and the failure callback.\n   * Note that this method does not executes the requests but only returns the requests.\n   * It can be used for sorting requests outside of the volume loader itself\n   * e.g. loading a single slice of CT, followed by a single slice of PET (interleaved), before\n   * moving to the next slice.\n   *\n   * @returns Array of requests including imageId of the request, its imageIdIndex,\n   * options (targetBuffer and scaling parameters), and additionalDetails (volumeId)\n   */\n  public getImageLoadRequests(_priority: number): any[] {\n    throw new Error('Abstract method');\n  }\n\n  private _prefetchImageIds(priority: number): void {\n    // Note: here is the correct location to set the loading flag\n    // since getImageIdsRequest is just grabbing and building requests\n    // and not actually executing them\n    this.loadStatus.loading = true;\n\n    const requests = this.getImageLoadRequests(priority);\n\n    requests.reverse().forEach((request) => {\n      if (!request) {\n        // there is a cached image for the imageId and no requests will fire\n        return;\n      }\n\n      const {\n        callLoadImage,\n        imageId,\n        imageIdIndex,\n        options,\n        priority,\n        requestType,\n        additionalDetails,\n      } = request;\n\n      imageLoadPoolManager.addRequest(\n        callLoadImage.bind(this, imageId, imageIdIndex, options),\n        requestType,\n        additionalDetails,\n        priority\n      );\n    });\n  }\n\n  /**\n   * This function decides whether or not to scale the image based on the\n   * scalingParameters. If the image is already scaled, we should take that\n   * into account when scaling the image again, so if the rescaleSlope and/or\n   * rescaleIntercept are different from the ones that were used to scale the\n   * image, we should scale the image again according to the new parameters.\n   */\n  private _scaleIfNecessary(\n    image,\n    scalingParametersToUse: Types.ScalingParameters\n  ) {\n    const imageIsAlreadyScaled = image.preScale?.scaled;\n    const noScalingParametersToUse =\n      !scalingParametersToUse ||\n      !scalingParametersToUse.rescaleIntercept ||\n      !scalingParametersToUse.rescaleSlope;\n\n    if (!imageIsAlreadyScaled && noScalingParametersToUse) {\n      // no need to scale the image\n      return image.getPixelData().slice(0);\n    }\n\n    if (\n      !imageIsAlreadyScaled &&\n      scalingParametersToUse &&\n      scalingParametersToUse.rescaleIntercept !== undefined &&\n      scalingParametersToUse.rescaleSlope !== undefined\n    ) {\n      // if not already scaled, just scale the image.\n      // copy so that it doesn't get modified\n      const pixelDataCopy = image.getPixelData().slice(0);\n      const scaledArray = scaleArray(pixelDataCopy, scalingParametersToUse);\n      return scaledArray;\n    }\n\n    // if the image is already scaled,\n    const {\n      rescaleSlope: rescaleSlopeToUse,\n      rescaleIntercept: rescaleInterceptToUse,\n      suvbw: suvbwToUse,\n    } = scalingParametersToUse;\n\n    const {\n      rescaleSlope: rescaleSlopeUsed,\n      rescaleIntercept: rescaleInterceptUsed,\n      suvbw: suvbwUsed,\n    } = image.preScale.scalingParameters;\n\n    const rescaleSlopeIsSame = rescaleSlopeToUse === rescaleSlopeUsed;\n    const rescaleInterceptIsSame =\n      rescaleInterceptToUse === rescaleInterceptUsed;\n    const suvbwIsSame = suvbwToUse === suvbwUsed;\n\n    if (rescaleSlopeIsSame && rescaleInterceptIsSame && suvbwIsSame) {\n      // if the scaling parameters are the same, we don't need to scale the image again\n      return image.getPixelData();\n    }\n\n    const pixelDataCopy = image.getPixelData().slice(0);\n    // the general formula for scaling is  scaledPixelValue = suvbw * (pixelValue * rescaleSlope) + rescaleIntercept\n    const newSuvbw = suvbwToUse / suvbwUsed;\n    const newRescaleSlope = rescaleSlopeToUse / rescaleSlopeUsed;\n    const newRescaleIntercept =\n      rescaleInterceptToUse - rescaleInterceptUsed * newRescaleSlope;\n\n    const newScalingParameters = {\n      ...scalingParametersToUse,\n      rescaleSlope: newRescaleSlope,\n      rescaleIntercept: newRescaleIntercept,\n      suvbw: newSuvbw,\n    };\n\n    const scaledArray = scaleArray(pixelDataCopy, newScalingParameters);\n    return scaledArray;\n  }\n\n  private _addScalingToVolume(suvFactor) {\n    // Todo: handle case where suvFactors are not the same for all frames\n    if (this.scaling) {\n      return;\n    }\n\n    const { suvbw, suvlbm, suvbsa } = suvFactor;\n\n    const petScaling = <Types.PTScaling>{};\n\n    if (suvlbm) {\n      petScaling.suvbwToSuvlbm = suvlbm / suvbw;\n    }\n\n    if (suvbsa) {\n      petScaling.suvbwToSuvbsa = suvbsa / suvbw;\n    }\n\n    if (suvbw) {\n      petScaling.suvbw = suvbw;\n    }\n\n    this.scaling = { PT: petScaling };\n  }\n\n  private _removeFromCache() {\n    // TODO: not 100% sure this is the same Id as the volume loader's volumeId?\n    // so I have no idea if this will work\n    cache.removeVolumeLoadObject(this.volumeId);\n  }\n\n  /**\n   * Converts the requested imageId inside the volume to a cornerstoneImage\n   * object. It uses the typedArray set method to copy the pixelData from the\n   * correct offset in the scalarData to a new array for the image\n   *\n   * @param imageId - the imageId of the image to be converted\n   * @param imageIdIndex - the index of the imageId in the imageIds array\n   * @returns image object containing the pixel data, metadata, and other information\n   */\n  public getCornerstoneImage(\n    imageId: string,\n    imageIdIndex: number\n  ): Types.IImage {\n    const { imageIds } = this;\n    const frameIndex = this._imageIdIndexToFrameIndex(imageIdIndex);\n\n    const {\n      bytesPerImage,\n      pixelsPerImage,\n      windowCenter,\n      windowWidth,\n      numComponents,\n      color,\n      dimensions,\n      spacing,\n      invert,\n      voiLUTFunction,\n      photometricInterpretation,\n    } = this.cornerstoneImageMetaData;\n\n    // 1. Grab the buffer and it's type\n    const scalarData = this._getScalarDataByImageIdIndex(imageIdIndex);\n    const volumeBuffer = scalarData.buffer;\n    // (not sure if this actually works, TypeScript keeps complaining)\n    const TypedArray = scalarData.constructor;\n\n    // 2. Given the index of the image and frame length in bytes,\n    //    create a view on the volume arraybuffer\n    const bytePerPixel = bytesPerImage / pixelsPerImage;\n\n    let byteOffset = bytesPerImage * frameIndex;\n\n    // If there is a discrepancy between the volume typed array\n    // and the bitsAllocated for the image. The reason is that VTK uses Float32\n    // on the GPU and if the type is not Float32, it will convert it. So for not\n    // having a performance issue, we convert all types initially to Float32 even\n    // if they are not Float32.\n    if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {\n      byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;\n    }\n\n    // 3. Create a new TypedArray of the same type for the new\n    //    Image that will be created\n    // @ts-ignore\n    const imageScalarData = new TypedArray(pixelsPerImage);\n    // @ts-ignore\n    const volumeBufferView = new TypedArray(\n      volumeBuffer,\n      byteOffset,\n      pixelsPerImage\n    );\n\n    // 4. Use e.g. TypedArray.set() to copy the data from the larger\n    //    buffer's view into the smaller one\n    imageScalarData.set(volumeBufferView);\n\n    // 5. Create an Image Object from imageScalarData and put it into the Image cache\n    const volumeImageId = imageIds[imageIdIndex];\n    const modalityLutModule =\n      metaData.get('modalityLutModule', volumeImageId) || {};\n    const minMax = getMinMax(imageScalarData);\n    const intercept = modalityLutModule.rescaleIntercept\n      ? modalityLutModule.rescaleIntercept\n      : 0;\n\n    return {\n      imageId,\n      intercept,\n      windowCenter,\n      windowWidth,\n      voiLUTFunction,\n      color,\n      rgba: false,\n      numComps: numComponents,\n      // Note the dimensions were defined as [Columns, Rows, Frames]\n      rows: dimensions[1],\n      columns: dimensions[0],\n      sizeInBytes: imageScalarData.byteLength,\n      getPixelData: () => imageScalarData,\n      minPixelValue: minMax.min,\n      maxPixelValue: minMax.max,\n      slope: modalityLutModule.rescaleSlope\n        ? modalityLutModule.rescaleSlope\n        : 1,\n      getCanvas: undefined, // todo: which canvas?\n      height: dimensions[0],\n      width: dimensions[1],\n      columnPixelSpacing: spacing[0],\n      rowPixelSpacing: spacing[1],\n      invert,\n      photometricInterpretation,\n    };\n  }\n\n  /**\n   * Converts the requested imageId inside the volume to a cornerstoneImage\n   * object. It uses the typedArray set method to copy the pixelData from the\n   * correct offset in the scalarData to a new array for the image\n   * Duplicate of getCornerstoneImageLoadObject for legacy reasons\n   *\n   * @param imageId - the imageId of the image to be converted\n   * @param imageIdIndex - the index of the imageId in the imageIds array\n   * @returns imageLoadObject containing the promise that resolves\n   * to the cornerstone image\n   */\n  public convertToCornerstoneImage(\n    imageId: string,\n    imageIdIndex: number\n  ): Types.IImageLoadObject {\n    return this.getCornerstoneImageLoadObject(imageId, imageIdIndex);\n  }\n\n  /**\n   * Converts the requested imageId inside the volume to a cornerstoneImage\n   * object. It uses the typedArray set method to copy the pixelData from the\n   * correct offset in the scalarData to a new array for the image\n   *\n   * @param imageId - the imageId of the image to be converted\n   * @param imageIdIndex - the index of the imageId in the imageIds array\n   * @returns imageLoadObject containing the promise that resolves\n   * to the cornerstone image\n   */\n  public getCornerstoneImageLoadObject(\n    imageId: string,\n    imageIdIndex: number\n  ): Types.IImageLoadObject {\n    const image = this.getCornerstoneImage(imageId, imageIdIndex);\n\n    const imageLoadObject = {\n      promise: Promise.resolve(image),\n    };\n\n    return imageLoadObject;\n  }\n\n  /**\n   * Returns an array of all the volume's images as Cornerstone images.\n   * It iterates over all the imageIds and converts them to Cornerstone images.\n   *\n   * @returns An array of Cornerstone images.\n   */\n  public getCornerstoneImages(): Types.IImage[] {\n    const { imageIds } = this;\n\n    return imageIds.map((imageId, imageIdIndex) => {\n      return this.getCornerstoneImage(imageId, imageIdIndex);\n    });\n  }\n\n  /**\n   * Converts all the volume images (imageIds) to cornerstoneImages and caches them.\n   * It iterates over all the imageIds and convert them until there is no\n   * enough space left inside the imageCache. Finally it will decache the Volume.\n   *\n   */\n  private _convertToImages() {\n    // 1. Try to decache images in the volatile Image Cache to provide\n    //    enough space to store another entire copy of the volume (as Images).\n    //    If we do not have enough, we will store as many images in the cache\n    //    as possible, and the rest of the volume will be decached.\n    const byteLength = this.sizeInBytes;\n    const numImages = this.imageIds.length;\n    const { bytesPerImage } = this.cornerstoneImageMetaData;\n\n    let bytesRemaining = cache.decacheIfNecessaryUntilBytesAvailable(\n      byteLength,\n      this.imageIds\n    );\n\n    for (let imageIdIndex = 0; imageIdIndex < numImages; imageIdIndex++) {\n      const imageId = this.imageIds[imageIdIndex];\n\n      bytesRemaining = bytesRemaining - bytesPerImage;\n\n      // 2. Convert each imageId to a cornerstone Image object which is\n      // resolved inside the promise of imageLoadObject\n      const imageLoadObject = this.convertToCornerstoneImage(\n        imageId,\n        imageIdIndex\n      );\n\n      // 3. Caching the image\n      if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\n          console.error(err);\n        });\n      }\n\n      // 4. If we know we won't be able to add another Image to the cache\n      //    without breaching the limit, stop here.\n      if (bytesRemaining <= bytesPerImage) {\n        break;\n      }\n    }\n    // 5. When as much of the Volume is processed into Images as possible\n    //    without breaching the cache limit, remove the Volume\n    this._removeFromCache();\n  }\n\n  /**\n   * If completelyRemove is true, remove the volume completely from the cache. Otherwise,\n   * convert the volume to cornerstone images (stack images) and store it in the cache\n   * @param completelyRemove - If true, the image will be removed from the\n   * cache completely.\n   */\n  public decache(completelyRemove = false): void {\n    if (completelyRemove) {\n      this._removeFromCache();\n    } else {\n      this._convertToImages();\n    }\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport BaseStreamingImageVolume from './BaseStreamingImageVolume';\n\n/**\n * Streaming Image Volume Class that extends ImageVolume base class.\n * It implements load method to load the imageIds and insert them into the volume.\n */\nexport default class StreamingImageVolume extends BaseStreamingImageVolume {\n  constructor(\n    imageVolumeProperties: Types.IVolume,\n    streamingProperties: Types.IStreamingVolumeProperties\n  ) {\n    super(imageVolumeProperties, streamingProperties);\n  }\n\n  /**\n   * Return the scalar data (buffer)\n   * @returns volume scalar data\n   */\n  public getScalarData(): Types.VolumeScalarData {\n    return <Types.VolumeScalarData>this.scalarData;\n  }\n\n  /**\n   * It returns the imageLoad requests for the streaming image volume instance.\n   * It involves getting all the imageIds of the volume and creating a success callback\n   * which would update the texture (when the image has loaded) and the failure callback.\n   * Note that this method does not executes the requests but only returns the requests.\n   * It can be used for sorting requests outside of the volume loader itself\n   * e.g. loading a single slice of CT, followed by a single slice of PET (interleaved), before\n   * moving to the next slice.\n   *\n   * @returns Array of requests including imageId of the request, its imageIdIndex,\n   * options (targetBuffer and scaling parameters), and additionalDetails (volumeId)\n   */\n  public getImageLoadRequests = (priority: number) => {\n    const { imageIds } = this;\n    const scalarData = <Types.VolumeScalarData>this.scalarData;\n\n    return this.getImageIdsRequests(imageIds, scalarData, priority);\n  };\n}\n","import {\n  cache,\n  utilities,\n  Enums,\n  imageLoader,\n  imageLoadPoolManager,\n  getShouldUseSharedArrayBuffer,\n  getConfiguration,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { makeVolumeMetadata, sortImageIdsAndGetSpacing } from './helpers';\nimport StreamingImageVolume from './StreamingImageVolume';\n\nconst {\n  createUint8SharedArray,\n  createFloat32SharedArray,\n  createUint16SharedArray,\n  createInt16SharedArray,\n} = utilities;\n\ninterface IVolumeLoader {\n  promise: Promise<StreamingImageVolume>;\n  cancel: () => void;\n  decache: () => void;\n}\n\n/**\n * It handles loading of a image by streaming in its imageIds. It will be the\n * volume loader if the schema for the volumeID is `cornerstoneStreamingImageVolume`.\n * This function returns a promise that resolves to the StreamingImageVolume instance.\n *\n * In order to use the cornerstoneStreamingImageVolumeLoader you should use\n * createAndCacheVolume helper from the cornerstone-core volumeLoader module.\n *\n * @param volumeId - The ID of the volume\n * @param options - options for loading, imageIds\n * @returns a promise that resolves to a StreamingImageVolume\n */\nfunction cornerstoneStreamingImageVolumeLoader(\n  volumeId: string,\n  options: {\n    imageIds: string[];\n  }\n): IVolumeLoader {\n  if (!options || !options.imageIds || !options.imageIds.length) {\n    throw new Error(\n      'ImageIds must be provided to create a streaming image volume'\n    );\n  }\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getConfiguration().rendering;\n  const use16BitDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  async function getStreamingImageVolume() {\n    /**\n     * Check if we are using the `wadouri:` scheme, and if so, preload first,\n     * middle, and last image metadata as these are the images the current\n     * streaming image loader may explicitly request metadata from. The last image\n     * metadata would only be specifically requested if the imageId array order is\n     * reversed in the `sortImageIdsAndGetSpacing.ts` file.\n     */\n    if (options.imageIds[0].split(':')[0] === 'wadouri') {\n      const [middleImageIndex, lastImageIndex] = [\n        Math.floor(options.imageIds.length / 2),\n        options.imageIds.length - 1,\n      ];\n      const indexesToPrefetch = [0, middleImageIndex, lastImageIndex];\n      await Promise.all(\n        indexesToPrefetch.map((index) => {\n          return new Promise((resolve, reject) => {\n            const imageId = options.imageIds[index];\n            imageLoadPoolManager.addRequest(\n              async () => {\n                imageLoader\n                  .loadImage(imageId)\n                  .then(() => {\n                    console.log(`Prefetched imageId: ${imageId}`);\n                    resolve(true);\n                  })\n                  .catch((err) => {\n                    reject(err);\n                  });\n              },\n              Enums.RequestType.Prefetch,\n              { volumeId },\n              1 // priority\n            );\n          });\n        })\n      ).catch(console.error);\n    }\n\n    const { imageIds } = options;\n\n    const volumeMetadata = makeVolumeMetadata(imageIds);\n\n    // For a streaming volume, the data type cannot rely on cswil to load\n    // the proper array buffer type. This is because the target buffer container\n    // must be decided ahead of time.\n    // TODO: move this logic into CSWIL to avoid logic duplication.\n    // We check if scaling parameters are negative we choose Int16 instead of\n    // Uint16 for cases where BitsAllocated is 16.\n    const imageIdIndex = Math.floor(imageIds.length / 2);\n    const imageId = imageIds[imageIdIndex];\n    const scalingParameters = csUtils.getScalingParameters(imageId);\n    const hasNegativeRescale =\n      scalingParameters.rescaleIntercept < 0 ||\n      scalingParameters.rescaleSlope < 0;\n\n    // The prescale is ALWAYS used with modality LUT, so we can assume that\n    // if the rescale slope is not an integer, we need to use Float32\n    const hasFloatRescale =\n      scalingParameters.rescaleIntercept % 1 !== 0 ||\n      scalingParameters.rescaleSlope % 1 !== 0;\n\n    const {\n      BitsAllocated,\n      PixelRepresentation,\n      PhotometricInterpretation,\n      ImageOrientationPatient,\n      PixelSpacing,\n      Columns,\n      Rows,\n    } = volumeMetadata;\n\n    const rowCosineVec = vec3.fromValues(\n      ImageOrientationPatient[0],\n      ImageOrientationPatient[1],\n      ImageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      ImageOrientationPatient[3],\n      ImageOrientationPatient[4],\n      ImageOrientationPatient[5]\n    );\n\n    const scanAxisNormal = vec3.create();\n\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n\n    const { zSpacing, origin, sortedImageIds } = sortImageIdsAndGetSpacing(\n      imageIds,\n      scanAxisNormal\n    );\n\n    const numFrames = imageIds.length;\n\n    // Spacing goes [1] then [0], as [1] is column spacing (x) and [0] is row spacing (y)\n    const spacing = <Types.Point3>[PixelSpacing[1], PixelSpacing[0], zSpacing];\n    const dimensions = <Types.Point3>[Columns, Rows, numFrames];\n    const direction = [\n      ...rowCosineVec,\n      ...colCosineVec,\n      ...scanAxisNormal,\n    ] as Types.Mat3;\n    const signed = PixelRepresentation === 1;\n    const numComponents = PhotometricInterpretation === 'RGB' ? 3 : 1;\n    const useSharedArrayBuffer = getShouldUseSharedArrayBuffer();\n    const length = dimensions[0] * dimensions[1] * dimensions[2];\n    const handleCache = (sizeInBytes) => {\n      if (!cache.isCacheable(sizeInBytes)) {\n        throw new Error(Enums.Events.CACHE_SIZE_EXCEEDED);\n      }\n      cache.decacheIfNecessaryUntilBytesAvailable(sizeInBytes);\n    };\n\n    let scalarData, sizeInBytes;\n    switch (BitsAllocated) {\n      case 8:\n        if (signed) {\n          throw new Error(\n            '8 Bit signed images are not yet supported by this plugin.'\n          );\n        }\n        sizeInBytes = length * numComponents;\n        handleCache(sizeInBytes);\n        scalarData = useSharedArrayBuffer\n          ? createUint8SharedArray(length * numComponents)\n          : new Uint8Array(length * numComponents);\n        break;\n\n      case 16:\n        // Temporary fix for 16 bit images to use Float32\n        // until the new dicom image loader handler the conversion\n        // correctly\n        if (!use16BitDataType || hasFloatRescale) {\n          sizeInBytes = length * 4;\n          scalarData = useSharedArrayBuffer\n            ? createFloat32SharedArray(length)\n            : new Float32Array(length);\n\n          break;\n        }\n\n        sizeInBytes = length * 2;\n        if (signed || hasNegativeRescale) {\n          handleCache(sizeInBytes);\n          scalarData = useSharedArrayBuffer\n            ? createInt16SharedArray(length)\n            : new Int16Array(length);\n          break;\n        }\n\n        if (!signed && !hasNegativeRescale) {\n          handleCache(sizeInBytes);\n          scalarData = useSharedArrayBuffer\n            ? createUint16SharedArray(length)\n            : new Uint16Array(length);\n          break;\n        }\n\n        // Default to Float32 again\n        sizeInBytes = length * 4;\n        handleCache(sizeInBytes);\n        scalarData = useSharedArrayBuffer\n          ? createFloat32SharedArray(length)\n          : new Float32Array(length);\n        break;\n\n      case 24:\n        sizeInBytes = length * numComponents;\n        handleCache(sizeInBytes);\n\n        // hacky because we don't support alpha channel in dicom\n        scalarData = useSharedArrayBuffer\n          ? createUint8SharedArray(length * numComponents)\n          : new Uint8Array(length * numComponents);\n        break;\n    }\n\n    const streamingImageVolume = new StreamingImageVolume(\n      // ImageVolume properties\n      {\n        volumeId,\n        metadata: volumeMetadata,\n        dimensions,\n        spacing,\n        origin,\n        direction,\n        scalarData,\n        sizeInBytes,\n      },\n      // Streaming properties\n      {\n        imageIds: sortedImageIds,\n        loadStatus: {\n          // todo: loading and loaded should be on ImageVolume\n          loaded: false,\n          loading: false,\n          cancelled: false,\n          cachedFrames: [],\n          callbacks: [],\n        },\n      }\n    );\n\n    return streamingImageVolume;\n  }\n\n  const streamingImageVolumePromise = getStreamingImageVolume();\n\n  return {\n    promise: streamingImageVolumePromise,\n    decache: () => {\n      streamingImageVolumePromise.then((streamingImageVolume) => {\n        streamingImageVolume.destroy();\n        streamingImageVolume = null;\n      });\n    },\n    cancel: () => {\n      streamingImageVolumePromise.then((streamingImageVolume) => {\n        streamingImageVolume.cancelLoading();\n      });\n    },\n  };\n}\n\nexport default cornerstoneStreamingImageVolumeLoader;\n","import { metaData } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * It creates a metadata object for a volume given the imageIds that compose it.\n * It uses the first imageId to get the metadata.\n *\n * @param imageIds - array of imageIds\n * @returns The volume metadata\n */\nexport default function makeVolumeMetadata(\n  imageIds: Array<string>\n): Types.Metadata {\n  const imageId0 = imageIds[0];\n\n  const {\n    pixelRepresentation,\n    bitsAllocated,\n    bitsStored,\n    highBit,\n    photometricInterpretation,\n    samplesPerPixel,\n  } = metaData.get('imagePixelModule', imageId0);\n\n  // Add list of VOIs stored on the DICOM.\n  const voiLut = [];\n\n  const voiLutModule = metaData.get('voiLutModule', imageId0);\n\n  // voiLutModule is not always present\n  let voiLUTFunction;\n  if (voiLutModule) {\n    const { windowWidth, windowCenter } = voiLutModule;\n    voiLUTFunction = voiLutModule?.voiLUTFunction;\n\n    if (Array.isArray(windowWidth)) {\n      for (let i = 0; i < windowWidth.length; i++) {\n        voiLut.push({\n          windowWidth: windowWidth[i],\n          windowCenter: windowCenter[i],\n        });\n      }\n    } else {\n      voiLut.push({\n        windowWidth: windowWidth,\n        windowCenter: windowCenter,\n      });\n    }\n  } else {\n    voiLut.push({\n      windowWidth: undefined,\n      windowCenter: undefined,\n    });\n  }\n\n  const { modality, seriesInstanceUID } = metaData.get(\n    'generalSeriesModule',\n    imageId0\n  );\n\n  const {\n    imageOrientationPatient,\n    pixelSpacing,\n    frameOfReferenceUID,\n    columns,\n    rows,\n  } = metaData.get('imagePlaneModule', imageId0);\n\n  // Map to dcmjs-style keywords. This is becoming the standard and makes it\n  // Easier to swap out cornerstoneDICOMImageLoader at a later date.\n  return {\n    BitsAllocated: bitsAllocated,\n    BitsStored: bitsStored,\n    SamplesPerPixel: samplesPerPixel,\n    HighBit: highBit,\n    PhotometricInterpretation: photometricInterpretation,\n    PixelRepresentation: pixelRepresentation,\n    Modality: modality,\n    ImageOrientationPatient: imageOrientationPatient,\n    PixelSpacing: pixelSpacing,\n    FrameOfReferenceUID: frameOfReferenceUID,\n    Columns: columns,\n    Rows: rows,\n    // This is a reshaped object and not a dicom tag:\n    voiLut,\n    VOILUTFunction: voiLUTFunction,\n    SeriesInstanceUID: seriesInstanceUID,\n  };\n}\n","import * as cornerstone from '@cornerstonejs/core';\nimport { volumeLoader } from '@cornerstonejs/core';\nimport { cornerstoneStreamingImageVolumeLoader } from '@cornerstonejs/streaming-image-volume-loader';\nimport dicomImageLoader, { webWorkerManager } from '@cornerstonejs/dicom-image-loader';\nimport dicomParser from 'dicom-parser';\nimport { errorHandler, utils } from '@ohif/core';\n\nconst { registerVolumeLoader } = volumeLoader;\n\nlet initialized = false;\n\nfunction initWebWorkers(appConfig) {\n  const config = {\n    maxWebWorkers: Math.min(\n      Math.max(navigator.hardwareConcurrency - 1, 1),\n      appConfig.maxNumberOfWebWorkers\n    ),\n    startWebWorkersOnDemand: true,\n    taskConfiguration: {\n      decodeTask: {\n        initializeCodecsOnStartup: false,\n        usePDFJS: false,\n        strict: false,\n      },\n    },\n  };\n\n  if (!initialized) {\n    dicomImageLoader.webWorkerManager.initialize(config);\n    initialized = true;\n  }\n}\n\nexport default function initWADOImageLoader(\n  userAuthenticationService,\n  appConfig,\n  extensionManager\n) {\n  dicomImageLoader.external.cornerstone = cornerstone;\n  dicomImageLoader.external.dicomParser = dicomParser;\n\n  registerVolumeLoader('cornerstoneStreamingImageVolume', cornerstoneStreamingImageVolumeLoader);\n\n  dicomImageLoader.configure({\n    decodeConfig: {\n      // !! IMPORTANT !!\n      // We should set this flag to false, since, by default @cornerstonejs/dicom-image-loader\n      // will convert everything to integers (to be able to work with cornerstone-2d).\n      // Until the default is set to true (which is the case for cornerstone3D),\n      // we should set this flag to false.\n      convertFloatPixelDataToInt: false,\n      use16BitDataType: Boolean(appConfig.use16BitDataType),\n    },\n    beforeSend: function (xhr) {\n      //TODO should be removed in the future and request emitted by DicomWebDataSource\n      const sourceConfig = extensionManager.getActiveDataSource()?.[0].getConfig() ?? {};\n      const headers = userAuthenticationService.getAuthorizationHeader();\n      const acceptHeader = utils.generateAcceptHeader(\n        sourceConfig.acceptHeader,\n        sourceConfig.requestTransferSyntaxUID,\n        sourceConfig.omitQuotationForMultipartRequest\n      );\n\n      const xhrRequestHeaders = {\n        Accept: acceptHeader,\n      };\n\n      if (headers) {\n        Object.assign(xhrRequestHeaders, headers);\n      }\n\n      return xhrRequestHeaders;\n    },\n    errorInterceptor: error => {\n      errorHandler.getHTTPErrorHandler(error);\n    },\n  });\n\n  initWebWorkers(appConfig);\n}\n\nexport function destroy() {\n  // Note: we don't want to call .terminate on the webWorkerManager since\n  // that resets the config\n  const webWorkers = webWorkerManager.webWorkers;\n  for (let i = 0; i < webWorkers.length; i++) {\n    webWorkers[i].worker.terminate();\n  }\n  webWorkers.length = 0;\n}\n","import React from 'react';\nimport { Input, Dialog, ButtonEnums } from '@ohif/ui';\n\n/**\n *\n * @param {*} data\n * @param {*} data.text\n * @param {*} data.label\n * @param {*} event\n * @param {*} callback\n * @param {*} isArrowAnnotateInputDialog\n * @param {*} dialogConfig\n * @param {string?} dialogConfig.dialogTitle - title of the input dialog\n * @param {string?} dialogConfig.inputLabel - show label above the input\n */\nfunction callInputDialog(\n  uiDialogService,\n  data,\n  callback,\n  isArrowAnnotateInputDialog = true,\n  dialogConfig: any = {}\n) {\n  const dialogId = 'dialog-enter-annotation';\n  const label = data ? (isArrowAnnotateInputDialog ? data.text : data.label) : '';\n  const {\n    dialogTitle = 'Annotation',\n    inputLabel = 'Enter your annotation',\n    validateFunc = value => true,\n  } = dialogConfig;\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        if (typeof validateFunc === 'function' && !validateFunc(value.label)) {\n          return;\n        }\n\n        callback(value.label, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: dialogTitle,\n        value: { label },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: ButtonEnums.type.secondary },\n          { id: 'save', text: 'Save', type: ButtonEnums.type.primary },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          return (\n            <Input\n              autoFocus\n              className=\"border-primary-main bg-black\"\n              type=\"text\"\n              id=\"annotation\"\n              label={inputLabel}\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              value={value.label}\n              onChange={event => {\n                event.persist();\n                setValue(value => ({ ...value, label: event.target.value }));\n              }}\n              onKeyPress={event => {\n                if (event.key === 'Enter') {\n                  onSubmitHandler({ value, action: { id: 'save' } });\n                }\n              }}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callInputDialog;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { IEnabledElement } from '@cornerstonejs/core/dist/esm/types';\n\nimport { getEnabledElement as OHIFgetEnabledElement } from '../state';\n\nexport default function getActiveViewportEnabledElement(viewportGridService): IEnabledElement {\n  const { activeViewportId } = viewportGridService.getState();\n  const { element } = OHIFgetEnabledElement(activeViewportId) || {};\n  const enabledElement = getEnabledElement(element);\n  return enabledElement;\n}\n","import { metaData } from '@cornerstonejs/core';\nimport { LengthTool, utilities } from '@cornerstonejs/tools';\nimport callInputDialog from '../utils/callInputDialog';\nimport getActiveViewportEnabledElement from '../utils/getActiveViewportEnabledElement';\n\nconst { calibrateImageSpacing } = utilities;\n\n/**\n * Calibration Line tool works almost the same as the\n */\nclass CalibrationLineTool extends LengthTool {\n  static toolName = 'CalibrationLine';\n\n  _renderingViewport: any;\n  _lengthToolRenderAnnotation = this.renderAnnotation;\n\n  renderAnnotation = (enabledElement, svgDrawingHelper) => {\n    const { viewport } = enabledElement;\n    this._renderingViewport = viewport;\n    return this._lengthToolRenderAnnotation(enabledElement, svgDrawingHelper);\n  };\n\n  _getTextLines(data, targetId) {\n    const [canvasPoint1, canvasPoint2] = data.handles.points.map(p =>\n      this._renderingViewport.worldToCanvas(p)\n    );\n    // for display, round to 2 decimal points\n    const lengthPx = Math.round(calculateLength2(canvasPoint1, canvasPoint2) * 100) / 100;\n\n    const textLines = [`${lengthPx}px`];\n\n    return textLines;\n  }\n}\n\nfunction calculateLength2(point1, point2) {\n  const dx = point1[0] - point2[0];\n  const dy = point1[1] - point2[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction calculateLength3(pos1, pos2) {\n  const dx = pos1[0] - pos2[0];\n  const dy = pos1[1] - pos2[1];\n  const dz = pos1[2] - pos2[2];\n\n  return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nexport default CalibrationLineTool;\n\nexport function onCompletedCalibrationLine(servicesManager, csToolsEvent) {\n  const { uiDialogService, viewportGridService } = servicesManager.services;\n\n  // calculate length (mm) with the current Pixel Spacing\n  const annotationAddedEventDetail = csToolsEvent.detail;\n  const {\n    annotation: { metadata, data: annotationData },\n  } = annotationAddedEventDetail;\n  const { referencedImageId: imageId } = metadata;\n  const enabledElement = getActiveViewportEnabledElement(viewportGridService);\n  const { viewport } = enabledElement;\n\n  const length =\n    Math.round(\n      calculateLength3(annotationData.handles.points[0], annotationData.handles.points[1]) * 100\n    ) / 100;\n\n  // calculate the currently applied pixel spacing on the viewport\n  const calibratedPixelSpacing = metaData.get('calibratedPixelSpacing', imageId);\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n  const currentRowPixelSpacing =\n    calibratedPixelSpacing?.[0] || imagePlaneModule?.rowPixelSpacing || 1;\n  const currentColumnPixelSpacing =\n    calibratedPixelSpacing?.[1] || imagePlaneModule?.columnPixelSpacing || 1;\n\n  const adjustCalibration = newLength => {\n    const spacingScale = newLength / length;\n\n    // trigger resize of the viewport to adjust the world/pixel mapping\n    calibrateImageSpacing(imageId, viewport.getRenderingEngine(), {\n      type: 'User',\n      scale: 1 / spacingScale,\n    });\n  };\n\n  return new Promise((resolve, reject) => {\n    if (!uiDialogService) {\n      reject('UIDialogService is not initiated');\n      return;\n    }\n\n    callInputDialog(\n      uiDialogService,\n      {\n        text: '',\n        label: `${length}`,\n      },\n      (value, id) => {\n        if (id === 'save') {\n          adjustCalibration(Number.parseFloat(value));\n          resolve(true);\n        } else {\n          reject('cancel');\n        }\n      },\n      false,\n      {\n        dialogTitle: 'Calibration',\n        inputLabel: 'Actual Physical distance (mm)',\n\n        // the input value must be a number\n        validateFunc: val => {\n          try {\n            const v = Number.parseFloat(val);\n            return !isNaN(v) && v !== 0.0;\n          } catch {\n            return false;\n          }\n        },\n      }\n    );\n  });\n}\n","import { VolumeViewport, metaData } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { IStackViewport, IVolumeViewport, Point3 } from '@cornerstonejs/core/dist/esm/types';\nimport { AnnotationDisplayTool, drawing } from '@cornerstonejs/tools';\nimport { guid } from '@ohif/core/src/utils';\n\ninterface CachedStat {\n  color: number[]; // [r, g, b, a]\n  overlays: {\n    // ...overlayPlaneModule\n    _id: string;\n    type: 'G' | 'R'; // G for Graphics, R for ROI\n    color?: number[]; // Rendered color [r, g, b, a]\n    dataUrl?: string; // Rendered image in Data URL expression\n  }[];\n}\n\n/**\n * Image Overlay Viewer tool is not a traditional tool that requires user interactin.\n * But it is used to display Pixel Overlays. And it will provide toggling capability.\n *\n * The documentation for Overlay Plane Module of DICOM can be found in [C.9.2 of\n * Part-3 of DICOM standard](https://dicom.nema.org/medical/dicom/2018b/output/chtml/part03/sect_C.9.2.html)\n *\n * Image Overlay rendered by this tool can be toggled on and off using\n * toolGroup.setToolEnabled() and toolGroup.setToolDisabled()\n */\nclass ImageOverlayViewerTool extends AnnotationDisplayTool {\n  static toolName = 'ImageOverlayViewer';\n  private _cachedOverlayMetadata: Map<string, any[]> = new Map();\n  private _cachedStats: { [key: string]: CachedStat } = {};\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: [],\n      configuration: {\n        fillColor: [255, 127, 127, 255],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolDisabled = (): void => {\n    this._cachedStats = {};\n    this._cachedOverlayMetadata = new Map();\n  };\n\n  protected getReferencedImageId(viewport: IStackViewport | IVolumeViewport): string {\n    if (viewport instanceof VolumeViewport) {\n      return;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    return targetId.split('imageId:')[1];\n  }\n\n  renderAnnotation = (enabledElement, svgDrawingHelper) => {\n    const { viewport } = enabledElement;\n\n    const imageId = this.getReferencedImageId(viewport);\n    if (!imageId) {\n      return;\n    }\n\n    const overlays =\n      this._cachedOverlayMetadata.get(imageId) ??\n      metaData.get('overlayPlaneModule', imageId)?.overlays;\n\n    // no overlays\n    if (!overlays?.length) {\n      return;\n    }\n\n    this._cachedOverlayMetadata.set(imageId, overlays);\n\n    this._getCachedStat(imageId, overlays, this.configuration.fillColor).then(cachedStat => {\n      cachedStat.overlays.forEach(overlay => {\n        this._renderOverlay(enabledElement, svgDrawingHelper, overlay);\n      });\n    });\n\n    return true;\n  };\n\n  /**\n   * Render to DOM\n   *\n   * @param enabledElement\n   * @param svgDrawingHelper\n   * @param overlayData\n   * @returns\n   */\n  private _renderOverlay(enabledElement, svgDrawingHelper, overlayData) {\n    const { viewport } = enabledElement;\n    const imageId = this.getReferencedImageId(viewport);\n    if (!imageId) {\n      return;\n    }\n\n    // Decide the rendering position of the overlay image on the current canvas\n    const { _id, columns: width, rows: height, x, y } = overlayData;\n    const overlayTopLeftWorldPos = utilities.imageToWorldCoords(imageId, [\n      x - 1, // Remind that top-left corner's (x, y) is be (1, 1)\n      y - 1,\n    ]);\n    const overlayTopLeftOnCanvas = viewport.worldToCanvas(overlayTopLeftWorldPos);\n    const overlayBottomRightWorldPos = utilities.imageToWorldCoords(imageId, [width, height]);\n    const overlayBottomRightOnCanvas = viewport.worldToCanvas(overlayBottomRightWorldPos);\n\n    // add image to the annotations svg layer\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = `image-overlay-${_id}`;\n    const existingImageElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n    const attributes = {\n      'data-id': svgNodeHash,\n      width: overlayBottomRightOnCanvas[0] - overlayTopLeftOnCanvas[0],\n      height: overlayBottomRightOnCanvas[1] - overlayTopLeftOnCanvas[1],\n      x: overlayTopLeftOnCanvas[0],\n      y: overlayTopLeftOnCanvas[1],\n      href: overlayData.dataUrl,\n    };\n\n    if (\n      isNaN(attributes.x) ||\n      isNaN(attributes.y) ||\n      isNaN(attributes.width) ||\n      isNaN(attributes.height)\n    ) {\n      console.warn('Invalid rendering attribute for image overlay', attributes['data-id']);\n      return false;\n    }\n\n    if (existingImageElement) {\n      drawing.setAttributesIfNecessary(attributes, existingImageElement);\n      svgDrawingHelper.setNodeTouched(svgNodeHash);\n    } else {\n      const newImageElement = document.createElementNS(svgns, 'image');\n      drawing.setNewAttributesIfValid(attributes, newImageElement);\n      svgDrawingHelper.appendNode(newImageElement, svgNodeHash);\n    }\n    return true;\n  }\n\n  private async _getCachedStat(\n    imageId: string,\n    overlayMetadata: any[],\n    color: number[]\n  ): Promise<CachedStat> {\n    if (this._cachedStats[imageId] && this._isSameColor(this._cachedStats[imageId].color, color)) {\n      return this._cachedStats[imageId];\n    }\n\n    const overlays = await Promise.all(\n      overlayMetadata\n        .filter(overlay => overlay.pixelData)\n        .map(async (overlay, idx) => {\n          let pixelData = null;\n          if (overlay.pixelData.Value) {\n            pixelData = overlay.pixelData.Value;\n          } else if (overlay.pixelData.retrieveBulkData) {\n            pixelData = await overlay.pixelData.retrieveBulkData();\n          }\n\n          if (!pixelData) {\n            return;\n          }\n\n          const dataUrl = this._renderOverlayToDataUrl(\n            { width: overlay.columns, height: overlay.rows },\n            color,\n            pixelData\n          );\n\n          return {\n            ...overlay,\n            _id: guid(),\n            dataUrl, // this will be a data url expression of the rendered image\n            color,\n          };\n        })\n    );\n\n    this._cachedStats[imageId] = {\n      color: color,\n      overlays: overlays.filter(overlay => overlay),\n    };\n\n    return this._cachedStats[imageId];\n  }\n\n  /**\n   * compare two RGBA expression of colors.\n   *\n   * @param color1\n   * @param color2\n   * @returns\n   */\n  private _isSameColor(color1: number[], color2: number[]) {\n    return (\n      color1 &&\n      color2 &&\n      color1[0] === color2[0] &&\n      color1[1] === color2[1] &&\n      color1[2] === color2[2] &&\n      color1[3] === color2[3]\n    );\n  }\n\n  /**\n   * pixelData of overlayPlane module is an array of bits corresponding\n   * to each of the underlying pixels of the image.\n   * Let's create pixel data from bit array of overlay data\n   *\n   * @param pixelDataRaw\n   * @param color\n   * @returns\n   */\n  private _renderOverlayToDataUrl({ width, height }, color, pixelDataRaw) {\n    const pixelDataView = new DataView(pixelDataRaw);\n    const totalBits = width * height;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, width, height); // make it transparent\n    ctx.globalCompositeOperation = 'copy';\n\n    const imageData = ctx.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    for (let i = 0, bitIdx = 0, byteIdx = 0; i < totalBits; i++) {\n      if (pixelDataView.getUint8(byteIdx) & (1 << bitIdx)) {\n        data[i * 4] = color[0];\n        data[i * 4 + 1] = color[1];\n        data[i * 4 + 2] = color[2];\n        data[i * 4 + 3] = color[3];\n      }\n\n      // next bit, byte\n      if (bitIdx >= 7) {\n        bitIdx = 0;\n        byteIdx++;\n      } else {\n        bitIdx++;\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    return canvas.toDataURL();\n  }\n}\n\nexport default ImageOverlayViewerTool;\n","import {\n  PanTool,\n  WindowLevelTool,\n  StackScrollTool,\n  StackScrollMouseWheelTool,\n  ZoomTool,\n  VolumeRotateMouseWheelTool,\n  MIPJumpToClickTool,\n  LengthTool,\n  RectangleROITool,\n  EllipticalROITool,\n  CircleROITool,\n  BidirectionalTool,\n  ArrowAnnotateTool,\n  DragProbeTool,\n  ProbeTool,\n  AngleTool,\n  CobbAngleTool,\n  PlanarFreehandROITool,\n  MagnifyTool,\n  CrosshairsTool,\n  SegmentationDisplayTool,\n  init,\n  addTool,\n  annotation,\n  ReferenceLinesTool,\n  TrackballRotateTool,\n  CircleScissorsTool,\n  RectangleScissorsTool,\n  SphereScissorsTool,\n} from '@cornerstonejs/tools';\n\nimport CalibrationLineTool from './tools/CalibrationLineTool';\nimport ImageOverlayViewerTool from './tools/ImageOverlayViewerTool';\n\nexport default function initCornerstoneTools(configuration = {}) {\n  CrosshairsTool.isAnnotation = false;\n  ReferenceLinesTool.isAnnotation = false;\n\n  init(configuration);\n  addTool(PanTool);\n  addTool(WindowLevelTool);\n  addTool(StackScrollMouseWheelTool);\n  addTool(StackScrollTool);\n  addTool(ZoomTool);\n  addTool(ProbeTool);\n  addTool(VolumeRotateMouseWheelTool);\n  addTool(MIPJumpToClickTool);\n  addTool(LengthTool);\n  addTool(RectangleROITool);\n  addTool(EllipticalROITool);\n  addTool(CircleROITool);\n  addTool(BidirectionalTool);\n  addTool(ArrowAnnotateTool);\n  addTool(DragProbeTool);\n  addTool(AngleTool);\n  addTool(CobbAngleTool);\n  addTool(PlanarFreehandROITool);\n  addTool(MagnifyTool);\n  addTool(CrosshairsTool);\n  addTool(SegmentationDisplayTool);\n  addTool(ReferenceLinesTool);\n  addTool(CalibrationLineTool);\n  addTool(TrackballRotateTool);\n  addTool(CircleScissorsTool);\n  addTool(RectangleScissorsTool);\n  addTool(SphereScissorsTool);\n  addTool(ImageOverlayViewerTool);\n\n  // Modify annotation tools to use dashed lines on SR\n  const annotationStyle = {\n    textBoxFontSize: '15px',\n    lineWidth: '1.5',\n  };\n\n  const defaultStyles = annotation.config.style.getDefaultToolStyles();\n  annotation.config.style.setDefaultToolStyles({\n    global: {\n      ...defaultStyles.global,\n      ...annotationStyle,\n    },\n  });\n}\n\nconst toolNames = {\n  Pan: PanTool.toolName,\n  ArrowAnnotate: ArrowAnnotateTool.toolName,\n  WindowLevel: WindowLevelTool.toolName,\n  StackScroll: StackScrollTool.toolName,\n  StackScrollMouseWheel: StackScrollMouseWheelTool.toolName,\n  Zoom: ZoomTool.toolName,\n  VolumeRotateMouseWheel: VolumeRotateMouseWheelTool.toolName,\n  MipJumpToClick: MIPJumpToClickTool.toolName,\n  Length: LengthTool.toolName,\n  DragProbe: DragProbeTool.toolName,\n  Probe: ProbeTool.toolName,\n  RectangleROI: RectangleROITool.toolName,\n  EllipticalROI: EllipticalROITool.toolName,\n  CircleROI: CircleROITool.toolName,\n  Bidirectional: BidirectionalTool.toolName,\n  Angle: AngleTool.toolName,\n  CobbAngle: CobbAngleTool.toolName,\n  PlanarFreehandROI: PlanarFreehandROITool.toolName,\n  Magnify: MagnifyTool.toolName,\n  Crosshairs: CrosshairsTool.toolName,\n  SegmentationDisplay: SegmentationDisplayTool.toolName,\n  ReferenceLines: ReferenceLinesTool.toolName,\n  CalibrationLine: CalibrationLineTool.toolName,\n  TrackballRotateTool: TrackballRotateTool.toolName,\n  CircleScissors: CircleScissorsTool.toolName,\n  RectangleScissors: RectangleScissorsTool.toolName,\n  SphereScissors: SphereScissorsTool.toolName,\n  ImageOverlayViewer: ImageOverlayViewerTool.toolName,\n};\n\nexport { toolNames };\n","export default [\n  'Length',\n  'EllipticalROI',\n  'CircleROI',\n  'Bidirectional',\n  'ArrowAnnotate',\n  'Angle',\n  'CobbAngle',\n  'Probe',\n  'RectangleROI',\n  'PlanarFreehandROI',\n];\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst Length = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, displaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { length, unit = 'mm' } = targetStats;\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      length,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:Length');\n\n  mappedAnnotations.forEach(annotation => {\n    const { length, unit } = annotation;\n    columns.push(`Length`);\n    values.push(length);\n    columns.push('Unit');\n    values.push(unit);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const {\n    length,\n    SeriesNumber,\n    SOPInstanceUID,\n    frameNumber,\n    unit,\n  } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  if (length === null || length === undefined) {\n    return displayText;\n  }\n  const roundedLength = utils.roundNumber(length, 2);\n  displayText.push(\n    `${roundedLength} ${unit} (S: ${SeriesNumber}${instanceText}${frameText})`\n  );\n\n  return displayText;\n}\n\nexport default Length;\n","import { annotation } from '@cornerstonejs/tools';\n\nimport SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst Bidirectional = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, displaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId, referencedSeriesInstanceUID } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { length, width, unit } = targetStats;\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      length,\n      width,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:Bidirectional');\n\n  mappedAnnotations.forEach(annotation => {\n    const { length, width, unit } = annotation;\n    columns.push(`Length`, `Width`, 'Unit');\n    values.push(length, width, unit);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const {\n    length,\n    width,\n    unit,\n    SeriesNumber,\n    SOPInstanceUID,\n    frameNumber,\n  } = mappedAnnotations[0];\n  const roundedLength = utils.roundNumber(length, 2);\n  const roundedWidth = utils.roundNumber(width, 2);\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  displayText.push(\n    `L: ${roundedLength} ${unit} (S: ${SeriesNumber}${instanceText}${frameText})`\n  );\n  displayText.push(`W: ${roundedWidth} ${unit}`);\n\n  return displayText;\n}\n\nexport default Bidirectional;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst EllipticalROI = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, displaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      // Todo: Non-acquisition plane measurement mapping not supported yet\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { mean, stdDev, max, area, Modality, areaUnit, modalityUnit } = targetStats;\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      Modality,\n      unit: modalityUnit,\n      areaUnit,\n      mean,\n      stdDev,\n      max,\n      area,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:EllipticalROI');\n\n  mappedAnnotations.forEach(annotation => {\n    const { mean, stdDev, max, area, unit, areaUnit } = annotation;\n\n    if (!mean || !unit || !max || !area) {\n      return;\n    }\n\n    columns.push(\n      `max (${unit})`,\n      `mean (${unit})`,\n      `std (${unit})`,\n      'Area',\n      'Unit'\n    );\n    values.push(max, mean, stdDev, area, areaUnit);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { area, SOPInstanceUID, frameNumber, areaUnit } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  const roundedArea = utils.roundNumber(area, 2);\n  displayText.push(`${roundedArea} ${areaUnit}`);\n\n  // Todo: we need a better UI for displaying all these information\n  mappedAnnotations.forEach(mappedAnnotation => {\n    const { unit, max, SeriesNumber } = mappedAnnotation;\n\n    let maxStr = '';\n    if (max) {\n      const roundedMax = utils.roundNumber(max, 2);\n      maxStr = `Max: ${roundedMax} <small>${unit}</small> `;\n    }\n\n    const str = `${maxStr}(S:${SeriesNumber}${instanceText}${frameText})`;\n    if (!displayText.includes(str)) {\n      displayText.push(str);\n    }\n  });\n\n  return displayText;\n}\n\nexport default EllipticalROI;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst CircleROI = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    DisplaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = DisplaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, DisplaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      // Todo: Non-acquisition plane measurement mapping not supported yet\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { mean, stdDev, max, area, Modality, areaUnit, modalityUnit } = targetStats;\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      Modality,\n      unit: modalityUnit,\n      mean,\n      stdDev,\n      max,\n      area,\n      areaUnit,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:CircleROI');\n\n  mappedAnnotations.forEach(annotation => {\n    const { mean, stdDev, max, area, unit, areaUnit } = annotation;\n\n    if (!mean || !unit || !max || !area) {\n      return;\n    }\n\n    columns.push(\n      `max (${unit})`,\n      `mean (${unit})`,\n      `std (${unit})`,\n      'Area',\n      'Unit'\n    );\n    values.push(max, mean, stdDev, area, areaUnit);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { area, SOPInstanceUID, frameNumber, areaUnit } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  // Area sometimes becomes undefined if `preventHandleOutsideImage` is off.\n  const roundedArea = utils.roundNumber(area || 0, 2);\n  displayText.push(`${roundedArea} ${areaUnit}`);\n\n  // Todo: we need a better UI for displaying all these information\n  mappedAnnotations.forEach(mappedAnnotation => {\n    const { unit, max, SeriesNumber } = mappedAnnotation;\n\n    let maxStr = '';\n    if (max) {\n      const roundedMax = utils.roundNumber(max, 2);\n      maxStr = `Max: ${roundedMax} <small>${unit}</small> `;\n    }\n\n    const str = `${maxStr}(S:${SeriesNumber}${instanceText}${frameText})`;\n    if (!displayText.includes(str)) {\n      displayText.push(str);\n    }\n  });\n\n  return displayText;\n}\n\nexport default CircleROI;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\n\nconst Length = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, displaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.text,\n      text: data.text,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport: () => {\n        throw new Error('Not implemented');\n      },\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { text } = data;\n  const { referencedImageId } = metadata;\n\n  const annotations = [];\n\n  const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n    getSOPInstanceAttributes(referencedImageId);\n\n  const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    frameNumber\n  );\n\n  const { SeriesNumber } = displaySet;\n\n  annotations.push({\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesNumber,\n    frameNumber,\n    text,\n  });\n\n  return annotations;\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { SeriesNumber, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  displayText.push(`(S: ${SeriesNumber}${instanceText}${frameText})`);\n\n  return displayText;\n}\n\nexport default Length;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst CobbAngle = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Cobb Angle tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, displaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations?.[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return;\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { angle } = targetStats;\n    const unit = '\\u00B0';\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      angle,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:CobbAngle');\n\n  mappedAnnotations.forEach(annotation => {\n    const { angle, unit } = annotation;\n    columns.push(`Angle (${unit})`);\n    values.push(angle);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { angle, unit, SeriesNumber, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n  if (angle === undefined) {\n    return displayText;\n  }\n  const roundedAngle = utils.roundNumber(angle, 2);\n  displayText.push(`${roundedAngle} ${unit} (S: ${SeriesNumber}${instanceText}${frameText})`);\n\n  return displayText;\n}\n\nexport default CobbAngle;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst Angle = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, displaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations?.[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return;\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { angle } = targetStats;\n    const unit = '\\u00B0';\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      angle,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:Angle');\n\n  mappedAnnotations.forEach(annotation => {\n    const { angle, unit } = annotation;\n    columns.push(`Angle (${unit})`);\n    values.push(angle);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { angle, unit, SeriesNumber, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n  if (angle === undefined) {\n    return displayText;\n  }\n  const roundedAngle = utils.roundNumber(angle, 2);\n  displayText.push(`${roundedAngle} ${unit} (S: ${SeriesNumber}${instanceText}${frameText})`);\n\n  return displayText;\n}\n\nexport default Angle;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\n\nconst PlanarFreehandROI = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    DisplaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('PlanarFreehandROI tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = DisplaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, DisplaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: { ...data, ...data.cachedStats },\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\n/**\n * It maps an imaging library annotation to a list of simplified annotation properties.\n *\n * @param {Object} annotationData\n * @param {Object} DisplaySetService\n * @returns\n */\nfunction getMappedAnnotations(annotationData, DisplaySetService) {\n  const { metadata, data } = annotationData;\n  const { label } = data;\n  const { referencedImageId } = metadata;\n\n  const annotations = [];\n\n  const { SOPInstanceUID: _SOPInstanceUID, SeriesInstanceUID: _SeriesInstanceUID } =\n    getSOPInstanceAttributes(referencedImageId) || {};\n\n  if (!_SOPInstanceUID || !_SeriesInstanceUID) {\n    return annotations;\n  }\n\n  const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n    _SOPInstanceUID,\n    _SeriesInstanceUID\n  );\n\n  const { SeriesNumber, SeriesInstanceUID } = displaySet;\n\n  annotations.push({\n    SeriesInstanceUID,\n    SeriesNumber,\n    label,\n    data,\n  });\n\n  return annotations;\n}\n\n/**\n * TBD\n * This function is used to convert the measurement data to a format that is suitable for the report generation (e.g. for the csv report).\n * The report returns a list of columns and corresponding values.\n * @param {*} mappedAnnotations\n * @param {*} points\n * @param {*} FrameOfReferenceUID\n * @returns Object representing the report's content for this tool.\n */\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations) {\n  return '';\n}\n\nexport default PlanarFreehandROI;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst RectangleROI = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    DisplaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Rectangle ROI tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = DisplaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(annotation, DisplaySetService);\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () => _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      // Todo: Non-acquisition plane measurement mapping not supported yet\n      throw new Error('Non-acquisition plane measurement mapping not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { mean, stdDev, max, area, Modality, modalityUnit, areaUnit } = targetStats;\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      Modality,\n      unit: modalityUnit,\n      mean,\n      stdDev,\n      max,\n      area,\n      areaUnit,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:RectangleROI');\n\n  mappedAnnotations.forEach(annotation => {\n    const { mean, stdDev, max, area, unit, areaUnit } = annotation;\n\n    if (!mean || !unit || !max || !area) {\n      return;\n    }\n\n    columns.push(`Maximum`, `Mean`, `Std Dev`, 'Pixel Unit', `Area`, 'Unit');\n    values.push(max, mean, stdDev, unit, area, areaUnit);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { area, SOPInstanceUID, frameNumber, areaUnit } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(image => image.SOPInstanceUID === SOPInstanceUID);\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  // Area sometimes becomes undefined if `preventHandleOutsideImage` is off.\n  const roundedArea = utils.roundNumber(area || 0, 2);\n  displayText.push(`${roundedArea} ${areaUnit}`);\n\n  // Todo: we need a better UI for displaying all these information\n  mappedAnnotations.forEach(mappedAnnotation => {\n    const { unit, max, SeriesNumber } = mappedAnnotation;\n\n    let maxStr = '';\n    if (max) {\n      const roundedMax = utils.roundNumber(max, 2);\n      maxStr = `Max: ${roundedMax} <small>${unit}</small> `;\n    }\n\n    const str = `${maxStr}(S:${SeriesNumber}${instanceText}${frameText})`;\n    if (!displayText.includes(str)) {\n      displayText.push(str);\n    }\n  });\n\n  return displayText;\n}\n\nexport default RectangleROI;\n","import { MeasurementService } from '@ohif/core';\nimport Length from './Length';\nimport Bidirectional from './Bidirectional';\nimport EllipticalROI from './EllipticalROI';\nimport CircleROI from './CircleROI';\nimport ArrowAnnotate from './ArrowAnnotate';\nimport CobbAngle from './CobbAngle';\nimport Angle from './Angle';\nimport PlanarFreehandROI from './PlanarFreehandROI';\nimport RectangleROI from './RectangleROI';\n\nconst measurementServiceMappingsFactory = (\n  measurementService: MeasurementService,\n  displaySetService,\n  cornerstoneViewportService\n) => {\n  /**\n   * Maps measurement service format object to cornerstone annotation object.\n   *\n   * @param measurement The measurement instance\n   * @param definition The source definition\n   * @return Cornerstone annotation data\n   */\n\n  const _getValueTypeFromToolType = toolType => {\n    const { POLYLINE, ELLIPSE, CIRCLE, RECTANGLE, BIDIRECTIONAL, POINT, ANGLE } =\n      MeasurementService.VALUE_TYPES;\n\n    // TODO -> I get why this was attempted, but its not nearly flexible enough.\n    // A single measurement may have an ellipse + a bidirectional measurement, for instances.\n    // You can't define a bidirectional tool as a single type..\n    const TOOL_TYPE_TO_VALUE_TYPE = {\n      Length: POLYLINE,\n      EllipticalROI: ELLIPSE,\n      CircleROI: CIRCLE,\n      RectangleROI: RECTANGLE,\n      PlanarFreehandROI: POLYLINE,\n      Bidirectional: BIDIRECTIONAL,\n      ArrowAnnotate: POINT,\n      CobbAngle: ANGLE,\n      Angle: ANGLE,\n    };\n\n    return TOOL_TYPE_TO_VALUE_TYPE[toolType];\n  };\n\n  const factories = {\n    Length: {\n      toAnnotation: Length.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        Length.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n          points: 2,\n        },\n      ],\n    },\n    Bidirectional: {\n      toAnnotation: Bidirectional.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        Bidirectional.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        // TODO -> We should eventually do something like shortAxis + longAxis,\n        // But its still a little unclear how these automatic interpretations will work.\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n          points: 2,\n        },\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n          points: 2,\n        },\n      ],\n    },\n\n    EllipticalROI: {\n      toAnnotation: EllipticalROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        EllipticalROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.ELLIPSE,\n        },\n      ],\n    },\n\n    CircleROI: {\n      toAnnotation: CircleROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        CircleROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.CIRCLE,\n        },\n      ],\n    },\n\n    RectangleROI: {\n      toAnnotation: RectangleROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        RectangleROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n        },\n      ],\n    },\n\n    PlanarFreehandROI: {\n      toAnnotation: PlanarFreehandROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        PlanarFreehandROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n        },\n      ],\n    },\n\n    ArrowAnnotate: {\n      toAnnotation: ArrowAnnotate.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        ArrowAnnotate.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POINT,\n          points: 1,\n        },\n      ],\n    },\n\n    CobbAngle: {\n      toAnnotation: CobbAngle.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        CobbAngle.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.ANGLE,\n        },\n      ],\n    },\n\n    Angle: {\n      toAnnotation: Angle.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        Angle.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.ANGLE,\n        },\n      ],\n    },\n  };\n\n  return factories;\n};\n\nexport default measurementServiceMappingsFactory;\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Enums, annotation } from '@cornerstonejs/tools';\nimport { DicomMetadataStore } from '@ohif/core';\nimport { toolNames } from './initCornerstoneTools';\nimport { onCompletedCalibrationLine } from './tools/CalibrationLineTool';\n\nimport measurementServiceMappingsFactory from './utils/measurementServiceMappings/measurementServiceMappingsFactory';\nimport getSOPInstanceAttributes from './utils/measurementServiceMappings/utils/getSOPInstanceAttributes';\n\nconst { removeAnnotation } = annotation.state;\n\nconst csToolsEvents = Enums.Events;\n\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\n\nconst initMeasurementService = (\n  measurementService,\n  displaySetService,\n  cornerstoneViewportService\n) => {\n  /* Initialization */\n  const {\n    Length,\n    Bidirectional,\n    EllipticalROI,\n    CircleROI,\n    ArrowAnnotate,\n    Angle,\n    CobbAngle,\n    RectangleROI,\n    PlanarFreehandROI,\n  } = measurementServiceMappingsFactory(\n    measurementService,\n    displaySetService,\n    cornerstoneViewportService\n  );\n  const csTools3DVer1MeasurementSource = measurementService.createSource(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  /* Mappings */\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'Length',\n    Length.matchingCriteria,\n    Length.toAnnotation,\n    Length.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'Bidirectional',\n    Bidirectional.matchingCriteria,\n    Bidirectional.toAnnotation,\n    Bidirectional.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'EllipticalROI',\n    EllipticalROI.matchingCriteria,\n    EllipticalROI.toAnnotation,\n    EllipticalROI.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'CircleROI',\n    CircleROI.matchingCriteria,\n    CircleROI.toAnnotation,\n    CircleROI.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'ArrowAnnotate',\n    ArrowAnnotate.matchingCriteria,\n    ArrowAnnotate.toAnnotation,\n    ArrowAnnotate.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'CobbAngle',\n    CobbAngle.matchingCriteria,\n    CobbAngle.toAnnotation,\n    CobbAngle.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'Angle',\n    Angle.matchingCriteria,\n    Angle.toAnnotation,\n    Angle.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'RectangleROI',\n    RectangleROI.matchingCriteria,\n    RectangleROI.toAnnotation,\n    RectangleROI.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'PlanarFreehandROI',\n    PlanarFreehandROI.matchingCriteria,\n    PlanarFreehandROI.toAnnotation,\n    PlanarFreehandROI.toMeasurement\n  );\n\n  // On the UI side, the Calibration Line tool will work almost the same as the\n  // Length tool\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'CalibrationLine',\n    Length.matchingCriteria,\n    Length.toAnnotation,\n    Length.toMeasurement\n  );\n\n  return csTools3DVer1MeasurementSource;\n};\n\nconst connectToolsToMeasurementService = servicesManager => {\n  const { measurementService, displaySetService, cornerstoneViewportService } =\n    servicesManager.services;\n  const csTools3DVer1MeasurementSource = initMeasurementService(\n    measurementService,\n    displaySetService,\n    cornerstoneViewportService\n  );\n  connectMeasurementServiceToTools(\n    measurementService,\n    cornerstoneViewportService,\n    csTools3DVer1MeasurementSource\n  );\n  const { annotationToMeasurement, remove } = csTools3DVer1MeasurementSource;\n\n  //\n  function addMeasurement(csToolsEvent) {\n    try {\n      const annotationAddedEventDetail = csToolsEvent.detail;\n      const {\n        annotation: { metadata, annotationUID },\n      } = annotationAddedEventDetail;\n      const { toolName } = metadata;\n\n      if (csToolsEvent.type === completedEvt && toolName === toolNames.CalibrationLine) {\n        // show modal to input the measurement (mm)\n        onCompletedCalibrationLine(servicesManager, csToolsEvent)\n          .then(\n            () => {\n              console.log('calibration applied');\n            },\n            () => true\n          )\n          .finally(() => {\n            // we don't need the calibration line lingering around, remove the\n            // annotation from the display\n            removeAnnotation(annotationUID);\n            removeMeasurement(csToolsEvent);\n            // this will ensure redrawing of annotations\n            cornerstoneViewportService.resize();\n          });\n      } else {\n        // To force the measurementUID be the same as the annotationUID\n        // Todo: this should be changed when a measurement can include multiple annotations\n        // in the future\n        annotationAddedEventDetail.uid = annotationUID;\n        annotationToMeasurement(toolName, annotationAddedEventDetail);\n      }\n    } catch (error) {\n      console.warn('Failed to update measurement:', error);\n    }\n  }\n\n  function updateMeasurement(csToolsEvent) {\n    try {\n      const annotationModifiedEventDetail = csToolsEvent.detail;\n\n      const {\n        annotation: { metadata, annotationUID },\n      } = annotationModifiedEventDetail;\n\n      // If the measurement hasn't been added, don't modify it\n      const measurement = measurementService.getMeasurement(annotationUID);\n\n      if (!measurement) {\n        return;\n      }\n      const { toolName } = metadata;\n\n      annotationModifiedEventDetail.uid = annotationUID;\n      // Passing true to indicate this is an update and NOT a annotation (start) completion.\n      annotationToMeasurement(toolName, annotationModifiedEventDetail, true);\n    } catch (error) {\n      console.warn('Failed to update measurement:', error);\n    }\n  }\n  function selectMeasurement(csToolsEvent) {\n    try {\n      const annotationSelectionEventDetail = csToolsEvent.detail;\n\n      const { added: addedSelectedAnnotationUIDs, removed: removedSelectedAnnotationUIDs } =\n        annotationSelectionEventDetail;\n\n      if (removedSelectedAnnotationUIDs) {\n        removedSelectedAnnotationUIDs.forEach(annotationUID =>\n          measurementService.setMeasurementSelected(annotationUID, false)\n        );\n      }\n\n      if (addedSelectedAnnotationUIDs) {\n        addedSelectedAnnotationUIDs.forEach(annotationUID =>\n          measurementService.setMeasurementSelected(annotationUID, true)\n        );\n      }\n    } catch (error) {\n      console.warn('Failed to select and unselect measurements:', error);\n    }\n  }\n\n  /**\n   * When csTools fires a removed event, remove the same measurement\n   * from the measurement service\n   *\n   * @param {*} csToolsEvent\n   */\n  function removeMeasurement(csToolsEvent) {\n    try {\n      try {\n        const annotationRemovedEventDetail = csToolsEvent.detail;\n        const {\n          annotation: { annotationUID },\n        } = annotationRemovedEventDetail;\n\n        const measurement = measurementService.getMeasurement(annotationUID);\n\n        if (measurement) {\n          console.log('~~ removeEvt', csToolsEvent);\n          remove(annotationUID, annotationRemovedEventDetail);\n        }\n      } catch (error) {\n        console.warn('Failed to update measurement:', error);\n      }\n    } catch (error) {\n      console.warn('Failed to remove measurement:', error);\n    }\n  }\n\n  // on display sets added, check if there are any measurements in measurement service that need to be\n  // put into cornerstone tools\n  const addedEvt = csToolsEvents.ANNOTATION_ADDED;\n  const completedEvt = csToolsEvents.ANNOTATION_COMPLETED;\n  const updatedEvt = csToolsEvents.ANNOTATION_MODIFIED;\n  const removedEvt = csToolsEvents.ANNOTATION_REMOVED;\n  const selectionEvt = csToolsEvents.ANNOTATION_SELECTION_CHANGE;\n\n  eventTarget.addEventListener(addedEvt, addMeasurement);\n  eventTarget.addEventListener(completedEvt, addMeasurement);\n  eventTarget.addEventListener(updatedEvt, updateMeasurement);\n  eventTarget.addEventListener(removedEvt, removeMeasurement);\n  eventTarget.addEventListener(selectionEvt, selectMeasurement);\n\n  return csTools3DVer1MeasurementSource;\n};\n\nconst connectMeasurementServiceToTools = (\n  measurementService,\n  cornerstoneViewportService,\n  measurementSource\n) => {\n  const { MEASUREMENT_REMOVED, MEASUREMENTS_CLEARED, MEASUREMENT_UPDATED, RAW_MEASUREMENT_ADDED } =\n    measurementService.EVENTS;\n\n  const csTools3DVer1MeasurementSource = measurementService.getSource(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  measurementService.subscribe(MEASUREMENTS_CLEARED, ({ measurements }) => {\n    if (!Object.keys(measurements).length) {\n      return;\n    }\n\n    for (const measurement of Object.values(measurements)) {\n      const { uid, source } = measurement;\n      if (source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        continue;\n      }\n\n      removeAnnotation(uid);\n    }\n  });\n\n  measurementService.subscribe(\n    MEASUREMENT_UPDATED,\n    ({ source, measurement, notYetUpdatedAtSource }) => {\n      if (source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        return;\n      }\n\n      if (notYetUpdatedAtSource === false) {\n        // This event was fired by cornerstone telling the measurement service to sync.\n        // Already in sync.\n        return;\n      }\n\n      const { uid, label } = measurement;\n\n      const sourceAnnotation = annotation.state.getAnnotation(uid);\n      const { data, metadata } = sourceAnnotation;\n\n      if (!data) {\n        return;\n      }\n\n      if (data.label !== label) {\n        data.label = label;\n      }\n\n      if (metadata.toolName === 'ArrowAnnotate') {\n        data.text = label;\n      }\n\n      // Todo: trigger render for annotation\n    }\n  );\n\n  measurementService.subscribe(\n    RAW_MEASUREMENT_ADDED,\n    ({ source, measurement, data, dataSource }) => {\n      if (source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        return;\n      }\n\n      const { referenceSeriesUID, referenceStudyUID, SOPInstanceUID } = measurement;\n\n      const instance = DicomMetadataStore.getInstance(\n        referenceStudyUID,\n        referenceSeriesUID,\n        SOPInstanceUID\n      );\n\n      let imageId;\n      let frameNumber = 1;\n\n      if (measurement?.metadata?.referencedImageId) {\n        imageId = measurement.metadata.referencedImageId;\n        frameNumber = getSOPInstanceAttributes(measurement.metadata.referencedImageId).frameNumber;\n      } else {\n        imageId = dataSource.getImageIdsForInstance({ instance });\n      }\n\n      const annotationManager = annotation.state.getAnnotationManager();\n      annotationManager.addAnnotation({\n        annotationUID: measurement.uid,\n        highlighted: false,\n        isLocked: false,\n        invalidated: false,\n        metadata: {\n          toolName: measurement.toolName,\n          FrameOfReferenceUID: measurement.FrameOfReferenceUID,\n          referencedImageId: imageId,\n        },\n        data: {\n          text: data.annotation.data.text,\n          handles: { ...data.annotation.data.handles },\n          cachedStats: { ...data.annotation.data.cachedStats },\n          label: data.annotation.data.label,\n          frameNumber: frameNumber,\n        },\n      });\n    }\n  );\n\n  measurementService.subscribe(\n    MEASUREMENT_REMOVED,\n    ({ source, measurement: removedMeasurementId }) => {\n      if (source?.name && source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        return;\n      }\n      removeAnnotation(removedMeasurementId);\n      const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n      // Note: We could do a better job by triggering the render on the\n      // viewport itself, but the removeAnnotation does not include that info...\n      renderingEngine.render();\n    }\n  );\n};\n\nexport {\n  initMeasurementService,\n  connectToolsToMeasurementService,\n  connectMeasurementServiceToTools,\n};\n","import { utilities } from '@cornerstonejs/tools';\n\nfunction initCineService(cineService) {\n  const playClip = (element, playClipOptions) => {\n    return utilities.cine.playClip(element, playClipOptions);\n  };\n\n  const stopClip = element => {\n    return utilities.cine.stopClip(element);\n  };\n\n  cineService.setServiceImplementation({ playClip, stopClip });\n}\n\nexport default initCineService;\n","import { cache, imageLoadPoolManager, Enums } from '@cornerstonejs/core';\nimport getInterleavedFrames from './getInterleavedFrames';\nimport { compact, flatten, zip } from 'lodash';\n\n// Map of volumeId and SeriesInstanceId\nconst volumeIdMapsToLoad = new Map<string, string>();\nconst viewportIdVolumeInputArrayMap = new Map<string, unknown[]>();\n\n/**\n * This function caches the volumeUIDs until all the volumes inside the\n * hanging protocol are initialized. Then it goes through the imageIds\n * of the volumes, and interleave them, in order for the volumes to be loaded\n * together from middle to the start and the end.\n * @param {Object} props image loading properties from Cornerstone ViewportService\n * @returns\n */\nexport default function interleaveCenterLoader({\n  data: { viewportId, volumeInputArray },\n  displaySetsMatchDetails,\n  viewportMatchDetails: matchDetails,\n}) {\n  viewportIdVolumeInputArrayMap.set(viewportId, volumeInputArray);\n\n  // Based on the volumeInputs store the volumeIds and SeriesInstanceIds\n  // to keep track of the volumes being loaded\n  for (const volumeInput of volumeInputArray) {\n    const { volumeId } = volumeInput;\n    const volume = cache.getVolume(volumeId);\n\n    if (!volume) {\n      return;\n    }\n\n    // if the volumeUID is not in the volumeUIDs array, add it\n    if (!volumeIdMapsToLoad.has(volumeId)) {\n      const { metadata } = volume;\n      volumeIdMapsToLoad.set(volumeId, metadata.SeriesInstanceUID);\n    }\n  }\n\n  /**\n   * The following is checking if all the viewports that were matched in the HP has been\n   * successfully created their cornerstone viewport or not. Todo: This can be\n   * improved by not checking it, and as soon as the matched DisplaySets have their\n   * volume loaded, we start the loading, but that comes at the cost of viewports\n   * not being created yet (e.g., in a 10 viewport ptCT fusion, when one ct viewport and one\n   * pt viewport are created we have a guarantee that the volumes are created in the cache\n   * but the rest of the viewports (fusion, mip etc.) are not created yet. So\n   * we can't initiate setting the volumes for those viewports. One solution can be\n   * to add an event when a viewport is created (not enabled element event) and then\n   * listen to it and as the other viewports are created we can set the volumes for them\n   * since volumes are already started loading.\n   */\n  if (matchDetails.size !== viewportIdVolumeInputArrayMap.size) {\n    return;\n  }\n\n  // Check if all the matched volumes are loaded\n  for (const [_, details] of displaySetsMatchDetails.entries()) {\n    const { SeriesInstanceUID } = details;\n\n    // HangingProtocol has matched, but don't have all the volumes created yet, so return\n    if (!Array.from(volumeIdMapsToLoad.values()).includes(SeriesInstanceUID)) {\n      return;\n    }\n  }\n\n  const volumeIds = Array.from(volumeIdMapsToLoad.keys()).slice();\n  // get volumes from cache\n  const volumes = volumeIds.map(volumeId => {\n    return cache.getVolume(volumeId);\n  });\n\n  // iterate over all volumes, and get their imageIds, and interleave\n  // the imageIds and save them in AllRequests for later use\n  const AllRequests = [];\n  volumes.forEach(volume => {\n    const requests = volume.getImageLoadRequests();\n\n    if (!requests.length || !requests[0] || !requests[0].imageId) {\n      return;\n    }\n\n    const requestImageIds = requests.map(request => {\n      return request.imageId;\n    });\n\n    const imageIds = getInterleavedFrames(requestImageIds);\n\n    const reOrderedRequests = imageIds.map(({ imageId }) => {\n      const request = requests.find(req => req.imageId === imageId);\n      return request;\n    });\n\n    AllRequests.push(reOrderedRequests);\n  });\n\n  // flatten the AllRequests array, which will result in a list of all the\n  // imageIds for all the volumes but interleaved\n  const interleavedRequests = compact(flatten(zip(...AllRequests)));\n\n  // set the finalRequests to the imageLoadPoolManager\n  const finalRequests = [];\n  interleavedRequests.forEach(request => {\n    const { imageId } = request;\n\n    AllRequests.forEach(volumeRequests => {\n      const volumeImageIdRequest = volumeRequests.find(req => req.imageId === imageId);\n      if (volumeImageIdRequest) {\n        finalRequests.push(volumeImageIdRequest);\n      }\n    });\n  });\n\n  const requestType = Enums.RequestType.Prefetch;\n  const priority = 0;\n\n  finalRequests.forEach(({ callLoadImage, additionalDetails, imageId, imageIdIndex, options }) => {\n    const callLoadImageBound = callLoadImage.bind(null, imageId, imageIdIndex, options);\n\n    imageLoadPoolManager.addRequest(callLoadImageBound, requestType, additionalDetails, priority);\n  });\n\n  // clear the volumeIdMapsToLoad\n  volumeIdMapsToLoad.clear();\n\n  // copy the viewportIdVolumeInputArrayMap\n  const viewportIdVolumeInputArrayMapCopy = new Map(viewportIdVolumeInputArrayMap);\n\n  // reset the viewportIdVolumeInputArrayMap\n  viewportIdVolumeInputArrayMap.clear();\n\n  return viewportIdVolumeInputArrayMapCopy;\n}\n","export default function getInterleavedFrames(imageIds) {\n  const minImageIdIndex = 0;\n  const maxImageIdIndex = imageIds.length - 1;\n\n  const middleImageIdIndex = Math.floor(imageIds.length / 2);\n\n  let lowerImageIdIndex = middleImageIdIndex;\n  let upperImageIdIndex = middleImageIdIndex;\n\n  // Build up an array of images to prefetch, starting with the current image.\n  const imageIdsToPrefetch = [\n    { imageId: imageIds[middleImageIdIndex], imageIdIndex: middleImageIdIndex },\n  ];\n\n  const prefetchQueuedFilled = {\n    currentPositionDownToMinimum: false,\n    currentPositionUpToMaximum: false,\n  };\n\n  // Check if on edges and some criteria is already fulfilled\n\n  if (middleImageIdIndex === minImageIdIndex) {\n    prefetchQueuedFilled.currentPositionDownToMinimum = true;\n  } else if (middleImageIdIndex === maxImageIdIndex) {\n    prefetchQueuedFilled.currentPositionUpToMaximum = true;\n  }\n\n  while (\n    !prefetchQueuedFilled.currentPositionDownToMinimum ||\n    !prefetchQueuedFilled.currentPositionUpToMaximum\n  ) {\n    if (!prefetchQueuedFilled.currentPositionDownToMinimum) {\n      // Add imageId below\n      lowerImageIdIndex--;\n      imageIdsToPrefetch.push({\n        imageId: imageIds[lowerImageIdIndex],\n        imageIdIndex: lowerImageIdIndex,\n      });\n\n      if (lowerImageIdIndex === minImageIdIndex) {\n        prefetchQueuedFilled.currentPositionDownToMinimum = true;\n      }\n    }\n\n    if (!prefetchQueuedFilled.currentPositionUpToMaximum) {\n      // Add imageId above\n      upperImageIdIndex++;\n      imageIdsToPrefetch.push({\n        imageId: imageIds[upperImageIdIndex],\n        imageIdIndex: upperImageIdIndex,\n      });\n\n      if (upperImageIdIndex === maxImageIdIndex) {\n        prefetchQueuedFilled.currentPositionUpToMaximum = true;\n      }\n    }\n  }\n\n  return imageIdsToPrefetch;\n}\n","import { cache, imageLoadPoolManager, Enums } from '@cornerstonejs/core';\nimport getNthFrames from './getNthFrames';\nimport interleave from './interleave';\n\n// Map of volumeId and SeriesInstanceId\nconst volumeIdMapsToLoad = new Map<string, string>();\nconst viewportIdVolumeInputArrayMap = new Map<string, unknown[]>();\n\n/**\n * This function caches the volumeUIDs until all the volumes inside the\n * hanging protocol are initialized. Then it goes through the requests and\n * chooses a sub-selection starting the the first few objects, center objects\n * and last objects, and then the remaining nth images until all instances are\n * retrieved.  This causes the image to have a progressive load order and looks\n * visually much better.\n * @param {Object} props image loading properties from Cornerstone ViewportService\n */\nexport default function interleaveNthLoader({\n  data: { viewportId, volumeInputArray },\n  displaySetsMatchDetails,\n}) {\n  viewportIdVolumeInputArrayMap.set(viewportId, volumeInputArray);\n\n  // Based on the volumeInputs store the volumeIds and SeriesInstanceIds\n  // to keep track of the volumes being loaded\n  for (const volumeInput of volumeInputArray) {\n    const { volumeId } = volumeInput;\n    const volume = cache.getVolume(volumeId);\n\n    if (!volume) {\n      console.log(\"interleaveNthLoader::No volume, can't load it\");\n      return;\n    }\n\n    // if the volumeUID is not in the volumeUIDs array, add it\n    if (!volumeIdMapsToLoad.has(volumeId)) {\n      const { metadata } = volume;\n      volumeIdMapsToLoad.set(volumeId, metadata.SeriesInstanceUID);\n    }\n  }\n\n  const volumeIds = Array.from(volumeIdMapsToLoad.keys()).slice();\n  // get volumes from cache\n  const volumes = volumeIds.map(volumeId => {\n    return cache.getVolume(volumeId);\n  });\n\n  // iterate over all volumes, and get their imageIds, and interleave\n  // the imageIds and save them in AllRequests for later use\n  const originalRequests = volumes\n    .map(volume => volume.getImageLoadRequests())\n    .filter(requests => requests?.[0]?.imageId);\n\n  const orderedRequests = originalRequests.map(request => getNthFrames(request));\n\n  // set the finalRequests to the imageLoadPoolManager\n  const finalRequests = interleave(orderedRequests);\n\n  const requestType = Enums.RequestType.Prefetch;\n  const priority = 0;\n\n  finalRequests.forEach(({ callLoadImage, additionalDetails, imageId, imageIdIndex, options }) => {\n    const callLoadImageBound = callLoadImage.bind(null, imageId, imageIdIndex, options);\n\n    imageLoadPoolManager.addRequest(callLoadImageBound, requestType, additionalDetails, priority);\n  });\n\n  // clear the volumeIdMapsToLoad\n  volumeIdMapsToLoad.clear();\n\n  // copy the viewportIdVolumeInputArrayMap\n  const viewportIdVolumeInputArrayMapCopy = new Map(viewportIdVolumeInputArrayMap);\n\n  // reset the viewportIdVolumeInputArrayMap\n  viewportIdVolumeInputArrayMap.clear();\n\n  return viewportIdVolumeInputArrayMapCopy;\n}\n","/**\n * Interleave the items from all the lists so that the first items are first\n * in the returned list, the second items are next etc.\n * Does this in a O(n) fashion, and return lists[0] if there is only one list.\n *\n * @param {[]} lists\n * @returns [] reordered to be breadth first traversal of lists\n */\nexport default function interleave(lists) {\n  if (!lists || !lists.length) {\n    return [];\n  }\n  if (lists.length === 1) {\n    return lists[0];\n  }\n  console.time('interleave');\n  const useLists = [...lists];\n  const ret = [];\n  for (let i = 0; useLists.length > 0; i++) {\n    for (const list of useLists) {\n      if (i >= list.length) {\n        useLists.splice(useLists.indexOf(list), 1);\n        continue;\n      }\n      ret.push(list[i]);\n    }\n  }\n  console.timeEnd('interleave');\n  return ret;\n}\n","/**\n * Returns a re-ordered array consisting of, in order:\n *    1. First few objects\n *    2. Center objects\n *    3. Last few objects\n *    4. nth Objects (n=7), set 2\n *    5. nth Objects set 5,\n *    6. Remaining objects\n * What this does is return the first/center/start objects, as those\n * are often used first, then a selection of objects scattered over the\n * instances in order to allow making requests over a set of image instances.\n *\n * @param {[]} imageIds\n * @returns [] reordered to be an nth selection\n */\nexport default function getNthFrames(imageIds) {\n  const frames = [[], [], [], [], []];\n  const centerStart = imageIds.length / 2 - 3;\n  const centerEnd = centerStart + 6;\n\n  for (let i = 0; i < imageIds.length; i++) {\n    if (i < 2 || i > imageIds.length - 4 || (i > centerStart && i < centerEnd)) {\n      frames[0].push(imageIds[i]);\n    } else if (i % 7 === 2) {\n      frames[1].push(imageIds[i]);\n    } else if (i % 7 === 5) {\n      frames[2].push(imageIds[i]);\n    } else {\n      frames[(i % 2) + 3].push(imageIds[i]);\n    }\n  }\n  const ret = [...frames[0], ...frames[1], ...frames[2], ...frames[3], ...frames[4]];\n  return ret;\n}\n","import { cache, imageLoadPoolManager, Enums } from '@cornerstonejs/core';\nimport { compact, flatten, zip } from 'lodash';\n\n// Map of volumeId and SeriesInstanceId\nconst volumeIdMapsToLoad = new Map<string, string>();\nconst viewportIdVolumeInputArrayMap = new Map<string, unknown[]>();\n\n/**\n * This function caches the volumeIds until all the volumes inside the\n * hanging protocol are initialized. Then it goes through the imageIds\n * of the volumes, and interleave them, in order for the volumes to be loaded\n * together from middle to the start and the end.\n * @param {Object} {viewportData, displaySetMatchDetails}\n * @returns\n */\nexport default function interleaveTopToBottom({\n  data: { viewportId, volumeInputArray },\n  displaySetsMatchDetails,\n  viewportMatchDetails: matchDetails,\n}) {\n  viewportIdVolumeInputArrayMap.set(viewportId, volumeInputArray);\n\n  // Based on the volumeInputs store the volumeIds and SeriesInstanceIds\n  // to keep track of the volumes being loaded\n  for (const volumeInput of volumeInputArray) {\n    const { volumeId } = volumeInput;\n    const volume = cache.getVolume(volumeId);\n\n    if (!volume) {\n      return;\n    }\n\n    // if the volumeUID is not in the volumeUIDs array, add it\n    if (!volumeIdMapsToLoad.has(volumeId)) {\n      const { metadata } = volume;\n      volumeIdMapsToLoad.set(volumeId, metadata.SeriesInstanceUID);\n    }\n  }\n\n  /**\n   * The following is checking if all the viewports that were matched in the HP has been\n   * successfully created their cornerstone viewport or not. Todo: This can be\n   * improved by not checking it, and as soon as the matched DisplaySets have their\n   * volume loaded, we start the loading, but that comes at the cost of viewports\n   * not being created yet (e.g., in a 10 viewport ptCT fusion, when one ct viewport and one\n   * pt viewport are created we have a guarantee that the volumes are created in the cache\n   * but the rest of the viewports (fusion, mip etc.) are not created yet. So\n   * we can't initiate setting the volumes for those viewports. One solution can be\n   * to add an event when a viewport is created (not enabled element event) and then\n   * listen to it and as the other viewports are created we can set the volumes for them\n   * since volumes are already started loading.\n   */\n  if (matchDetails.size !== viewportIdVolumeInputArrayMap.size) {\n    return;\n  }\n\n  // Check if all the matched volumes are loaded\n  for (const [_, details] of displaySetsMatchDetails.entries()) {\n    const { SeriesInstanceUID } = details;\n\n    // HangingProtocol has matched, but don't have all the volumes created yet, so return\n    if (!Array.from(volumeIdMapsToLoad.values()).includes(SeriesInstanceUID)) {\n      return;\n    }\n  }\n\n  const volumeIds = Array.from(volumeIdMapsToLoad.keys()).slice();\n  // get volumes from cache\n  const volumes = volumeIds.map(volumeId => {\n    return cache.getVolume(volumeId);\n  });\n\n  // iterate over all volumes, and get their imageIds, and interleave\n  // the imageIds and save them in AllRequests for later use\n  const AllRequests = [];\n  volumes.forEach(volume => {\n    const requests = volume.getImageLoadRequests();\n\n    if (!requests.length || !requests[0] || !requests[0].imageId) {\n      return;\n    }\n\n    // reverse the requests\n    AllRequests.push(requests.reverse());\n  });\n\n  // flatten the AllRequests array, which will result in a list of all the\n  // imageIds for all the volumes but interleaved\n  const interleavedRequests = compact(flatten(zip(...AllRequests)));\n\n  // set the finalRequests to the imageLoadPoolManager\n  const finalRequests = [];\n  interleavedRequests.forEach(request => {\n    const { imageId } = request;\n\n    AllRequests.forEach(volumeRequests => {\n      const volumeImageIdRequest = volumeRequests.find(req => req.imageId === imageId);\n      if (volumeImageIdRequest) {\n        finalRequests.push(volumeImageIdRequest);\n      }\n    });\n  });\n\n  const requestType = Enums.RequestType.Prefetch;\n  const priority = 0;\n\n  finalRequests.forEach(({ callLoadImage, additionalDetails, imageId, imageIdIndex, options }) => {\n    const callLoadImageBound = callLoadImage.bind(null, imageId, imageIdIndex, options);\n\n    imageLoadPoolManager.addRequest(callLoadImageBound, requestType, additionalDetails, priority);\n  });\n\n  // clear the volumeIdMapsToLoad\n  volumeIdMapsToLoad.clear();\n\n  // copy the viewportIdVolumeInputArrayMap\n  const viewportIdVolumeInputArrayMapCopy = new Map(viewportIdVolumeInputArrayMap);\n\n  // reset the viewportIdVolumeInputArrayMap\n  viewportIdVolumeInputArrayMap.clear();\n\n  return viewportIdVolumeInputArrayMapCopy;\n}\n","/**\n * Finds tool nearby event position triggered.\n *\n * @param {Object} commandsManager mannager of commands\n * @param {Object} event that has being triggered\n * @returns cs toolData or undefined if not found.\n */\nexport const findNearbyToolData = (commandsManager, evt) => {\n  if (!evt?.detail) {\n    return;\n  }\n  const { element, currentPoints } = evt.detail;\n  return commandsManager.runCommand(\n    'getNearbyAnnotation',\n    {\n      element,\n      canvasCoordinates: currentPoints?.canvas,\n    },\n    'CORNERSTONE'\n  );\n};\n","import { eventTarget, EVENTS } from '@cornerstonejs/core';\nimport { Enums } from '@cornerstonejs/tools';\nimport { setEnabledElement } from './state';\nimport { findNearbyToolData } from './utils/findNearbyToolData';\n\nconst cs3DToolsEvents = Enums.Events;\n\nconst DEFAULT_CONTEXT_MENU_CLICKS = {\n  button1: {\n    commands: [\n      {\n        commandName: 'closeContextMenu',\n      },\n    ],\n  },\n  button3: {\n    commands: [\n      {\n        commandName: 'showCornerstoneContextMenu',\n        commandOptions: {\n          requireNearbyToolData: true,\n          menuId: 'measurementsContextMenu',\n        },\n      },\n    ],\n  },\n};\n\n/**\n * Generates a name, consisting of:\n *    * alt when the alt key is down\n *    * ctrl when the cctrl key is down\n *    * shift when the shift key is down\n *    * 'button' followed by the button number (1 left, 3 right etc)\n */\nfunction getEventName(evt) {\n  const button = evt.detail.event.which;\n  const nameArr = [];\n  if (evt.detail.event.altKey) {\n    nameArr.push('alt');\n  }\n  if (evt.detail.event.ctrlKey) {\n    nameArr.push('ctrl');\n  }\n  if (evt.detail.event.shiftKey) {\n    nameArr.push('shift');\n  }\n  nameArr.push('button');\n  nameArr.push(button);\n  return nameArr.join('');\n}\n\nfunction initContextMenu({\n  cornerstoneViewportService,\n  customizationService,\n  commandsManager,\n}): void {\n  /*\n   * Run the commands associated with the given button press,\n   * defaults on button1 and button2\n   */\n  const cornerstoneViewportHandleEvent = (name, evt) => {\n    const customizations =\n      customizationService.get('cornerstoneViewportClickCommands') || DEFAULT_CONTEXT_MENU_CLICKS;\n    const toRun = customizations[name];\n\n    if (!toRun) {\n      return;\n    }\n\n    // only find nearbyToolData if required, for the click (which closes the context menu\n    // we don't need to find nearbyToolData)\n    let nearbyToolData = null;\n    if (toRun.commands.some(command => command.commandOptions?.requireNearbyToolData)) {\n      nearbyToolData = findNearbyToolData(commandsManager, evt);\n    }\n\n    const options = {\n      nearbyToolData,\n      event: evt,\n    };\n    commandsManager.run(toRun, options);\n  };\n\n  const cornerstoneViewportHandleClick = evt => {\n    const name = getEventName(evt);\n    cornerstoneViewportHandleEvent(name, evt);\n  };\n\n  function elementEnabledHandler(evt) {\n    const { viewportId, element } = evt.detail;\n    const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n    if (!viewportInfo) {\n      return;\n    }\n    // TODO check update upstream\n    setEnabledElement(viewportId, element);\n\n    element.addEventListener(cs3DToolsEvents.MOUSE_CLICK, cornerstoneViewportHandleClick);\n  }\n\n  function elementDisabledHandler(evt) {\n    const { element } = evt.detail;\n\n    element.removeEventListener(cs3DToolsEvents.MOUSE_CLICK, cornerstoneViewportHandleClick);\n  }\n\n  eventTarget.addEventListener(EVENTS.ELEMENT_ENABLED, elementEnabledHandler.bind(null));\n\n  eventTarget.addEventListener(EVENTS.ELEMENT_DISABLED, elementDisabledHandler.bind(null));\n}\n\nexport default initContextMenu;\n","import { eventTarget, EVENTS } from '@cornerstonejs/core';\nimport { Enums } from '@cornerstonejs/tools';\nimport { CommandsManager, CustomizationService, Types } from '@ohif/core';\nimport { findNearbyToolData } from './utils/findNearbyToolData';\n\nconst cs3DToolsEvents = Enums.Events;\n\nconst DEFAULT_DOUBLE_CLICK = {\n  doubleClick: {\n    commandName: 'toggleOneUp',\n    commandOptions: {},\n  },\n};\n\n/**\n * Generates a double click event name, consisting of:\n *    * alt when the alt key is down\n *    * ctrl when the cctrl key is down\n *    * shift when the shift key is down\n *    * 'doubleClick'\n */\nfunction getDoubleClickEventName(evt: CustomEvent) {\n  const nameArr = [];\n  if (evt.detail.event.altKey) {\n    nameArr.push('alt');\n  }\n  if (evt.detail.event.ctrlKey) {\n    nameArr.push('ctrl');\n  }\n  if (evt.detail.event.shiftKey) {\n    nameArr.push('shift');\n  }\n  nameArr.push('doubleClick');\n  return nameArr.join('');\n}\n\nexport type initDoubleClickArgs = {\n  customizationService: CustomizationService;\n  commandsManager: CommandsManager;\n};\n\nfunction initDoubleClick({ customizationService, commandsManager }: initDoubleClickArgs): void {\n  const cornerstoneViewportHandleDoubleClick = (evt: CustomEvent) => {\n    // Do not allow double click on a tool.\n    const nearbyToolData = findNearbyToolData(commandsManager, evt);\n    if (nearbyToolData) {\n      return;\n    }\n\n    const eventName = getDoubleClickEventName(evt);\n\n    // Allows for the customization of the double click on a viewport.\n    const customizations =\n      customizationService.get('cornerstoneViewportClickCommands') || DEFAULT_DOUBLE_CLICK;\n\n    const toRun = customizations[eventName];\n\n    if (!toRun) {\n      return;\n    }\n\n    commandsManager.run(toRun);\n  };\n\n  function elementEnabledHandler(evt: CustomEvent) {\n    const { element } = evt.detail;\n\n    element.addEventListener(\n      cs3DToolsEvents.MOUSE_DOUBLE_CLICK,\n      cornerstoneViewportHandleDoubleClick\n    );\n  }\n\n  function elementDisabledHandler(evt: CustomEvent) {\n    const { element } = evt.detail;\n\n    element.removeEventListener(\n      cs3DToolsEvents.MOUSE_DOUBLE_CLICK,\n      cornerstoneViewportHandleDoubleClick\n    );\n  }\n\n  eventTarget.addEventListener(EVENTS.ELEMENT_ENABLED, elementEnabledHandler.bind(null));\n\n  eventTarget.addEventListener(EVENTS.ELEMENT_DISABLED, elementDisabledHandler.bind(null));\n}\n\nexport default initDoubleClick;\n","import OHIF, { Types } from '@ohif/core';\nimport React from 'react';\n\nimport * as cornerstone from '@cornerstonejs/core';\nimport * as cornerstoneTools from '@cornerstonejs/tools';\nimport {\n  init as cs3DInit,\n  eventTarget,\n  EVENTS,\n  metaData,\n  volumeLoader,\n  imageLoadPoolManager,\n  Settings,\n  utilities as csUtilities,\n  Enums as csEnums,\n} from '@cornerstonejs/core';\nimport { Enums, utilities, ReferenceLinesTool } from '@cornerstonejs/tools';\nimport { cornerstoneStreamingImageVolumeLoader } from '@cornerstonejs/streaming-image-volume-loader';\n\nimport initWADOImageLoader from './initWADOImageLoader';\nimport initCornerstoneTools from './initCornerstoneTools';\n\nimport { connectToolsToMeasurementService } from './initMeasurementService';\nimport initCineService from './initCineService';\nimport interleaveCenterLoader from './utils/interleaveCenterLoader';\nimport nthLoader from './utils/nthLoader';\nimport interleaveTopToBottom from './utils/interleaveTopToBottom';\nimport initContextMenu from './initContextMenu';\nimport initDoubleClick from './initDoubleClick';\nimport { CornerstoneServices } from './types';\n\n// TODO: Cypress tests are currently grabbing this from the window?\nwindow.cornerstone = cornerstone;\nwindow.cornerstoneTools = cornerstoneTools;\n/**\n *\n */\nexport default async function init({\n  servicesManager,\n  commandsManager,\n  extensionManager,\n  configuration,\n  appConfig,\n}: Types.Extensions.ExtensionParams): Promise<void> {\n  // Note: this should run first before initializing the cornerstone\n  switch (appConfig.useSharedArrayBuffer) {\n    case 'AUTO':\n      cornerstone.setUseSharedArrayBuffer(csEnums.SharedArrayBufferModes.AUTO);\n      break;\n    case 'FALSE':\n      cornerstone.setUseSharedArrayBuffer(csEnums.SharedArrayBufferModes.FALSE);\n      break;\n    default:\n      cornerstone.setUseSharedArrayBuffer(csEnums.SharedArrayBufferModes.TRUE);\n  }\n\n  await cs3DInit({\n    rendering: {\n      preferSizeOverAccuracy: Boolean(appConfig.use16BitDataType),\n      useNorm16Texture: Boolean(appConfig.use16BitDataType),\n    },\n  });\n\n  // For debugging e2e tests that are failing on CI\n  cornerstone.setUseCPURendering(Boolean(appConfig.useCPURendering));\n\n  cornerstone.setConfiguration({\n    ...cornerstone.getConfiguration(),\n    rendering: {\n      ...cornerstone.getConfiguration().rendering,\n      strictZSpacingForVolumeViewport: appConfig.strictZSpacingForVolumeViewport,\n    },\n  });\n\n  // For debugging large datasets, otherwise prefer the defaults\n  const { maxCacheSize } = appConfig;\n  if (maxCacheSize) {\n    cornerstone.cache.setMaxCacheSize(maxCacheSize);\n  }\n\n  initCornerstoneTools();\n\n  Settings.getRuntimeSettings().set('useCursors', Boolean(appConfig.useCursors));\n\n  const {\n    userAuthenticationService,\n    customizationService,\n    uiModalService,\n    uiNotificationService,\n    cineService,\n    cornerstoneViewportService,\n    hangingProtocolService,\n    toolGroupService,\n    viewportGridService,\n    stateSyncService,\n  } = servicesManager.services as CornerstoneServices;\n\n  window.services = servicesManager.services;\n  window.extensionManager = extensionManager;\n  window.commandsManager = commandsManager;\n\n  if (appConfig.showWarningMessageForCrossOrigin && !window.crossOriginIsolated) {\n    uiNotificationService.show({\n      title: 'Cross Origin Isolation',\n      message: 'Cross Origin Isolation is not enabled, volume rendering will not work (e.g., MPR)',\n      type: 'warning',\n    });\n  }\n\n  if (appConfig.showCPUFallbackMessage && cornerstone.getShouldUseCPURendering()) {\n    _showCPURenderingModal(uiModalService, hangingProtocolService);\n  }\n\n  // Stores a map from `lutPresentationId` to a Presentation object so that\n  // an OHIFCornerstoneViewport can be redisplayed with the same LUT\n  stateSyncService.register('lutPresentationStore', { clearOnModeExit: true });\n\n  // Stores a map from `positionPresentationId` to a Presentation object so that\n  // an OHIFCornerstoneViewport can be redisplayed with the same position\n  stateSyncService.register('positionPresentationStore', {\n    clearOnModeExit: true,\n  });\n\n  // Stores the entire ViewportGridService getState when toggling to one up\n  // (e.g. via a double click) so that it can be restored when toggling back.\n  stateSyncService.register('toggleOneUpViewportGridStore', {\n    clearOnModeExit: true,\n  });\n\n  const labelmapRepresentation = cornerstoneTools.Enums.SegmentationRepresentations.Labelmap;\n\n  cornerstoneTools.segmentation.config.setGlobalRepresentationConfig(labelmapRepresentation, {\n    fillAlpha: 0.3,\n    fillAlphaInactive: 0.2,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.65,\n  });\n\n  const metadataProvider = OHIF.classes.MetadataProvider;\n\n  volumeLoader.registerVolumeLoader(\n    'cornerstoneStreamingImageVolume',\n    cornerstoneStreamingImageVolumeLoader\n  );\n\n  hangingProtocolService.registerImageLoadStrategy('interleaveCenter', interleaveCenterLoader);\n  hangingProtocolService.registerImageLoadStrategy('interleaveTopToBottom', interleaveTopToBottom);\n  hangingProtocolService.registerImageLoadStrategy('nth', nthLoader);\n\n  // add metadata providers\n  metaData.addProvider(\n    csUtilities.calibratedPixelSpacingMetadataProvider.get.bind(\n      csUtilities.calibratedPixelSpacingMetadataProvider\n    )\n  ); // this provider is required for Calibration tool\n  metaData.addProvider(metadataProvider.get.bind(metadataProvider), 9999);\n\n  imageLoadPoolManager.maxNumRequests = {\n    interaction: appConfig?.maxNumRequests?.interaction || 100,\n    thumbnail: appConfig?.maxNumRequests?.thumbnail || 75,\n    prefetch: appConfig?.maxNumRequests?.prefetch || 10,\n  };\n\n  initWADOImageLoader(userAuthenticationService, appConfig, extensionManager);\n\n  /* Measurement Service */\n  this.measurementServiceSource = connectToolsToMeasurementService(servicesManager);\n\n  initCineService(cineService);\n\n  // When a custom image load is performed, update the relevant viewports\n  hangingProtocolService.subscribe(\n    hangingProtocolService.EVENTS.CUSTOM_IMAGE_LOAD_PERFORMED,\n    volumeInputArrayMap => {\n      for (const entry of volumeInputArrayMap.entries()) {\n        const [viewportId, volumeInputArray] = entry;\n        const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n        const ohifViewport = cornerstoneViewportService.getViewportInfo(viewportId);\n\n        const { lutPresentationStore, positionPresentationStore } = stateSyncService.getState();\n        const { presentationIds } = ohifViewport.getViewportOptions();\n        const presentations = {\n          positionPresentation: positionPresentationStore[presentationIds?.positionPresentationId],\n          lutPresentation: lutPresentationStore[presentationIds?.lutPresentationId],\n        };\n\n        cornerstoneViewportService.setVolumesForViewport(viewport, volumeInputArray, presentations);\n      }\n    }\n  );\n\n  initContextMenu({\n    cornerstoneViewportService,\n    customizationService,\n    commandsManager,\n  });\n\n  initDoubleClick({\n    customizationService,\n    commandsManager,\n  });\n\n  const newStackCallback = evt => {\n    const { element } = evt.detail;\n    utilities.stackPrefetch.enable(element);\n  };\n\n  const resetCrosshairs = evt => {\n    const { element } = evt.detail;\n    const { viewportId, renderingEngineId } = cornerstone.getEnabledElement(element);\n\n    const toolGroup = cornerstoneTools.ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    if (!toolGroup || !toolGroup._toolInstances?.['Crosshairs']) {\n      return;\n    }\n\n    const mode = toolGroup._toolInstances['Crosshairs'].mode;\n\n    if (mode === Enums.ToolModes.Active) {\n      toolGroup.setToolActive('Crosshairs');\n    } else if (mode === Enums.ToolModes.Passive) {\n      toolGroup.setToolPassive('Crosshairs');\n    } else if (mode === Enums.ToolModes.Enabled) {\n      toolGroup.setToolEnabled('Crosshairs');\n    }\n  };\n\n  function elementEnabledHandler(evt) {\n    const { element } = evt.detail;\n    element.addEventListener(EVENTS.CAMERA_RESET, resetCrosshairs);\n\n    eventTarget.addEventListener(EVENTS.STACK_VIEWPORT_NEW_STACK, newStackCallback);\n  }\n\n  function elementDisabledHandler(evt) {\n    const { element } = evt.detail;\n\n    element.removeEventListener(EVENTS.CAMERA_RESET, resetCrosshairs);\n\n    // TODO - consider removing the callback when all elements are gone\n    // eventTarget.removeEventListener(\n    //   EVENTS.STACK_VIEWPORT_NEW_STACK,\n    //   newStackCallback\n    // );\n  }\n\n  eventTarget.addEventListener(EVENTS.ELEMENT_ENABLED, elementEnabledHandler.bind(null));\n\n  eventTarget.addEventListener(EVENTS.ELEMENT_DISABLED, elementDisabledHandler.bind(null));\n\n  viewportGridService.subscribe(\n    viewportGridService.EVENTS.ACTIVE_VIEWPORT_ID_CHANGED,\n    ({ viewportId }) => {\n      const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n      if (!toolGroup || !toolGroup._toolInstances?.['ReferenceLines']) {\n        return;\n      }\n\n      // check if reference lines are active\n      const referenceLinesEnabled =\n        toolGroup._toolInstances['ReferenceLines'].mode === Enums.ToolModes.Enabled;\n\n      if (!referenceLinesEnabled) {\n        return;\n      }\n\n      toolGroup.setToolConfiguration(\n        ReferenceLinesTool.toolName,\n        {\n          sourceViewportId: viewportId,\n        },\n        true // overwrite\n      );\n\n      // make sure to set it to enabled again since we want to recalculate\n      // the source-target lines\n      toolGroup.setToolEnabled(ReferenceLinesTool.toolName);\n    }\n  );\n}\n\nfunction CPUModal() {\n  return (\n    <div>\n      <p>\n        Your computer does not have enough GPU power to support the default GPU rendering mode. OHIF\n        has switched to CPU rendering mode. Please note that CPU rendering does not support all\n        features such as Volume Rendering, Multiplanar Reconstruction, and Segmentation Overlays.\n      </p>\n    </div>\n  );\n}\n\nfunction _showCPURenderingModal(uiModalService, hangingProtocolService) {\n  const callback = progress => {\n    if (progress === 100) {\n      uiModalService.show({\n        content: CPUModal,\n        title: 'OHIF Fell Back to CPU Rendering',\n      });\n\n      return true;\n    }\n  };\n\n  const { unsubscribe } = hangingProtocolService.subscribe(\n    hangingProtocolService.EVENTS.PROTOCOL_CHANGED,\n    () => {\n      const done = callback(100);\n\n      if (done) {\n        unsubscribe();\n      }\n    }\n  );\n}\n","import dicomImageLoader from '@cornerstonejs/dicom-image-loader';\n\nimport { PubSubService } from '@ohif/core';\n\nexport const EVENTS = {\n  PROGRESS: 'event:DicomFileUploader:progress',\n};\n\nexport interface DicomFileUploaderEvent {\n  fileId: number;\n}\n\nexport interface DicomFileUploaderProgressEvent extends DicomFileUploaderEvent {\n  percentComplete: number;\n}\n\nexport enum UploadStatus {\n  NotStarted,\n  InProgress,\n  Success,\n  Failed,\n  Cancelled,\n}\n\ntype CancelOrFailed = UploadStatus.Cancelled | UploadStatus.Failed;\n\nexport class UploadRejection {\n  message: string;\n  status: CancelOrFailed;\n\n  constructor(status: CancelOrFailed, message: string) {\n    this.message = message;\n    this.status = status;\n  }\n}\n\nexport default class DicomFileUploader extends PubSubService {\n  private _file;\n  private _fileId;\n  private _dataSource;\n  private _loadPromise;\n  private _abortController = new AbortController();\n  private _status: UploadStatus = UploadStatus.NotStarted;\n  private _percentComplete = 0;\n\n  constructor(file, dataSource) {\n    super(EVENTS);\n    this._file = file;\n    this._fileId = dicomImageLoader.wadouri.fileManager.add(file);\n    this._dataSource = dataSource;\n  }\n\n  getFileId(): string {\n    return this._fileId;\n  }\n\n  getFileName(): string {\n    return this._file.name;\n  }\n\n  getFileSize(): number {\n    return this._file.size;\n  }\n\n  cancel(): void {\n    this._abortController.abort();\n  }\n\n  getStatus(): UploadStatus {\n    return this._status;\n  }\n\n  getPercentComplete(): number {\n    return this._percentComplete;\n  }\n\n  async load(): Promise<void> {\n    if (this._loadPromise) {\n      // Already started loading, return the load promise.\n      return this._loadPromise;\n    }\n\n    this._loadPromise = new Promise<void>((resolve, reject) => {\n      // The upload listeners: fire progress events and/or settle the promise.\n      const uploadCallbacks = {\n        progress: evt => {\n          if (!evt.lengthComputable) {\n            // Progress computation is not possible.\n            return;\n          }\n\n          this._status = UploadStatus.InProgress;\n\n          this._percentComplete = Math.round((100 * evt.loaded) / evt.total);\n          this._broadcastEvent(EVENTS.PROGRESS, {\n            fileId: this._fileId,\n            percentComplete: this._percentComplete,\n          });\n        },\n        timeout: () => {\n          this._reject(reject, new UploadRejection(UploadStatus.Failed, 'The request timed out.'));\n        },\n        abort: () => {\n          this._reject(reject, new UploadRejection(UploadStatus.Cancelled, 'Cancelled'));\n        },\n        error: () => {\n          this._reject(reject, new UploadRejection(UploadStatus.Failed, 'The request failed.'));\n        },\n      };\n\n      // First try to load the file.\n      dicomImageLoader.wadouri\n        .loadFileRequest(this._fileId)\n        .then(dicomFile => {\n          if (this._abortController.signal.aborted) {\n            this._reject(reject, new UploadRejection(UploadStatus.Cancelled, 'Cancelled'));\n            return;\n          }\n\n          if (!this._checkDicomFile(dicomFile)) {\n            // The file is not DICOM\n            this._reject(\n              reject,\n              new UploadRejection(UploadStatus.Failed, 'Not a valid DICOM file.')\n            );\n            return;\n          }\n\n          const request = new XMLHttpRequest();\n          this._addRequestCallbacks(request, uploadCallbacks);\n\n          // Do the actual upload by supplying the DICOM file and upload callbacks/listeners.\n          return this._dataSource.store\n            .dicom(dicomFile, request)\n            .then(() => {\n              this._status = UploadStatus.Success;\n              resolve();\n            })\n            .catch(reason => {\n              this._reject(reject, reason);\n            });\n        })\n        .catch(reason => {\n          this._reject(reject, reason);\n        });\n    });\n\n    return this._loadPromise;\n  }\n\n  private _isRejected(): boolean {\n    return this._status === UploadStatus.Failed || this._status === UploadStatus.Cancelled;\n  }\n\n  private _reject(reject: (reason?: any) => void, reason: any) {\n    if (this._isRejected()) {\n      return;\n    }\n\n    if (reason instanceof UploadRejection) {\n      this._status = reason.status;\n      reject(reason);\n      return;\n    }\n\n    this._status = UploadStatus.Failed;\n\n    if (reason.message) {\n      reject(new UploadRejection(UploadStatus.Failed, reason.message));\n      return;\n    }\n\n    reject(new UploadRejection(UploadStatus.Failed, reason));\n  }\n\n  private _addRequestCallbacks(request: XMLHttpRequest, uploadCallbacks) {\n    const abortCallback = () => request.abort();\n    this._abortController.signal.addEventListener('abort', abortCallback);\n\n    for (const [eventName, callback] of Object.entries(uploadCallbacks)) {\n      request.upload.addEventListener(eventName, callback);\n    }\n\n    const cleanUpCallback = () => {\n      this._abortController.signal.removeEventListener('abort', abortCallback);\n\n      for (const [eventName, callback] of Object.entries(uploadCallbacks)) {\n        request.upload.removeEventListener(eventName, callback);\n      }\n\n      request.removeEventListener('loadend', cleanUpCallback);\n    };\n    request.addEventListener('loadend', cleanUpCallback);\n  }\n\n  private _checkDicomFile(arrayBuffer: ArrayBuffer) {\n    if (arrayBuffer.length <= 132) {\n      return false;\n    }\n    const arr = new Uint8Array(arrayBuffer.slice(128, 132));\n    // bytes from 128 to 132 must be \"DICM\"\n    return Array.from('DICM').every((char, i) => char.charCodeAt(0) === arr[i]);\n  }\n}\n","import React, { ReactElement, memo, useCallback, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport DicomFileUploader, {\n  DicomFileUploaderProgressEvent,\n  EVENTS,\n  UploadRejection,\n  UploadStatus,\n} from '../../utils/DicomFileUploader';\nimport { Icon } from '@ohif/ui';\n\ntype DicomUploadProgressItemProps = {\n  dicomFileUploader: DicomFileUploader;\n};\n\n// eslint-disable-next-line react/display-name\nconst DicomUploadProgressItem = memo(\n  ({ dicomFileUploader }: DicomUploadProgressItemProps): ReactElement => {\n    const [percentComplete, setPercentComplete] = useState(dicomFileUploader.getPercentComplete());\n    const [failedReason, setFailedReason] = useState('');\n    const [status, setStatus] = useState(dicomFileUploader.getStatus());\n\n    const isComplete = useCallback(() => {\n      return (\n        status === UploadStatus.Failed ||\n        status === UploadStatus.Cancelled ||\n        status === UploadStatus.Success\n      );\n    }, [status]);\n\n    useEffect(() => {\n      const progressSubscription = dicomFileUploader.subscribe(\n        EVENTS.PROGRESS,\n        (dicomFileUploaderProgressEvent: DicomFileUploaderProgressEvent) => {\n          setPercentComplete(dicomFileUploaderProgressEvent.percentComplete);\n        }\n      );\n\n      dicomFileUploader\n        .load()\n        .catch((reason: UploadRejection) => {\n          setStatus(reason.status);\n          setFailedReason(reason.message ?? '');\n        })\n        .finally(() => setStatus(dicomFileUploader.getStatus()));\n\n      return () => progressSubscription.unsubscribe();\n    }, []);\n\n    const cancelUpload = useCallback(() => {\n      dicomFileUploader.cancel();\n    }, []);\n\n    const getStatusIcon = (): ReactElement => {\n      switch (dicomFileUploader.getStatus()) {\n        case UploadStatus.Success:\n          return (\n            <Icon\n              name=\"status-tracked\"\n              className=\"text-primary-light\"\n            ></Icon>\n          );\n        case UploadStatus.InProgress:\n          return <Icon name=\"icon-transferring\"></Icon>;\n        case UploadStatus.Failed:\n          return <Icon name=\"icon-alert-small\"></Icon>;\n        case UploadStatus.Cancelled:\n          return <Icon name=\"icon-alert-outline\"></Icon>;\n        default:\n          return <></>;\n      }\n    };\n\n    return (\n      <div className=\"min-h-14 border-secondary-light flex w-full items-center overflow-hidden border-b p-2.5 text-lg\">\n        <div className=\"self-top flex w-0 shrink grow flex-col gap-1\">\n          <div className=\"flex gap-4\">\n            <div className=\"flex w-6 shrink-0 items-center justify-center\">{getStatusIcon()}</div>\n            <div className=\"overflow-hidden text-ellipsis whitespace-nowrap\">\n              {dicomFileUploader.getFileName()}\n            </div>\n          </div>\n          {failedReason && <div className=\"pl-10\">{failedReason}</div>}\n        </div>\n        <div className=\"flex w-24 items-center\">\n          {!isComplete() && (\n            <>\n              {dicomFileUploader.getStatus() === UploadStatus.InProgress && (\n                <div className=\"w-10 text-right\">{percentComplete}%</div>\n              )}\n              <div className=\"ml-auto flex cursor-pointer\">\n                <Icon\n                  className=\"text-primary-active self-center\"\n                  name=\"close\"\n                  onClick={cancelUpload}\n                />\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\n\nDicomUploadProgressItem.propTypes = {\n  dicomFileUploader: PropTypes.instanceOf(DicomFileUploader).isRequired,\n};\n\nexport default DicomUploadProgressItem;\n","import React, { useCallback, useEffect, useRef, useState, ReactElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { Button, Icon, ProgressLoadingBar } from '@ohif/ui';\nimport DicomFileUploader, {\n  EVENTS,\n  UploadStatus,\n  DicomFileUploaderProgressEvent,\n  UploadRejection,\n} from '../../utils/DicomFileUploader';\nimport DicomUploadProgressItem from './DicomUploadProgressItem';\nimport classNames from 'classnames';\n\ntype DicomUploadProgressProps = {\n  dicomFileUploaderArr: DicomFileUploader[];\n  onComplete: () => void;\n};\n\nconst ONE_SECOND = 1000;\nconst ONE_MINUTE = ONE_SECOND * 60;\nconst ONE_HOUR = ONE_MINUTE * 60;\n\n// The base/initial interval time length used to calculate the\n// rate of the upload and in turn estimate the\n// the amount of time remaining for the upload. This is the length\n// of the very first interval to get a reasonable estimate on screen in\n// a reasonable amount of time. The length of each interval after the first\n// is based on the upload rate calculated. Faster rates use this base interval\n// length. Slower rates below UPLOAD_RATE_THRESHOLD get longer interval times\n// to obtain more accurate upload rates.\nconst BASE_INTERVAL_TIME = 15000;\n\n// The upload rate threshold to determine the length of the interval to\n// calculate the upload rate.\nconst UPLOAD_RATE_THRESHOLD = 75;\n\nconst NO_WRAP_ELLIPSIS_CLASS_NAMES = 'text-ellipsis whitespace-nowrap overflow-hidden';\n\nfunction DicomUploadProgress({\n  dicomFileUploaderArr,\n  onComplete,\n}: DicomUploadProgressProps): ReactElement {\n  const [totalUploadSize] = useState(\n    dicomFileUploaderArr.reduce((acc, fileUploader) => acc + fileUploader.getFileSize(), 0)\n  );\n\n  const currentUploadSizeRef = useRef<number>(0);\n\n  const uploadRateRef = useRef(0);\n\n  const [timeRemaining, setTimeRemaining] = useState<number>(null);\n\n  const [percentComplete, setPercentComplete] = useState(0);\n\n  const [numFilesCompleted, setNumFilesCompleted] = useState(0);\n\n  const [numFails, setNumFails] = useState(0);\n\n  const [showFailedOnly, setShowFailedOnly] = useState(false);\n\n  const progressBarContainerRef = useRef<HTMLElement>();\n\n  /**\n   * The effect for measuring and setting the current upload rate. This is\n   * done by measuring the amount of data uploaded in a set interval time.\n   */\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout;\n\n    // The amount of data already uploaded at the start of the interval.\n    let intervalStartUploadSize = 0;\n\n    // The starting time of the interval.\n    let intervalStartTime = Date.now();\n\n    const setUploadRateRef = () => {\n      const uploadSizeFromStartOfInterval = currentUploadSizeRef.current - intervalStartUploadSize;\n\n      const now = Date.now();\n      const timeSinceStartOfInterval = now - intervalStartTime;\n\n      // Calculate and set the upload rate (ref)\n      uploadRateRef.current = uploadSizeFromStartOfInterval / timeSinceStartOfInterval;\n\n      // Reset the interval starting values.\n      intervalStartUploadSize = currentUploadSizeRef.current;\n      intervalStartTime = now;\n\n      // Only start a new interval if there is more to upload.\n      if (totalUploadSize - currentUploadSizeRef.current > 0) {\n        if (uploadRateRef.current >= UPLOAD_RATE_THRESHOLD) {\n          timeoutId = setTimeout(setUploadRateRef, BASE_INTERVAL_TIME);\n        } else {\n          // The current upload rate is relatively slow, so use a larger\n          // time interval to get a better upload rate estimate.\n          timeoutId = setTimeout(setUploadRateRef, BASE_INTERVAL_TIME * 2);\n        }\n      }\n    };\n\n    // The very first interval is just the base time interval length.\n    timeoutId = setTimeout(setUploadRateRef, BASE_INTERVAL_TIME);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, []);\n\n  /**\n   * The effect for: updating the overall percentage complete; setting the\n   * estimated time remaining; updating the number of files uploaded; and\n   * detecting if any error has occurred.\n   */\n  useEffect(() => {\n    let currentTimeRemaining = null;\n\n    // For each uploader, listen for the progress percentage complete and\n    // add promise catch/finally callbacks to detect errors and count number\n    // of uploads complete.\n    const subscriptions = dicomFileUploaderArr.map(fileUploader => {\n      let currentFileUploadSize = 0;\n\n      const updateProgress = (percentComplete: number) => {\n        const previousFileUploadSize = currentFileUploadSize;\n\n        currentFileUploadSize = Math.round((percentComplete / 100) * fileUploader.getFileSize());\n\n        currentUploadSizeRef.current = Math.min(\n          totalUploadSize,\n          currentUploadSizeRef.current - previousFileUploadSize + currentFileUploadSize\n        );\n\n        setPercentComplete((currentUploadSizeRef.current / totalUploadSize) * 100);\n\n        if (uploadRateRef.current !== 0) {\n          const uploadSizeRemaining = totalUploadSize - currentUploadSizeRef.current;\n\n          const timeRemaining = Math.round(uploadSizeRemaining / uploadRateRef.current);\n\n          if (currentTimeRemaining === null) {\n            currentTimeRemaining = timeRemaining;\n            setTimeRemaining(currentTimeRemaining);\n            return;\n          }\n\n          // Do not show an increase in the time remaining by two seconds or minutes\n          // so as to prevent jumping the time remaining up and down constantly\n          // due to rounding, inaccuracies in the estimate and slight variations\n          // in upload rates over time.\n          if (timeRemaining < ONE_MINUTE) {\n            const currentSecondsRemaining = Math.ceil(currentTimeRemaining / ONE_SECOND);\n            const secondsRemaining = Math.ceil(timeRemaining / ONE_SECOND);\n            const delta = secondsRemaining - currentSecondsRemaining;\n            if (delta < 0 || delta > 2) {\n              currentTimeRemaining = timeRemaining;\n              setTimeRemaining(currentTimeRemaining);\n            }\n            return;\n          }\n\n          if (timeRemaining < ONE_HOUR) {\n            const currentMinutesRemaining = Math.ceil(currentTimeRemaining / ONE_MINUTE);\n            const minutesRemaining = Math.ceil(timeRemaining / ONE_MINUTE);\n            const delta = minutesRemaining - currentMinutesRemaining;\n            if (delta < 0 || delta > 2) {\n              currentTimeRemaining = timeRemaining;\n              setTimeRemaining(currentTimeRemaining);\n            }\n            return;\n          }\n\n          // Hours remaining...\n          currentTimeRemaining = timeRemaining;\n          setTimeRemaining(currentTimeRemaining);\n        }\n      };\n\n      const progressCallback = (progressEvent: DicomFileUploaderProgressEvent) => {\n        updateProgress(progressEvent.percentComplete);\n      };\n\n      // Use the uploader promise to flag any error and count the number of\n      // uploads completed.\n      fileUploader\n        .load()\n        .catch((rejection: UploadRejection) => {\n          if (rejection.status === UploadStatus.Failed) {\n            setNumFails(numFails => numFails + 1);\n          }\n        })\n        .finally(() => {\n          // If any error occurred, the percent complete progress stops firing\n          // but this call to updateProgress nicely puts all finished uploads at 100%.\n          updateProgress(100);\n          setNumFilesCompleted(numCompleted => numCompleted + 1);\n        });\n\n      return fileUploader.subscribe(EVENTS.PROGRESS, progressCallback);\n    });\n    return () => {\n      subscriptions.forEach(subscription => subscription.unsubscribe());\n    };\n  }, []);\n\n  const cancelAllUploads = useCallback(async () => {\n    for (const dicomFileUploader of dicomFileUploaderArr) {\n      // Important: we need a non-blocking way to cancel every upload,\n      // otherwise the UI will freeze and the user will not be able\n      // to interact with the app and progress will not be updated.\n      const promise = new Promise<void>((resolve, reject) => {\n        setTimeout(() => {\n          dicomFileUploader.cancel();\n          resolve();\n        }, 0);\n      });\n    }\n  }, []);\n\n  const getFormattedTimeRemaining = useCallback((): string => {\n    if (timeRemaining == null) {\n      return '';\n    }\n\n    if (timeRemaining < ONE_MINUTE) {\n      const secondsRemaining = Math.ceil(timeRemaining / ONE_SECOND);\n      return `${secondsRemaining} ${secondsRemaining === 1 ? 'second' : 'seconds'}`;\n    }\n\n    if (timeRemaining < ONE_HOUR) {\n      const minutesRemaining = Math.ceil(timeRemaining / ONE_MINUTE);\n      return `${minutesRemaining} ${minutesRemaining === 1 ? 'minute' : 'minutes'}`;\n    }\n\n    const hoursRemaining = Math.ceil(timeRemaining / ONE_HOUR);\n    return `${hoursRemaining} ${hoursRemaining === 1 ? 'hour' : 'hours'}`;\n  }, [timeRemaining]);\n\n  const getPercentCompleteRounded = useCallback(\n    () => Math.min(100, Math.round(percentComplete)),\n    [percentComplete]\n  );\n\n  /**\n   * Determines if the progress bar should show the infinite animation or not.\n   * Show the infinite animation for progress less than 1% AND if less than\n   * one pixel of the progress bar would be displayed.\n   */\n  const showInfiniteProgressBar = useCallback((): boolean => {\n    return (\n      getPercentCompleteRounded() < 1 &&\n      (progressBarContainerRef?.current?.offsetWidth ?? 0) * (percentComplete / 100) < 1\n    );\n  }, [getPercentCompleteRounded, percentComplete]);\n\n  /**\n   * Gets the css style for the 'n of m' (files completed) text. The only css attribute\n   * of the style is width such that the 'n of m' is always a fixed width and thus\n   * as each file completes uploading the text on screen does not constantly shift\n   * left and right.\n   */\n  const getNofMFilesStyle = useCallback(() => {\n    // the number of digits accounts for the digits being on each side of the ' of '\n    const numDigits = 2 * dicomFileUploaderArr.length.toString().length;\n    // the number of digits + 2 spaces and 2 characters for ' of '\n    const numChars = numDigits + 4;\n    return { width: `${numChars}ch` };\n  }, []);\n\n  const getNumCompletedAndTimeRemainingComponent = (): ReactElement => {\n    return (\n      <div className=\"bg-primary-dark flex h-14 items-center px-1 pb-4 text-lg\">\n        {numFilesCompleted === dicomFileUploaderArr.length ? (\n          <>\n            <span className={NO_WRAP_ELLIPSIS_CLASS_NAMES}>{`${dicomFileUploaderArr.length} ${\n              dicomFileUploaderArr.length > 1 ? 'files' : 'file'\n            } completed.`}</span>\n            <Button\n              disabled={false}\n              className=\"ml-auto\"\n              onClick={onComplete}\n            >\n              {'Close'}\n            </Button>\n          </>\n        ) : (\n          <>\n            <span\n              style={getNofMFilesStyle()}\n              className={classNames(NO_WRAP_ELLIPSIS_CLASS_NAMES, 'text-end')}\n            >\n              {`${numFilesCompleted} of ${dicomFileUploaderArr.length}`}&nbsp;\n            </span>\n            <span className={NO_WRAP_ELLIPSIS_CLASS_NAMES}>{' files completed.'}&nbsp;</span>\n            <span className={NO_WRAP_ELLIPSIS_CLASS_NAMES}>\n              {timeRemaining ? `Less than ${getFormattedTimeRemaining()} remaining. ` : ''}\n            </span>\n            <span\n              className={classNames(\n                NO_WRAP_ELLIPSIS_CLASS_NAMES,\n                'text-primary-active hover:text-primary-light active:text-aqua-pale ml-auto cursor-pointer'\n              )}\n              onClick={cancelAllUploads}\n            >\n              Cancel All Uploads\n            </span>\n          </>\n        )}\n      </div>\n    );\n  };\n\n  const getShowFailedOnlyIconComponent = (): ReactElement => {\n    return (\n      <div className=\"ml-auto flex w-6 justify-center\">\n        {numFails > 0 && (\n          <div onClick={() => setShowFailedOnly(currentShowFailedOnly => !currentShowFailedOnly)}>\n            <Icon\n              className=\"cursor-pointer\"\n              name=\"icon-status-alert\"\n            ></Icon>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const getPercentCompleteComponent = (): ReactElement => {\n    return (\n      <div className=\"ohif-scrollbar border-secondary-light overflow-y-scroll border-b px-2\">\n        <div className=\"min-h-14 flex w-full items-center p-2.5\">\n          {numFilesCompleted === dicomFileUploaderArr.length ? (\n            <>\n              <div className=\"text-primary-light text-xl\">\n                {numFails > 0\n                  ? `Completed with ${numFails} ${numFails > 1 ? 'errors' : 'error'}!`\n                  : 'Completed!'}\n              </div>\n              {getShowFailedOnlyIconComponent()}\n            </>\n          ) : (\n            <>\n              <div\n                ref={progressBarContainerRef}\n                className=\"flex-grow\"\n              >\n                <ProgressLoadingBar\n                  progress={showInfiniteProgressBar() ? undefined : Math.min(100, percentComplete)}\n                ></ProgressLoadingBar>\n              </div>\n              <div className=\"ml-1 flex w-24 items-center\">\n                <div className=\"w-10 text-right\">{`${getPercentCompleteRounded()}%`}</div>\n                {getShowFailedOnlyIconComponent()}\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"flex grow flex-col\">\n      {getNumCompletedAndTimeRemainingComponent()}\n      <div className=\"flex grow flex-col overflow-hidden bg-black text-lg\">\n        {getPercentCompleteComponent()}\n        <div className=\"ohif-scrollbar h-1 grow overflow-y-scroll px-2\">\n          {dicomFileUploaderArr\n            .filter(\n              dicomFileUploader =>\n                !showFailedOnly || dicomFileUploader.getStatus() === UploadStatus.Failed\n            )\n            .map(dicomFileUploader => (\n              <DicomUploadProgressItem\n                key={dicomFileUploader.getFileId()}\n                dicomFileUploader={dicomFileUploader}\n              />\n            ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nDicomUploadProgress.propTypes = {\n  dicomFileUploaderArr: PropTypes.arrayOf(PropTypes.instanceOf(DicomFileUploader)).isRequired,\n  onComplete: PropTypes.func.isRequired,\n};\n\nexport default DicomUploadProgress;\n","import React, { useCallback, useState } from 'react';\nimport { ReactElement } from 'react';\nimport Dropzone from 'react-dropzone';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport DicomFileUploader from '../../utils/DicomFileUploader';\nimport DicomUploadProgress from './DicomUploadProgress';\nimport { Button, ButtonEnums } from '@ohif/ui';\nimport './DicomUpload.css';\n\ntype DicomUploadProps = {\n  dataSource;\n  onComplete: () => void;\n  onStarted: () => void;\n};\n\nfunction DicomUpload({ dataSource, onComplete, onStarted }: DicomUploadProps): ReactElement {\n  const baseClassNames = 'min-h-[480px] flex flex-col bg-black select-none';\n  const [dicomFileUploaderArr, setDicomFileUploaderArr] = useState([]);\n\n  const onDrop = useCallback(async acceptedFiles => {\n    onStarted();\n    setDicomFileUploaderArr(acceptedFiles.map(file => new DicomFileUploader(file, dataSource)));\n  }, []);\n\n  const getDropZoneComponent = (): ReactElement => {\n    return (\n      <Dropzone\n        onDrop={acceptedFiles => {\n          onDrop(acceptedFiles);\n        }}\n        noClick\n      >\n        {({ getRootProps }) => (\n          <div\n            {...getRootProps()}\n            className=\"dicom-upload-drop-area-border-dash m-5 flex h-full flex-col items-center justify-center\"\n          >\n            <div className=\"flex gap-3\">\n              <Dropzone\n                onDrop={onDrop}\n                noDrag\n              >\n                {({ getRootProps, getInputProps }) => (\n                  <div {...getRootProps()}>\n                    <Button\n                      disabled={false}\n                      onClick={() => {}}\n                    >\n                      {'Add files'}\n                      <input {...getInputProps()} />\n                    </Button>\n                  </div>\n                )}\n              </Dropzone>\n              <Dropzone\n                onDrop={onDrop}\n                noDrag\n              >\n                {({ getRootProps, getInputProps }) => (\n                  <div {...getRootProps()}>\n                    <Button\n                      type={ButtonEnums.type.secondary}\n                      disabled={false}\n                      onClick={() => {}}\n                    >\n                      {'Add folder'}\n                      <input\n                        {...getInputProps()}\n                        webkitdirectory=\"true\"\n                        mozdirectory=\"true\"\n                      />\n                    </Button>\n                  </div>\n                )}\n              </Dropzone>\n            </div>\n            <div className=\"pt-5\">or drag images or folders here</div>\n            <div className=\"text-aqua-pale pt-3 text-lg\">(DICOM files supported)</div>\n          </div>\n        )}\n      </Dropzone>\n    );\n  };\n\n  return (\n    <>\n      {dicomFileUploaderArr.length ? (\n        <div className={classNames('h-[calc(100vh-300px)]', baseClassNames)}>\n          <DicomUploadProgress\n            dicomFileUploaderArr={Array.from(dicomFileUploaderArr)}\n            onComplete={onComplete}\n          />\n        </div>\n      ) : (\n        <div className={classNames('h-[480px]', baseClassNames)}>{getDropZoneComponent()}</div>\n      )}\n    </>\n  );\n}\n\nDicomUpload.propTypes = {\n  dataSource: PropTypes.object.isRequired,\n  onComplete: PropTypes.func.isRequired,\n  onStarted: PropTypes.func.isRequired,\n};\n\nexport default DicomUpload;\n","import { Enums } from '@cornerstonejs/tools';\nimport { toolNames } from './initCornerstoneTools';\nimport DicomUpload from './components/DicomUpload/DicomUpload';\n\nconst tools = {\n  active: [\n    {\n      toolName: toolNames.WindowLevel,\n      bindings: [{ mouseButton: Enums.MouseBindings.Primary }],\n    },\n    {\n      toolName: toolNames.Pan,\n      bindings: [{ mouseButton: Enums.MouseBindings.Auxiliary }],\n    },\n    {\n      toolName: toolNames.Zoom,\n      bindings: [{ mouseButton: Enums.MouseBindings.Secondary }],\n    },\n    { toolName: toolNames.StackScrollMouseWheel, bindings: [] },\n  ],\n  enabled: [{ toolName: toolNames.SegmentationDisplay }],\n};\n\nfunction getCustomizationModule() {\n  return [\n    {\n      name: 'cornerstoneDicomUploadComponent',\n      value: {\n        id: 'dicomUploadComponent',\n        component: DicomUpload,\n      },\n    },\n    {\n      name: 'default',\n      value: [\n        {\n          id: 'cornerstone.overlayViewportTools',\n          tools,\n        },\n      ],\n    },\n  ];\n}\n\nexport default getCustomizationModule;\n","import React, { useEffect, useState } from 'react';\nimport html2canvas from 'html2canvas';\nimport {\n  Enums,\n  getEnabledElement,\n  getOrCreateCanvas,\n  StackViewport,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { ToolGroupManager } from '@cornerstonejs/tools';\nimport PropTypes from 'prop-types';\nimport { ViewportDownloadForm } from '@ohif/ui';\n\nimport { getEnabledElement as OHIFgetEnabledElement } from '../state';\n\nconst MINIMUM_SIZE = 100;\nconst DEFAULT_SIZE = 512;\nconst MAX_TEXTURE_SIZE = 10000;\nconst VIEWPORT_ID = 'cornerstone-viewport-download-form';\n\nconst CornerstoneViewportDownloadForm = ({\n  onClose,\n  activeViewportId: activeViewportIdProp,\n  cornerstoneViewportService,\n}) => {\n  const enabledElement = OHIFgetEnabledElement(activeViewportIdProp);\n  const activeViewportElement = enabledElement?.element;\n  const activeViewportEnabledElement = getEnabledElement(activeViewportElement);\n\n  const { viewportId: activeViewportId, renderingEngineId } = activeViewportEnabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(activeViewportId, renderingEngineId);\n\n  const toolModeAndBindings = Object.keys(toolGroup.toolOptions).reduce((acc, toolName) => {\n    const tool = toolGroup.toolOptions[toolName];\n    const { mode, bindings } = tool;\n\n    return {\n      ...acc,\n      [toolName]: {\n        mode,\n        bindings,\n      },\n    };\n  }, {});\n\n  useEffect(() => {\n    return () => {\n      Object.keys(toolModeAndBindings).forEach(toolName => {\n        const { mode, bindings } = toolModeAndBindings[toolName];\n        toolGroup.setToolMode(toolName, mode, { bindings });\n      });\n    };\n  }, []);\n\n  const enableViewport = viewportElement => {\n    if (viewportElement) {\n      const { renderingEngine, viewport } = getEnabledElement(activeViewportElement);\n\n      const viewportInput = {\n        viewportId: VIEWPORT_ID,\n        element: viewportElement,\n        type: viewport.type,\n        defaultOptions: {\n          background: viewport.defaultOptions.background,\n          orientation: viewport.defaultOptions.orientation,\n        },\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n  };\n\n  const disableViewport = viewportElement => {\n    if (viewportElement) {\n      const { renderingEngine } = getEnabledElement(viewportElement);\n      return new Promise(resolve => {\n        renderingEngine.disableElement(VIEWPORT_ID);\n      });\n    }\n  };\n\n  const updateViewportPreview = (downloadViewportElement, internalCanvas, fileType) =>\n    new Promise(resolve => {\n      const enabledElement = getEnabledElement(downloadViewportElement);\n\n      const { viewport: downloadViewport, renderingEngine } = enabledElement;\n\n      // Note: Since any trigger of dimensions will update the viewport,\n      // we need to resize the offScreenCanvas to accommodate for the new\n      // dimensions, this is due to the reason that we are using the GPU offScreenCanvas\n      // to render the viewport for the downloadViewport.\n      renderingEngine.resize();\n\n      // Trigger the render on the viewport to update the on screen\n      downloadViewport.render();\n\n      downloadViewportElement.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        function updateViewport(event) {\n          const enabledElement = getEnabledElement(event.target);\n          const { viewport } = enabledElement;\n          const { element } = viewport;\n\n          const downloadCanvas = getOrCreateCanvas(element);\n\n          const type = 'image/' + fileType;\n          const dataUrl = downloadCanvas.toDataURL(type, 1);\n\n          let newWidth = element.offsetHeight;\n          let newHeight = element.offsetWidth;\n\n          if (newWidth > DEFAULT_SIZE || newHeight > DEFAULT_SIZE) {\n            const multiplier = DEFAULT_SIZE / Math.max(newWidth, newHeight);\n            newHeight *= multiplier;\n            newWidth *= multiplier;\n          }\n\n          resolve({ dataUrl, width: newWidth, height: newHeight });\n\n          downloadViewportElement.removeEventListener(Enums.Events.IMAGE_RENDERED, updateViewport);\n        }\n      );\n    });\n\n  const loadImage = (activeViewportElement, viewportElement, width, height) =>\n    new Promise(resolve => {\n      if (activeViewportElement && viewportElement) {\n        const activeViewportEnabledElement = getEnabledElement(activeViewportElement);\n\n        if (!activeViewportEnabledElement) {\n          return;\n        }\n\n        const { viewport } = activeViewportEnabledElement;\n\n        const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n        const downloadViewport = renderingEngine.getViewport(VIEWPORT_ID);\n\n        if (downloadViewport instanceof StackViewport) {\n          const imageId = viewport.getCurrentImageId();\n          const properties = viewport.getProperties();\n\n          downloadViewport.setStack([imageId]).then(() => {\n            downloadViewport.setProperties(properties);\n\n            const newWidth = Math.min(width || image.width, MAX_TEXTURE_SIZE);\n            const newHeight = Math.min(height || image.height, MAX_TEXTURE_SIZE);\n\n            resolve({ width: newWidth, height: newHeight });\n          });\n        } else if (downloadViewport instanceof VolumeViewport) {\n          const actors = viewport.getActors();\n          // downloadViewport.setActors(actors);\n          actors.forEach(actor => {\n            downloadViewport.addActor(actor);\n          });\n\n          downloadViewport.setCamera(viewport.getCamera());\n          downloadViewport.render();\n\n          const newWidth = Math.min(width || image.width, MAX_TEXTURE_SIZE);\n          const newHeight = Math.min(height || image.height, MAX_TEXTURE_SIZE);\n\n          resolve({ width: newWidth, height: newHeight });\n        }\n      }\n    });\n\n  const toggleAnnotations = (toggle, viewportElement, activeViewportElement) => {\n    const activeViewportEnabledElement = getEnabledElement(activeViewportElement);\n\n    const downloadViewportElement = getEnabledElement(viewportElement);\n\n    const { viewportId: activeViewportId, renderingEngineId } = activeViewportEnabledElement;\n    const { viewportId: downloadViewportId } = downloadViewportElement;\n\n    if (!activeViewportEnabledElement || !downloadViewportElement) {\n      return;\n    }\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(activeViewportId, renderingEngineId);\n\n    // add the viewport to the toolGroup\n    toolGroup.addViewport(downloadViewportId, renderingEngineId);\n\n    Object.keys(toolGroup._toolInstances).forEach(toolName => {\n      // make all tools Enabled so that they can not be interacted with\n      // in the download viewport\n      if (toggle && toolName !== 'Crosshairs') {\n        try {\n          toolGroup.setToolEnabled(toolName);\n        } catch (e) {\n          console.log(e);\n        }\n      } else {\n        toolGroup.setToolDisabled(toolName);\n      }\n    });\n  };\n\n  const downloadBlob = (filename, fileType) => {\n    const file = `${filename}.${fileType}`;\n    const divForDownloadViewport = document.querySelector(\n      `div[data-viewport-uid=\"${VIEWPORT_ID}\"]`\n    );\n\n    html2canvas(divForDownloadViewport).then(canvas => {\n      const link = document.createElement('a');\n      link.download = file;\n      link.href = canvas.toDataURL(fileType, 1.0);\n      link.click();\n    });\n  };\n\n  return (\n    <ViewportDownloadForm\n      onClose={onClose}\n      minimumSize={MINIMUM_SIZE}\n      maximumSize={MAX_TEXTURE_SIZE}\n      defaultSize={DEFAULT_SIZE}\n      canvasClass={'cornerstone-canvas'}\n      activeViewportElement={activeViewportElement}\n      enableViewport={enableViewport}\n      disableViewport={disableViewport}\n      updateViewportPreview={updateViewportPreview}\n      loadImage={loadImage}\n      toggleAnnotations={toggleAnnotations}\n      downloadBlob={downloadBlob}\n    />\n  );\n};\n\nCornerstoneViewportDownloadForm.propTypes = {\n  onClose: PropTypes.func,\n  activeViewportId: PropTypes.string.isRequired,\n};\n\nexport default CornerstoneViewportDownloadForm;\n","import { Types, getRenderingEngine, utilities } from '@cornerstonejs/core';\n\nexport default function calculateViewportRegistrations(viewports: Types.IViewportId[]) {\n  const viewportPairs = _getViewportPairs(viewports);\n\n  for (const [viewport, nextViewport] of viewportPairs) {\n    // check if they are in the same Frame of Reference\n    const renderingEngine1 = getRenderingEngine(viewport.renderingEngineId);\n    const renderingEngine2 = getRenderingEngine(nextViewport.renderingEngineId);\n\n    const csViewport1 = renderingEngine1.getViewport(viewport.viewportId);\n    const csViewport2 = renderingEngine2.getViewport(nextViewport.viewportId);\n\n    utilities.calculateViewportsSpatialRegistration(csViewport1, csViewport2);\n  }\n}\n\nconst _getViewportPairs = (viewports: Types.IViewportId[]) => {\n  const viewportPairs = [];\n\n  for (let i = 0; i < viewports.length; i++) {\n    for (let j = i + 1; j < viewports.length; j++) {\n      viewportPairs.push([viewports[i], viewports[j]]);\n    }\n  }\n\n  return viewportPairs;\n};\n","import calculateViewportRegistrations from './calculateViewportRegistrations';\n\n// [ {\n//   synchronizerId: string,\n//   viewports: [ { viewportId: string, renderingEngineId: string, index: number } , ...]\n// ]}\nlet STACK_IMAGE_SYNC_GROUPS_INFO = [];\n\nexport default function toggleStackImageSync({ toggledState, servicesManager, getEnabledElement }) {\n  const { syncGroupService, viewportGridService, displaySetService, cornerstoneViewportService } =\n    servicesManager.services;\n\n  if (!toggledState) {\n    STACK_IMAGE_SYNC_GROUPS_INFO.forEach(syncGroupInfo => {\n      const { viewports, synchronizerId } = syncGroupInfo;\n\n      viewports.forEach(({ viewportId, renderingEngineId }) => {\n        syncGroupService.removeViewportFromSyncGroup(viewportId, renderingEngineId, synchronizerId);\n      });\n    });\n\n    return;\n  }\n\n  STACK_IMAGE_SYNC_GROUPS_INFO = [];\n\n  // create synchronization groups and add viewports\n  const { viewports } = viewportGridService.getState();\n\n  // filter empty viewports\n  const viewportsArray = Array.from(viewports.values())\n    .filter(viewport => viewport.displaySetInstanceUIDs?.length)\n    // filter reconstructable viewports\n    .filter(viewport => {\n      const { displaySetInstanceUIDs } = viewport;\n\n      for (const displaySetInstanceUID of displaySetInstanceUIDs) {\n        const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n        return !!displaySet?.isReconstructable;\n      }\n    });\n\n  const viewportsByOrientation = viewportsArray.reduce((acc, viewport) => {\n    const { viewportId, viewportType } = viewport.viewportOptions;\n\n    if (viewportType !== 'stack') {\n      console.warn('Viewport is not a stack, cannot sync images yet');\n      return acc;\n    }\n\n    const { element } = cornerstoneViewportService.getViewportInfo(viewportId);\n    const { viewport: csViewport, renderingEngineId } = getEnabledElement(element);\n    const { viewPlaneNormal } = csViewport.getCamera();\n\n    // Should we round here? I guess so, but not sure how much precision we need\n    const orientation = viewPlaneNormal.map(v => Math.round(v)).join(',');\n\n    if (!acc[orientation]) {\n      acc[orientation] = [];\n    }\n\n    acc[orientation].push({ viewportId, renderingEngineId });\n\n    return acc;\n  }, {});\n\n  // create synchronizer for each group\n  Object.values(viewportsByOrientation).map(viewports => {\n    let synchronizerId = viewports.map(({ viewportId }) => viewportId).join(',');\n\n    synchronizerId = `imageSync_${synchronizerId}`;\n\n    calculateViewportRegistrations(viewports);\n\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      syncGroupService.addViewportToSyncGroup(viewportId, renderingEngineId, {\n        type: 'stackimage',\n        id: synchronizerId,\n        source: true,\n        target: true,\n      });\n    });\n\n    STACK_IMAGE_SYNC_GROUPS_INFO.push({\n      synchronizerId,\n      viewports,\n    });\n  });\n}\n","import { annotation as cs3dToolAnnotationUtils } from '@cornerstonejs/tools';\n\n/**\n * Check whether an annotation from imaging library is selected or not.\n * @param {string} annotationUID uid of imaging library annotation\n * @returns boolean\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return cs3dToolAnnotationUtils.selection.isAnnotationSelected(annotationUID);\n}\n\n/**\n * Change an annotation from imaging library's selected property.\n * @param annotationUID - uid of imaging library annotation\n * @param selected - new value for selected\n */\nfunction setAnnotationSelected(annotationUID: string, selected: boolean): void {\n  const isCurrentSelected = isAnnotationSelected(annotationUID);\n  // branch cut, avoid invoking imaging library unnecessarily.\n  if (isCurrentSelected !== selected) {\n    cs3dToolAnnotationUtils.selection.setAnnotationSelected(annotationUID, selected);\n  }\n}\n\nfunction getFirstAnnotationSelected(element) {\n  const [selectedAnnotationUID] = cs3dToolAnnotationUtils.selection.getAnnotationsSelected() || [];\n\n  if (selectedAnnotationUID) {\n    return cs3dToolAnnotationUtils.state.getAnnotation(selectedAnnotationUID);\n  }\n}\n\nexport { isAnnotationSelected, setAnnotationSelected, getFirstAnnotationSelected };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport {\n  ToolGroupManager,\n  Enums,\n  utilities as cstUtils,\n  ReferenceLinesTool,\n} from '@cornerstonejs/tools';\nimport { Types as OhifTypes } from '@ohif/core';\n\nimport CornerstoneViewportDownloadForm from './utils/CornerstoneViewportDownloadForm';\nimport callInputDialog from './utils/callInputDialog';\nimport toggleStackImageSync from './utils/stackSync/toggleStackImageSync';\nimport { getFirstAnnotationSelected } from './utils/measurementServiceMappings/utils/selection';\nimport getActiveViewportEnabledElement from './utils/getActiveViewportEnabledElement';\nimport { CornerstoneServices } from './types';\n\nfunction commandsModule({\n  servicesManager,\n  commandsManager,\n}: OhifTypes.Extensions.ExtensionParams): OhifTypes.Extensions.CommandsModule {\n  const {\n    viewportGridService,\n    toolGroupService,\n    cineService,\n    toolbarService,\n    stateSyncService,\n    uiDialogService,\n    cornerstoneViewportService,\n    uiNotificationService,\n    measurementService,\n  } = servicesManager.services as CornerstoneServices;\n\n  const { measurementServiceSource } = this;\n\n  function _getActiveViewportEnabledElement() {\n    return getActiveViewportEnabledElement(viewportGridService);\n  }\n  const actions = {\n    /**\n     * Generates the selector props for the context menu, specific to\n     * the cornerstone viewport, and then runs the context menu.\n     */\n    showCornerstoneContextMenu: options => {\n      const element = _getActiveViewportEnabledElement()?.viewport?.element;\n\n      const optionsToUse = { ...options, element };\n      const { useSelectedAnnotation, nearbyToolData, event } = optionsToUse;\n\n      // This code is used to invoke the context menu via keyboard shortcuts\n      if (useSelectedAnnotation && !nearbyToolData) {\n        const firstAnnotationSelected = getFirstAnnotationSelected(element);\n        // filter by allowed selected tools from config property (if there is any)\n        const isToolAllowed =\n          !optionsToUse.allowedSelectedTools ||\n          optionsToUse.allowedSelectedTools.includes(firstAnnotationSelected?.metadata?.toolName);\n        if (isToolAllowed) {\n          optionsToUse.nearbyToolData = firstAnnotationSelected;\n        } else {\n          return;\n        }\n      }\n\n      optionsToUse.defaultPointsPosition = [];\n      // if (optionsToUse.nearbyToolData) {\n      //   optionsToUse.defaultPointsPosition = commandsManager.runCommand(\n      //     'getToolDataActiveCanvasPoints',\n      //     { toolData: optionsToUse.nearbyToolData }\n      //   );\n      // }\n\n      // TODO - make the selectorProps richer by including the study metadata and display set.\n      optionsToUse.selectorProps = {\n        toolName: optionsToUse.nearbyToolData?.metadata?.toolName,\n        value: optionsToUse.nearbyToolData,\n        uid: optionsToUse.nearbyToolData?.annotationUID,\n        nearbyToolData: optionsToUse.nearbyToolData,\n        event,\n        ...optionsToUse.selectorProps,\n      };\n\n      commandsManager.run(options, optionsToUse);\n    },\n\n    getNearbyToolData({ nearbyToolData, element, canvasCoordinates }) {\n      return nearbyToolData ?? cstUtils.getAnnotationNearPoint(element, canvasCoordinates);\n    },\n    getNearbyAnnotation({ element, canvasCoordinates }) {\n      const nearbyToolData = actions.getNearbyToolData({\n        nearbyToolData: null,\n        element,\n        canvasCoordinates,\n      });\n\n      const isAnnotation = toolName => {\n        const enabledElement = getEnabledElement(element);\n\n        if (!enabledElement) {\n          return;\n        }\n\n        const { renderingEngineId, viewportId } = enabledElement;\n        const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n\n        const toolInstance = toolGroup.getToolInstance(toolName);\n\n        return toolInstance?.constructor?.isAnnotation ?? true;\n      };\n\n      return nearbyToolData?.metadata?.toolName && isAnnotation(nearbyToolData.metadata.toolName)\n        ? nearbyToolData\n        : null;\n    },\n\n    // Measurement tool commands:\n\n    /** Delete the given measurement */\n    deleteMeasurement: ({ uid }) => {\n      if (uid) {\n        measurementServiceSource.remove(uid);\n      }\n    },\n\n    /**\n     * Show the measurement labelling input dialog and update the label\n     * on the measurement with a response if not cancelled.\n     */\n    setMeasurementLabel: ({ uid }) => {\n      const measurement = measurementService.getMeasurement(uid);\n\n      callInputDialog(\n        uiDialogService,\n        measurement,\n        (label, actionId) => {\n          if (actionId === 'cancel') {\n            return;\n          }\n\n          const updatedMeasurement = Object.assign({}, measurement, {\n            label,\n          });\n\n          measurementService.update(updatedMeasurement.uid, updatedMeasurement, true);\n        },\n        false\n      );\n    },\n\n    /**\n     *\n     * @param props - containing the updates to apply\n     * @param props.measurementKey - chooses the measurement key to apply the\n     *        code to.  This will typically be finding or site to apply a\n     *        finind code or a findingSites code.\n     * @param props.code - A coding scheme value from DICOM, including:\n     *       * CodeValue - the language independent code, for example '1234'\n     *       * CodingSchemeDesignator - the issue of the code value\n     *       * CodeMeaning - the text value shown to the user\n     *       * ref - a string reference in the form `<designator>:<codeValue>`\n     *       * Other fields\n     *     Note it is a valid option to remove the finding or site values by\n     *     supplying null for the code.\n     * @param props.uid - the measurement UID to find it with\n     * @param props.label - the text value for the code.  Has NOTHING to do with\n     *        the measurement label, which can be set with textLabel\n     * @param props.textLabel is the measurement label to apply.  Set to null to\n     *            delete.\n     *\n     * If the measurementKey is `site`, then the code will also be added/replace\n     * the 0 element of findingSites.  This behaviour is expected to be enhanced\n     * in the future with ability to set other site information.\n     */\n    updateMeasurement: props => {\n      const { code, uid, textLabel, label } = props;\n      const measurement = measurementService.getMeasurement(uid);\n      const updatedMeasurement = {\n        ...measurement,\n      };\n      // Call it textLabel as the label value\n      // TODO - remove the label setting when direct rendering of findingSites is enabled\n      if (textLabel !== undefined) {\n        updatedMeasurement.label = textLabel;\n      }\n      if (code !== undefined) {\n        const measurementKey = code.type || 'finding';\n\n        if (code.ref && !code.CodeValue) {\n          const split = code.ref.indexOf(':');\n          code.CodeValue = code.ref.substring(split + 1);\n          code.CodeMeaning = code.text || label;\n          code.CodingSchemeDesignator = code.ref.substring(0, split);\n        }\n        updatedMeasurement[measurementKey] = code;\n        // TODO - remove this line once the measurements table customizations are in\n        if (measurementKey !== 'finding') {\n          if (updatedMeasurement.findingSites) {\n            updatedMeasurement.findingSites = updatedMeasurement.findingSites.filter(\n              it => it.type !== measurementKey\n            );\n            updatedMeasurement.findingSites.push(code);\n          } else {\n            updatedMeasurement.findingSites = [code];\n          }\n        }\n      }\n      measurementService.update(updatedMeasurement.uid, updatedMeasurement, true);\n    },\n\n    // Retrieve value commands\n    getActiveViewportEnabledElement: _getActiveViewportEnabledElement,\n\n    setViewportActive: ({ viewportId }) => {\n      const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n      if (!viewportInfo) {\n        console.warn('No viewport found for viewportId:', viewportId);\n        return;\n      }\n\n      viewportGridService.setActiveViewportId(viewportId);\n    },\n    arrowTextCallback: ({ callback, data }) => {\n      callInputDialog(uiDialogService, data, callback);\n    },\n    toggleCine: () => {\n      const { viewports } = viewportGridService.getState();\n      const { isCineEnabled } = cineService.getState();\n      cineService.setIsCineEnabled(!isCineEnabled);\n      toolbarService.setButton('Cine', { props: { isActive: !isCineEnabled } });\n      viewports.forEach((_, index) => cineService.setCine({ id: index, isPlaying: false }));\n    },\n    setWindowLevel({ window, level, toolGroupId }) {\n      // convert to numbers\n      const windowWidthNum = Number(window);\n      const windowCenterNum = Number(level);\n\n      const { viewportId } = _getActiveViewportEnabledElement();\n      const viewportToolGroupId = toolGroupService.getToolGroupForViewport(viewportId);\n\n      if (toolGroupId && toolGroupId !== viewportToolGroupId) {\n        return;\n      }\n\n      // get actor from the viewport\n      const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n      const viewport = renderingEngine.getViewport(viewportId);\n\n      const { lower, upper } = csUtils.windowLevel.toLowHighRange(windowWidthNum, windowCenterNum);\n\n      viewport.setProperties({\n        voiRange: {\n          upper,\n          lower,\n        },\n      });\n      viewport.render();\n    },\n\n    // Just call the toolbar service record interaction - allows\n    // executing a toolbar command as a full toolbar command with side affects\n    // coming from the ToolbarService itself.\n    toolbarServiceRecordInteraction: props => {\n      toolbarService.recordInteraction(props);\n    },\n    setToolActive: ({ toolName, toolGroupId = null, toggledState }) => {\n      if (toolName === 'Crosshairs') {\n        const activeViewportToolGroup = toolGroupService.getToolGroup(null);\n\n        if (!activeViewportToolGroup._toolInstances.Crosshairs) {\n          uiNotificationService.show({\n            title: 'Crosshairs',\n            message:\n              'You need to be in a MPR view to use Crosshairs. Click on MPR button in the toolbar to activate it.',\n            type: 'info',\n            duration: 3000,\n          });\n\n          throw new Error('Crosshairs tool is not available in this viewport');\n        }\n      }\n\n      const { viewports } = viewportGridService.getState();\n\n      if (!viewports.size) {\n        return;\n      }\n\n      const toolGroup = toolGroupService.getToolGroup(toolGroupId);\n      const toolGroupViewportIds = toolGroup?.getViewportIds?.();\n\n      // if toolGroup has been destroyed, or its viewports have been removed\n      if (!toolGroupViewportIds || !toolGroupViewportIds.length) {\n        return;\n      }\n\n      const filteredViewports = Array.from(viewports.values()).filter(viewport => {\n        return toolGroupViewportIds.includes(viewport.viewportId);\n      });\n\n      if (!filteredViewports.length) {\n        return;\n      }\n\n      if (!toolGroup.getToolInstance(toolName)) {\n        uiNotificationService.show({\n          title: `${toolName} tool`,\n          message: `The ${toolName} tool is not available in this viewport.`,\n          type: 'info',\n          duration: 3000,\n        });\n\n        throw new Error(`ToolGroup ${toolGroup.id} does not have this tool.`);\n      }\n\n      const activeToolName = toolGroup.getActivePrimaryMouseButtonTool();\n\n      if (activeToolName) {\n        // Todo: this is a hack to prevent the crosshairs to stick around\n        // after another tool is selected. We should find a better way to do this\n        if (activeToolName === 'Crosshairs') {\n          toolGroup.setToolDisabled(activeToolName);\n        } else {\n          toolGroup.setToolPassive(activeToolName);\n        }\n      }\n\n      // If there is a toggle state, then simply set the enabled/disabled state without\n      // setting the tool active.\n      if (toggledState != null) {\n        toggledState ? toolGroup.setToolEnabled(toolName) : toolGroup.setToolDisabled(toolName);\n        return;\n      }\n\n      // Set the new toolName to be active\n      toolGroup.setToolActive(toolName, {\n        bindings: [\n          {\n            mouseButton: Enums.MouseBindings.Primary,\n          },\n        ],\n      });\n    },\n    showDownloadViewportModal: () => {\n      const { activeViewportId } = viewportGridService.getState();\n\n      if (!cornerstoneViewportService.getCornerstoneViewport(activeViewportId)) {\n        // Cannot download a non-cornerstone viewport (image).\n        uiNotificationService.show({\n          title: 'Download Image',\n          message: 'Image cannot be downloaded',\n          type: 'error',\n        });\n        return;\n      }\n\n      const { uiModalService } = servicesManager.services;\n\n      if (uiModalService) {\n        uiModalService.show({\n          content: CornerstoneViewportDownloadForm,\n          title: 'Download High Quality Image',\n          contentProps: {\n            activeViewportId,\n            onClose: uiModalService.hide,\n            cornerstoneViewportService,\n          },\n        });\n      }\n    },\n    rotateViewport: ({ rotation }) => {\n      const enabledElement = _getActiveViewportEnabledElement();\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { rotation: currentRotation } = viewport.getProperties();\n        const newRotation = (currentRotation + rotation) % 360;\n        viewport.setProperties({ rotation: newRotation });\n        viewport.render();\n      }\n    },\n    flipViewportHorizontal: () => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { flipHorizontal } = viewport.getCamera();\n        viewport.setCamera({ flipHorizontal: !flipHorizontal });\n        viewport.render();\n      }\n    },\n    flipViewportVertical: () => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { flipVertical } = viewport.getCamera();\n        viewport.setCamera({ flipVertical: !flipVertical });\n        viewport.render();\n      }\n    },\n    invertViewport: ({ element }) => {\n      let enabledElement;\n\n      if (element === undefined) {\n        enabledElement = _getActiveViewportEnabledElement();\n      } else {\n        enabledElement = element;\n      }\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      const { invert } = viewport.getProperties();\n      viewport.setProperties({ invert: !invert });\n      viewport.render();\n    },\n    resetViewport: () => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        viewport.resetProperties();\n        viewport.resetCamera();\n      } else {\n        // Todo: add reset properties for volume viewport\n        viewport.resetCamera();\n      }\n\n      viewport.render();\n    },\n    scaleViewport: ({ direction }) => {\n      const enabledElement = _getActiveViewportEnabledElement();\n      const scaleFactor = direction > 0 ? 0.9 : 1.1;\n\n      if (!enabledElement) {\n        return;\n      }\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        if (direction) {\n          const { parallelScale } = viewport.getCamera();\n          viewport.setCamera({ parallelScale: parallelScale * scaleFactor });\n          viewport.render();\n        } else {\n          viewport.resetCamera();\n          viewport.render();\n        }\n      }\n    },\n\n    /** Jumps the active viewport or the specified one to the given slice index */\n    jumpToImage: ({ imageIndex, viewport: gridViewport }): void => {\n      // Get current active viewport (return if none active)\n      let viewport;\n      if (!gridViewport) {\n        const enabledElement = _getActiveViewportEnabledElement();\n        if (!enabledElement) {\n          return;\n        }\n        viewport = enabledElement.viewport;\n      } else {\n        viewport = cornerstoneViewportService.getCornerstoneViewport(gridViewport.id);\n      }\n\n      // Get number of slices\n      // -> Copied from cornerstone3D jumpToSlice\\_getImageSliceData()\n      let numberOfSlices = 0;\n\n      if (viewport instanceof StackViewport) {\n        numberOfSlices = viewport.getImageIds().length;\n      } else if (viewport instanceof VolumeViewport) {\n        numberOfSlices = csUtils.getImageSliceDataForVolumeViewport(viewport).numberOfSlices;\n      } else {\n        throw new Error('Unsupported viewport type');\n      }\n\n      const jumpIndex = imageIndex < 0 ? numberOfSlices + imageIndex : imageIndex;\n      if (jumpIndex >= numberOfSlices || jumpIndex < 0) {\n        throw new Error(`Can't jump to ${imageIndex}`);\n      }\n\n      // Set slice to last slice\n      const options = { imageIndex: jumpIndex };\n      cstUtils.jumpToSlice(viewport.element, options);\n    },\n    scroll: ({ direction }) => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      const options = { delta: direction };\n\n      cstUtils.scroll(viewport, options);\n    },\n    setViewportColormap: ({ viewportId, displaySetInstanceUID, colormap, immediate = false }) => {\n      const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n      const actorEntries = viewport.getActors();\n\n      const actorEntry = actorEntries.find(actorEntry => {\n        return actorEntry.uid.includes(displaySetInstanceUID);\n      });\n\n      const { actor: volumeActor, uid: volumeId } = actorEntry;\n\n      viewport.setProperties({ colormap, volumeActor }, volumeId);\n\n      if (immediate) {\n        viewport.render();\n      }\n    },\n    changeActiveViewport: ({ direction = 1 }) => {\n      const { activeViewportId, viewports } = viewportGridService.getState();\n      const viewportIds = Array.from(viewports.keys());\n      const currentIndex = viewportIds.indexOf(activeViewportId);\n      const nextViewportIndex =\n        (currentIndex + direction + viewportIds.length) % viewportIds.length;\n      viewportGridService.setActiveViewportId(viewportIds[nextViewportIndex] as string);\n    },\n\n    toggleStackImageSync: ({ toggledState }) => {\n      toggleStackImageSync({\n        getEnabledElement,\n        servicesManager,\n        toggledState,\n      });\n    },\n    setSourceViewportForReferenceLinesTool: ({ toggledState }) => {\n      const { activeViewportId } = viewportGridService.getState();\n      const viewportInfo = cornerstoneViewportService.getViewportInfo(activeViewportId);\n\n      const viewportId = viewportInfo.getViewportId();\n      const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n      toolGroup.setToolConfiguration(\n        ReferenceLinesTool.toolName,\n        {\n          sourceViewportId: viewportId,\n        },\n        true // overwrite\n      );\n    },\n    storePresentation: ({ viewportId }) => {\n      cornerstoneViewportService.storePresentation({ viewportId });\n    },\n  };\n\n  const definitions = {\n    // The command here is to show the viewer context menu, as being the\n    // context menu\n    showCornerstoneContextMenu: {\n      commandFn: actions.showCornerstoneContextMenu,\n      storeContexts: [],\n      options: {\n        menuCustomizationId: 'measurementsContextMenu',\n        commands: [\n          {\n            commandName: 'showContextMenu',\n          },\n        ],\n      },\n    },\n\n    getNearbyToolData: {\n      commandFn: actions.getNearbyToolData,\n    },\n    getNearbyAnnotation: {\n      commandFn: actions.getNearbyAnnotation,\n      storeContexts: [],\n      options: {},\n    },\n\n    deleteMeasurement: {\n      commandFn: actions.deleteMeasurement,\n    },\n    setMeasurementLabel: {\n      commandFn: actions.setMeasurementLabel,\n    },\n    updateMeasurement: {\n      commandFn: actions.updateMeasurement,\n    },\n\n    setWindowLevel: {\n      commandFn: actions.setWindowLevel,\n    },\n    toolbarServiceRecordInteraction: {\n      commandFn: actions.toolbarServiceRecordInteraction,\n    },\n    setToolActive: {\n      commandFn: actions.setToolActive,\n    },\n    rotateViewportCW: {\n      commandFn: actions.rotateViewport,\n      options: { rotation: 90 },\n    },\n    rotateViewportCCW: {\n      commandFn: actions.rotateViewport,\n      options: { rotation: -90 },\n    },\n    incrementActiveViewport: {\n      commandFn: actions.changeActiveViewport,\n    },\n    decrementActiveViewport: {\n      commandFn: actions.changeActiveViewport,\n      options: { direction: -1 },\n    },\n    flipViewportHorizontal: {\n      commandFn: actions.flipViewportHorizontal,\n    },\n    flipViewportVertical: {\n      commandFn: actions.flipViewportVertical,\n    },\n    invertViewport: {\n      commandFn: actions.invertViewport,\n    },\n    resetViewport: {\n      commandFn: actions.resetViewport,\n    },\n    scaleUpViewport: {\n      commandFn: actions.scaleViewport,\n      options: { direction: 1 },\n    },\n    scaleDownViewport: {\n      commandFn: actions.scaleViewport,\n      options: { direction: -1 },\n    },\n    fitViewportToWindow: {\n      commandFn: actions.scaleViewport,\n      options: { direction: 0 },\n    },\n    nextImage: {\n      commandFn: actions.scroll,\n      options: { direction: 1 },\n    },\n    previousImage: {\n      commandFn: actions.scroll,\n      options: { direction: -1 },\n    },\n    firstImage: {\n      commandFn: actions.jumpToImage,\n      options: { imageIndex: 0 },\n    },\n    lastImage: {\n      commandFn: actions.jumpToImage,\n      options: { imageIndex: -1 },\n    },\n    jumpToImage: {\n      commandFn: actions.jumpToImage,\n    },\n    showDownloadViewportModal: {\n      commandFn: actions.showDownloadViewportModal,\n    },\n    toggleCine: {\n      commandFn: actions.toggleCine,\n    },\n    arrowTextCallback: {\n      commandFn: actions.arrowTextCallback,\n    },\n    setViewportActive: {\n      commandFn: actions.setViewportActive,\n    },\n    setViewportColormap: {\n      commandFn: actions.setViewportColormap,\n    },\n    toggleStackImageSync: {\n      commandFn: actions.toggleStackImageSync,\n    },\n    setSourceViewportForReferenceLinesTool: {\n      commandFn: actions.setSourceViewportForReferenceLinesTool,\n    },\n    storePresentation: {\n      commandFn: actions.storePresentation,\n      storeContexts: [],\n      options: {},\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'CORNERSTONE',\n  };\n}\n\nexport default commandsModule;\n","import { Types } from '@ohif/core';\n\nconst mpr: Types.HangingProtocol.Protocol = {\n  id: 'mpr',\n  name: 'Multi-Planar Reconstruction',\n  locked: true,\n  createdDate: '2021-02-23',\n  modifiedDate: '2023-08-15',\n  availableTo: {},\n  editableBy: {},\n  // Unknown number of priors referenced - so just match any study\n  numberOfPriorsReferenced: 0,\n  protocolMatchingRules: [],\n  imageLoadStrategy: 'nth',\n  callbacks: {\n    // Switches out of MPR mode when the layout change button is used\n    onLayoutChange: [\n      {\n        commandName: 'toggleHangingProtocol',\n        commandOptions: { protocolId: 'mpr' },\n        context: 'DEFAULT',\n      },\n    ],\n    // Turns off crosshairs when switching out of MPR mode\n    onProtocolExit: [\n      {\n        commandName: 'toolbarServiceRecordInteraction',\n        commandOptions: {\n          interactionType: 'tool',\n          commands: [\n            {\n              commandOptions: {\n                toolName: 'WindowLevel',\n              },\n              context: 'CORNERSTONE',\n            },\n          ],\n        },\n      },\n    ],\n  },\n  displaySetSelectors: {\n    activeDisplaySet: {\n      seriesMatchingRules: [\n        {\n          weight: 1,\n          attribute: 'isReconstructable',\n          constraint: {\n            equals: {\n              value: true,\n            },\n          },\n          required: true,\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'MPR 1x3',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 3,\n          layoutOptions: [\n            {\n              x: 0,\n              y: 0,\n              width: 1 / 3,\n              height: 1,\n            },\n            {\n              x: 1 / 3,\n              y: 0,\n              width: 1 / 3,\n              height: 1,\n            },\n            {\n              x: 2 / 3,\n              y: 0,\n              width: 1 / 3,\n              height: 1,\n            },\n          ],\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            viewportId: 'mpr-axial',\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'axial',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'activeDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            viewportId: 'mpr-sagittal',\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'sagittal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'activeDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            viewportId: 'mpr-coronal',\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'coronal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'activeDisplaySet',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nconst mprAnd3DVolumeViewport = {\n  id: 'mprAnd3DVolumeViewport',\n  locked: true,\n  name: 'mpr',\n  createdDate: '2023-03-15T10:29:44.894Z',\n  modifiedDate: '2023-03-15T10:29:44.894Z',\n  availableTo: {},\n  editableBy: {},\n  protocolMatchingRules: [],\n  imageLoadStrategy: 'interleaveCenter',\n  displaySetSelectors: {\n    mprDisplaySet: {\n      seriesMatchingRules: [\n        {\n          weight: 1,\n          attribute: 'isReconstructable',\n          constraint: {\n            equals: {\n              value: true,\n            },\n          },\n          required: true,\n        },\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: {\n              value: 'CT',\n            },\n          },\n          required: true,\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      id: 'mpr3Stage',\n      name: 'mpr',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 2,\n          columns: 2,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'axial',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'volume3d',\n            viewportType: 'volume3d',\n            orientation: 'coronal',\n            customViewportProps: {\n              hideOverlays: true,\n            },\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n              options: {\n                displayPreset: 'CT-Bone',\n              },\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'coronal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'sagittal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: mpr.id,\n      protocol: mpr,\n    },\n    {\n      name: mprAnd3DVolumeViewport.id,\n      protocol: mprAnd3DVolumeViewport,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\n","import { ToolGroupManager, Enums, Types } from '@cornerstonejs/tools';\n\nimport { Types as OhifTypes, pubSubServiceInterface } from '@ohif/core';\nimport getActiveViewportEnabledElement from '../../utils/getActiveViewportEnabledElement';\n\nconst EVENTS = {\n  VIEWPORT_ADDED: 'event::cornerstone::toolgroupservice:viewportadded',\n  TOOLGROUP_CREATED: 'event::cornerstone::toolgroupservice:toolgroupcreated',\n};\n\ntype Tool = {\n  toolName: string;\n  bindings?: typeof Enums.MouseBindings | Enums.KeyboardBindings;\n};\n\ntype Tools = {\n  active: Tool[];\n  passive?: Tool[];\n  enabled?: Tool[];\n  disabled?: Tool[];\n};\n\nexport default class ToolGroupService {\n  public static REGISTRATION = {\n    name: 'toolGroupService',\n    altName: 'ToolGroupService',\n    create: ({ servicesManager }: OhifTypes.Extensions.ExtensionParams): ToolGroupService => {\n      return new ToolGroupService(servicesManager);\n    },\n  };\n\n  serviceManager: any;\n  private toolGroupIds: Set<string> = new Set();\n  /**\n   * Service-specific\n   */\n  listeners: { [key: string]: Function[] };\n  EVENTS: { [key: string]: string };\n\n  constructor(serviceManager) {\n    const { cornerstoneViewportService, viewportGridService } = serviceManager.services;\n    this.cornerstoneViewportService = cornerstoneViewportService;\n    this.viewportGridService = viewportGridService;\n    this.listeners = {};\n    this.EVENTS = EVENTS;\n    Object.assign(this, pubSubServiceInterface);\n  }\n\n  onModeExit() {\n    this.destroy();\n  }\n\n  /**\n   * Retrieves a tool group from the ToolGroupManager by tool group ID.\n   * If no tool group ID is provided, it retrieves the tool group of the active viewport.\n   * @param toolGroupId - Optional ID of the tool group to retrieve.\n   * @returns The tool group or undefined if it is not found.\n   */\n  public getToolGroup(toolGroupId?: string): Types.IToolGroup | void {\n    let toolGroupIdToUse = toolGroupId;\n\n    if (!toolGroupIdToUse) {\n      // Use the active viewport's tool group if no tool group id is provided\n      const enabledElement = getActiveViewportEnabledElement(this.viewportGridService);\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { renderingEngineId, viewportId } = enabledElement;\n      const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn(\n          'No tool group found for viewportId:',\n          viewportId,\n          'and renderingEngineId:',\n          renderingEngineId\n        );\n        return;\n      }\n\n      toolGroupIdToUse = toolGroup.id;\n    }\n\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupIdToUse);\n    return toolGroup;\n  }\n\n  public getToolGroupIds(): string[] {\n    return Array.from(this.toolGroupIds);\n  }\n\n  public getToolGroupForViewport(viewportId: string): Types.IToolGroup | void {\n    const renderingEngine = this.cornerstoneViewportService.getRenderingEngine();\n    return ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngine.id);\n  }\n\n  public getActiveToolForViewport(viewportId: string): string {\n    const toolGroup = this.getToolGroupForViewport(viewportId);\n    if (!toolGroup) {\n      return;\n    }\n\n    return toolGroup.getActivePrimaryMouseButtonTool();\n  }\n\n  public destroy() {\n    ToolGroupManager.destroy();\n    this.toolGroupIds = new Set();\n  }\n\n  public destroyToolGroup(toolGroupId: string) {\n    ToolGroupManager.destroyToolGroup(toolGroupId);\n    this.toolGroupIds.delete(toolGroupId);\n  }\n\n  public removeViewportFromToolGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    deleteToolGroupIfEmpty?: boolean\n  ): void {\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n\n    const viewportIds = toolGroup.getViewportIds();\n\n    if (viewportIds.length === 0 && deleteToolGroupIfEmpty) {\n      ToolGroupManager.destroyToolGroup(toolGroup.id);\n    }\n  }\n\n  public addViewportToToolGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    toolGroupId?: string\n  ): void {\n    if (!toolGroupId) {\n      // If toolGroupId is not provided, add the viewport to all toolGroups\n      const toolGroups = ToolGroupManager.getAllToolGroups();\n      toolGroups.forEach(toolGroup => {\n        toolGroup.addViewport(viewportId, renderingEngineId);\n      });\n    } else {\n      let toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n      if (!toolGroup) {\n        toolGroup = this.createToolGroup(toolGroupId);\n      }\n\n      toolGroup.addViewport(viewportId, renderingEngineId);\n    }\n\n    this._broadcastEvent(EVENTS.VIEWPORT_ADDED, {\n      viewportId,\n      toolGroupId,\n    });\n  }\n\n  public createToolGroup(toolGroupId: string): Types.IToolGroup {\n    if (this.getToolGroup(toolGroupId)) {\n      throw new Error(`ToolGroup ${toolGroupId} already exists`);\n    }\n\n    // if the toolGroup doesn't exist, create it\n    const toolGroup = ToolGroupManager.createToolGroup(toolGroupId);\n    this.toolGroupIds.add(toolGroupId);\n\n    this._broadcastEvent(EVENTS.TOOLGROUP_CREATED, {\n      toolGroupId,\n    });\n\n    return toolGroup;\n  }\n\n  public addToolsToToolGroup(toolGroupId: string, tools: Array<Tool>, configs: any = {}): void {\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n    // this.changeConfigurationIfNecessary(toolGroup, volumeId);\n    this._addTools(toolGroup, tools, configs);\n    this._setToolsMode(toolGroup, tools);\n  }\n\n  public createToolGroupAndAddTools(toolGroupId: string, tools: Array<Tool>): Types.IToolGroup {\n    const toolGroup = this.createToolGroup(toolGroupId);\n    this.addToolsToToolGroup(toolGroupId, tools);\n    return toolGroup;\n  }\n\n  /**\n  private changeConfigurationIfNecessary(toolGroup, volumeUID) {\n    // handle specific assignment for volumeUID (e.g., fusion)\n    const toolInstances = toolGroup._toolInstances;\n    // Object.values(toolInstances).forEach(toolInstance => {\n    //   if (toolInstance.configuration) {\n    //     toolInstance.configuration.volumeUID = volumeUID;\n    //   }\n    // });\n  }\n  */\n\n  /**\n   * Get the tool's configuration based on the tool name and tool group id\n   * @param toolGroupId - The id of the tool group that the tool instance belongs to.\n   * @param toolName - The name of the tool\n   * @returns The configuration of the tool.\n   */\n  public getToolConfiguration(toolGroupId: string, toolName: string) {\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n    if (!toolGroup) {\n      return null;\n    }\n\n    const tool = toolGroup.getToolInstance(toolName);\n    if (!tool) {\n      return null;\n    }\n\n    return tool.configuration;\n  }\n\n  /**\n   * Set the tool instance configuration. This will update the tool instance configuration\n   * on the toolGroup\n   * @param toolGroupId - The id of the tool group that the tool instance belongs to.\n   * @param toolName - The name of the tool\n   * @param config - The configuration object that you want to set.\n   */\n  public setToolConfiguration(toolGroupId, toolName, config) {\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n    const toolInstance = toolGroup.getToolInstance(toolName);\n    toolInstance.configuration = config;\n  }\n\n  private _setToolsMode(toolGroup, tools) {\n    const { active, passive, enabled, disabled } = tools;\n\n    if (active) {\n      active.forEach(({ toolName, bindings }) => {\n        toolGroup.setToolActive(toolName, { bindings });\n      });\n    }\n\n    if (passive) {\n      passive.forEach(({ toolName }) => {\n        toolGroup.setToolPassive(toolName);\n      });\n    }\n\n    if (enabled) {\n      enabled.forEach(({ toolName }) => {\n        toolGroup.setToolEnabled(toolName);\n      });\n    }\n\n    if (disabled) {\n      disabled.forEach(({ toolName }) => {\n        toolGroup.setToolDisabled(toolName);\n      });\n    }\n  }\n\n  private _addTools(toolGroup, tools) {\n    const addTools = tools => {\n      tools.forEach(({ toolName, parentTool, configuration }) => {\n        if (parentTool) {\n          toolGroup.addToolInstance(toolName, parentTool, {\n            ...configuration,\n          });\n        } else {\n          toolGroup.addTool(toolName, { ...configuration });\n        }\n      });\n    };\n\n    if (tools.active) {\n      addTools(tools.active);\n    }\n\n    if (tools.passive) {\n      addTools(tools.passive);\n    }\n\n    if (tools.enabled) {\n      addTools(tools.enabled);\n    }\n\n    if (tools.disabled) {\n      addTools(tools.disabled);\n    }\n  }\n}\n","import ToolGroupService from './ToolGroupService';\n\nexport default ToolGroupService;\n","import { synchronizers, SynchronizerManager, Synchronizer } from '@cornerstonejs/tools';\n\nimport { pubSubServiceInterface, Types, ServicesManager } from '@ohif/core';\n\nconst EVENTS = {\n  TOOL_GROUP_CREATED: 'event::cornerstone::syncgroupservice:toolgroupcreated',\n};\n\n/**\n * @params options - are an optional set of options associated with the first\n * sync group declared.\n */\nexport type SyncCreator = (id: string, options?: Record<string, unknown>) => Synchronizer;\n\nexport type SyncGroup = {\n  type: string;\n  id?: string;\n  // Source and target default to true if not specified\n  source?: boolean;\n  target?: boolean;\n  options?: Record<string, unknown>;\n};\n\nconst POSITION = 'cameraposition';\nconst VOI = 'voi';\nconst ZOOMPAN = 'zoompan';\nconst STACKIMAGE = 'stackimage';\n\nconst asSyncGroup = (syncGroup: string | SyncGroup): SyncGroup =>\n  typeof syncGroup === 'string' ? { type: syncGroup } : syncGroup;\n\nexport default class SyncGroupService {\n  static REGISTRATION = {\n    name: 'syncGroupService',\n    altName: 'SyncGroupService',\n    create: ({ servicesManager }: Types.Extensions.ExtensionParams): SyncGroupService => {\n      return new SyncGroupService(servicesManager);\n    },\n  };\n\n  servicesManager: ServicesManager;\n  listeners: { [key: string]: (...args: any[]) => void } = {};\n  EVENTS: { [key: string]: string };\n  synchronizerCreators: Record<string, SyncCreator> = {\n    [POSITION]: synchronizers.createCameraPositionSynchronizer,\n    [VOI]: synchronizers.createVOISynchronizer,\n    [ZOOMPAN]: synchronizers.createZoomPanSynchronizer,\n    [STACKIMAGE]: synchronizers.createStackImageSynchronizer,\n  };\n\n  constructor(serviceManager: ServicesManager) {\n    this.servicesManager = serviceManager;\n    this.listeners = {};\n    this.EVENTS = EVENTS;\n    //\n    Object.assign(this, pubSubServiceInterface);\n  }\n\n  private _createSynchronizer(type: string, id: string, options): Synchronizer | undefined {\n    const syncCreator = this.synchronizerCreators[type.toLowerCase()];\n    if (syncCreator) {\n      return syncCreator(id, options);\n    } else {\n      console.warn('Unknown synchronizer type', type, id);\n    }\n  }\n\n  /**\n   * Creates a synchronizer type.\n   * @param type is the type of the synchronizer to create\n   * @param creator\n   */\n  public addSynchronizerType(type: string, creator: SyncCreator): void {\n    this.synchronizerCreators[type.toLowerCase()] = creator;\n  }\n\n  protected _getOrCreateSynchronizer(\n    type: string,\n    id: string,\n    options: Record<string, unknown>\n  ): Synchronizer | undefined {\n    let synchronizer = SynchronizerManager.getSynchronizer(id);\n\n    if (!synchronizer) {\n      synchronizer = this._createSynchronizer(type, id, options);\n    }\n    return synchronizer;\n  }\n\n  public addViewportToSyncGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    syncGroups?: SyncGroup | string | SyncGroup[] | string[]\n  ): void {\n    if (!syncGroups) {\n      return;\n    }\n\n    const syncGroupsArray = Array.isArray(syncGroups) ? syncGroups : [syncGroups];\n\n    syncGroupsArray.forEach(syncGroup => {\n      const syncGroupObj = asSyncGroup(syncGroup);\n      const { type, target = true, source = true, options = {}, id = type } = syncGroupObj;\n\n      const synchronizer = this._getOrCreateSynchronizer(type, id, options);\n      synchronizer.setOptions(viewportId, options);\n\n      const viewportInfo = { viewportId, renderingEngineId };\n      if (target && source) {\n        synchronizer.add(viewportInfo);\n        return;\n      } else if (source) {\n        synchronizer.addSource(viewportInfo);\n      } else if (target) {\n        synchronizer.addTarget(viewportInfo);\n      }\n    });\n  }\n\n  public destroy(): void {\n    SynchronizerManager.destroy();\n  }\n\n  public removeViewportFromSyncGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    syncGroupId?: string\n  ): void {\n    const synchronizers = SynchronizerManager.getAllSynchronizers();\n\n    const filteredSynchronizers = syncGroupId\n      ? synchronizers.filter(s => s.id === syncGroupId)\n      : synchronizers;\n\n    filteredSynchronizers.forEach(synchronizer => {\n      if (!synchronizer) {\n        return;\n      }\n\n      synchronizer.remove({\n        viewportId,\n        renderingEngineId,\n      });\n\n      // check if any viewport is left in any of the sync groups, if not, delete that sync group\n      const sourceViewports = synchronizer.getSourceViewports();\n      const targetViewports = synchronizer.getTargetViewports();\n\n      if (!sourceViewports.length && !targetViewports.length) {\n        SynchronizerManager.destroySynchronizer(synchronizer.id);\n      }\n    });\n  }\n}\n","import SyncGroupService from './SyncGroupService';\n\nexport default SyncGroupService;\n","/**\n * It is a bell curved function that uses ease in out quadratic for css\n * transition timing function for each side of the curve.\n *\n * @param {number} x - The current time, in the range [0, 1].\n * @param {number} baseline - The baseline value to start from and return to.\n * @returns the value of the transition at time x.\n */\nexport function easeInOutBell(x: number, baseline: number): number {\n  const alpha = 1 - baseline;\n\n  // prettier-ignore\n  if (x < 1 / 4) {\n    return  4 * Math.pow(2 * x, 3) * alpha + baseline;\n  } else if (x < 1 / 2) {\n    return (1 - Math.pow(-4 * x + 2, 3) / 2) * alpha + baseline;\n  } else if (x < 3 / 4) {\n    return (1 - Math.pow(4 * x - 2, 3) / 2) * alpha + baseline;\n  } else {\n    return (- 4 * Math.pow(2 * x - 2, 3)) * alpha + baseline;\n  }\n}\n\n/**\n * A reversed bell curved function that starts from 1 and goes to baseline and\n * come back to 1 again. It uses ease in out quadratic for css transition\n * timing function for each side of the curve.\n *\n * @param {number} x - The current time, in the range [0, 1].\n * @param {number} baseline - The baseline value to start from and return to.\n * @returns the value of the transition at time x.\n */\nexport function reverseEaseInOutBell(x: number, baseline: number): number {\n  const y = easeInOutBell(x, baseline);\n  return -y + 1 + baseline;\n}\n","import cloneDeep from 'lodash.clonedeep';\n\nimport { Types as OhifTypes, ServicesManager, PubSubService } from '@ohif/core';\nimport {\n  cache,\n  Enums as csEnums,\n  geometryLoader,\n  eventTarget,\n  getEnabledElementByIds,\n  metaData,\n  utilities as csUtils,\n  volumeLoader,\n} from '@cornerstonejs/core';\nimport {\n  CONSTANTS as cstConstants,\n  Enums as csToolsEnums,\n  segmentation as cstSegmentation,\n  Types as cstTypes,\n  utilities as cstUtils,\n} from '@cornerstonejs/tools';\nimport isEqual from 'lodash.isequal';\nimport { Types as ohifTypes } from '@ohif/core';\nimport { easeInOutBell, reverseEaseInOutBell } from '../../utils/transitions';\nimport { Segment, Segmentation, SegmentationConfig } from './SegmentationServiceTypes';\nimport { mapROIContoursToRTStructData } from './RTSTRUCT/mapROIContoursToRTStructData';\n\nconst { COLOR_LUT } = cstConstants;\nconst LABELMAP = csToolsEnums.SegmentationRepresentations.Labelmap;\nconst CONTOUR = csToolsEnums.SegmentationRepresentations.Contour;\n\nconst EVENTS = {\n  // fired when the segmentation is updated (e.g. when a segment is added, removed, or modified, locked, visibility changed etc.)\n  SEGMENTATION_UPDATED: 'event::segmentation_updated',\n  // fired when the segmentation data (e.g., labelmap pixels) is modified\n  SEGMENTATION_DATA_MODIFIED: 'event::segmentation_data_modified',\n  // fired when the segmentation is added to the cornerstone\n  SEGMENTATION_ADDED: 'event::segmentation_added',\n  // fired when the segmentation is removed\n  SEGMENTATION_REMOVED: 'event::segmentation_removed',\n  // fired when the configuration for the segmentation is changed (e.g., brush size, render fill, outline thickness, etc.)\n  SEGMENTATION_CONFIGURATION_CHANGED: 'event::segmentation_configuration_changed',\n  // fired when the active segment is loaded in SEG or RTSTRUCT\n  SEGMENT_LOADING_COMPLETE: 'event::segment_loading_complete',\n  // for all segments\n  SEGMENTATION_LOADING_COMPLETE: 'event::segmentation_loading_complete',\n};\n\nconst VALUE_TYPES = {};\n\nconst SEGMENT_CONSTANT = {\n  opacity: 255,\n  isVisible: true,\n  isLocked: false,\n};\n\nconst VOLUME_LOADER_SCHEME = 'cornerstoneStreamingImageVolume';\n\nclass SegmentationService extends PubSubService {\n  static REGISTRATION = {\n    name: 'segmentationService',\n    altName: 'SegmentationService',\n    create: ({ servicesManager }: OhifTypes.Extensions.ExtensionParams): SegmentationService => {\n      return new SegmentationService({ servicesManager });\n    },\n  };\n\n  segmentations: Record<string, Segmentation>;\n  readonly servicesManager: ServicesManager;\n  highlightIntervalId = null;\n  readonly EVENTS = EVENTS;\n\n  constructor({ servicesManager }) {\n    super(EVENTS);\n    this.segmentations = {};\n\n    this.servicesManager = servicesManager;\n\n    this._initSegmentationService();\n  }\n\n  public destroy = () => {\n    eventTarget.removeEventListener(\n      csToolsEnums.Events.SEGMENTATION_MODIFIED,\n      this._onSegmentationModifiedFromSource\n    );\n\n    eventTarget.removeEventListener(\n      csToolsEnums.Events.SEGMENTATION_DATA_MODIFIED,\n      this._onSegmentationDataModified\n    );\n\n    // remove the segmentations from the cornerstone\n    Object.keys(this.segmentations).forEach(segmentationId => {\n      this._removeSegmentationFromCornerstone(segmentationId);\n    });\n\n    this.segmentations = {};\n    this.listeners = {};\n  };\n\n  /**\n   * Adds a new segment to the specified segmentation.\n   * @param segmentationId - The ID of the segmentation to add the segment to.\n   * @param config - An object containing the configuration options for the new segment.\n   *   - segmentIndex: (optional) The index of the segment to add. If not provided, the next available index will be used.\n   *   - toolGroupId: (optional) The ID of the tool group to associate the new segment with. If not provided, the first available tool group will be used.\n   *   - properties: (optional) An object containing the properties of the new segment.\n   *     - label: (optional) The label of the new segment. If not provided, a default label will be used.\n   *     - color: (optional) The color of the new segment in RGB format. If not provided, a default color will be used.\n   *     - opacity: (optional) The opacity of the new segment. If not provided, a default opacity will be used.\n   *     - visibility: (optional) Whether the new segment should be visible. If not provided, the segment will be visible by default.\n   *     - isLocked: (optional) Whether the new segment should be locked for editing. If not provided, the segment will not be locked by default.\n   *     - active: (optional) Whether the new segment should be the active segment to be edited. If not provided, the segment will not be active by default.\n   */\n  public addSegment(\n    segmentationId: string,\n    config: {\n      segmentIndex?: number;\n      toolGroupId?: string;\n      properties?: {\n        label?: string;\n        color?: ohifTypes.RGB;\n        opacity?: number;\n        visibility?: boolean;\n        isLocked?: boolean;\n        active?: boolean;\n      };\n    } = {}\n  ): void {\n    if (config?.segmentIndex === 0) {\n      throw new Error('Segment index 0 is reserved for \"no label\"');\n    }\n\n    const toolGroupId = config.toolGroupId ?? this._getFirstToolGroupId();\n\n    const { segmentationRepresentationUID, segmentation } = this._getSegmentationInfo(\n      segmentationId,\n      toolGroupId\n    );\n\n    let segmentIndex = config.segmentIndex;\n    if (!segmentIndex) {\n      // grab the next available segment index\n      segmentIndex = segmentation.segments.length === 0 ? 1 : segmentation.segments.length;\n    }\n\n    if (this._getSegmentInfo(segmentation, segmentIndex)) {\n      throw new Error(`Segment ${segmentIndex} already exists`);\n    }\n\n    const rgbaColor = cstSegmentation.config.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    segmentation.segments[segmentIndex] = {\n      label: config.properties?.label ?? `Segment ${segmentIndex}`,\n      segmentIndex: segmentIndex,\n      color: [rgbaColor[0], rgbaColor[1], rgbaColor[2]],\n      opacity: rgbaColor[3],\n      isVisible: true,\n      isLocked: false,\n    };\n\n    segmentation.segmentCount++;\n\n    // make the newly added segment the active segment\n    this._setActiveSegment(segmentationId, segmentIndex);\n\n    const suppressEvents = true;\n    if (config.properties !== undefined) {\n      const { color: newColor, opacity, isLocked, visibility, active } = config.properties;\n\n      if (newColor !== undefined) {\n        this._setSegmentColor(segmentationId, segmentIndex, newColor, toolGroupId, suppressEvents);\n      }\n\n      if (opacity !== undefined) {\n        this._setSegmentOpacity(segmentationId, segmentIndex, opacity, toolGroupId, suppressEvents);\n      }\n\n      if (visibility !== undefined) {\n        this._setSegmentVisibility(\n          segmentationId,\n          segmentIndex,\n          visibility,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (active !== undefined) {\n        this._setActiveSegment(segmentationId, segmentIndex, suppressEvents);\n      }\n\n      if (isLocked !== undefined) {\n        this._setSegmentLocked(segmentationId, segmentIndex, isLocked, suppressEvents);\n      }\n    }\n\n    if (segmentation.activeSegmentIndex === null) {\n      this._setActiveSegment(segmentationId, segmentIndex, suppressEvents);\n    }\n\n    // Todo: this includes non-hydrated segmentations which might not be\n    // persisted in the store\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  }\n\n  public removeSegment(segmentationId: string, segmentIndex: number): void {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    if (segmentIndex === 0) {\n      throw new Error('Segment index 0 is reserved for \"no label\"');\n    }\n\n    if (!this._getSegmentInfo(segmentation, segmentIndex)) {\n      return;\n    }\n\n    segmentation.segmentCount--;\n\n    segmentation.segments[segmentIndex] = null;\n\n    // Get volume and delete the labels\n    // Todo: handle other segmentations other than labelmap\n    const labelmapVolume = this.getLabelmapVolume(segmentationId);\n\n    const { dimensions } = labelmapVolume;\n    const scalarData = labelmapVolume.getScalarData();\n\n    // Set all values of this segment to zero and get which frames have been edited.\n    const frameLength = dimensions[0] * dimensions[1];\n    const numFrames = dimensions[2];\n\n    let voxelIndex = 0;\n\n    const modifiedFrames = new Set() as Set<number>;\n\n    for (let frame = 0; frame < numFrames; frame++) {\n      for (let p = 0; p < frameLength; p++) {\n        if (scalarData[voxelIndex] === segmentIndex) {\n          scalarData[voxelIndex] = 0;\n          modifiedFrames.add(frame);\n        }\n\n        voxelIndex++;\n      }\n    }\n\n    const modifiedFramesArray: number[] = Array.from(modifiedFrames);\n\n    // Trigger texture update of modified segmentation frames.\n    cstSegmentation.triggerSegmentationEvents.triggerSegmentationDataModified(\n      segmentationId,\n      modifiedFramesArray\n    );\n\n    if (segmentation.activeSegmentIndex === segmentIndex) {\n      const segmentIndices = Object.keys(segmentation.segments);\n\n      const newActiveSegmentIndex = segmentIndices.length ? Number(segmentIndices[0]) : 1;\n\n      this._setActiveSegment(segmentationId, newActiveSegmentIndex, true);\n    }\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  }\n\n  public setSegmentVisibility(\n    segmentationId: string,\n    segmentIndex: number,\n    isVisible: boolean,\n    toolGroupId?: string,\n    suppressEvents = false\n  ): void {\n    this._setSegmentVisibility(\n      segmentationId,\n      segmentIndex,\n      isVisible,\n      toolGroupId,\n      suppressEvents\n    );\n  }\n\n  public setSegmentLocked(segmentationId: string, segmentIndex: number, isLocked: boolean): void {\n    const suppressEvents = false;\n    this._setSegmentLocked(segmentationId, segmentIndex, isLocked, suppressEvents);\n  }\n\n  /**\n   * Toggles the locked state of a segment in a segmentation.\n   * @param segmentationId - The ID of the segmentation.\n   * @param segmentIndex - The index of the segment to toggle.\n   */\n  public toggleSegmentLocked(segmentationId: string, segmentIndex: number): void {\n    const segmentation = this.getSegmentation(segmentationId);\n    const segment = this._getSegmentInfo(segmentation, segmentIndex);\n    const isLocked = !segment.isLocked;\n    this._setSegmentLocked(segmentationId, segmentIndex, isLocked);\n  }\n\n  public setSegmentColor(\n    segmentationId: string,\n    segmentIndex: number,\n    color: ohifTypes.RGB,\n    toolGroupId?: string\n  ): void {\n    this._setSegmentColor(segmentationId, segmentIndex, color, toolGroupId);\n  }\n\n  public setSegmentRGBA = (\n    segmentationId: string,\n    segmentIndex: number,\n    rgbaColor: cstTypes.Color,\n    toolGroupId?: string\n  ): void => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const suppressEvents = true;\n    this._setSegmentOpacity(\n      segmentationId,\n      segmentIndex,\n      rgbaColor[3],\n      toolGroupId,\n      suppressEvents\n    );\n\n    this._setSegmentColor(\n      segmentationId,\n      segmentIndex,\n      [rgbaColor[0], rgbaColor[1], rgbaColor[2]],\n      toolGroupId,\n      suppressEvents\n    );\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  };\n\n  public setSegmentOpacity(\n    segmentationId: string,\n    segmentIndex: number,\n    opacity: number,\n    toolGroupId?: string\n  ): void {\n    this._setSegmentOpacity(segmentationId, segmentIndex, opacity, toolGroupId);\n  }\n\n  public setActiveSegmentationForToolGroup(segmentationId: string, toolGroupId?: string): void {\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const suppressEvents = false;\n    this._setActiveSegmentationForToolGroup(segmentationId, toolGroupId, suppressEvents);\n  }\n\n  public setActiveSegment(segmentationId: string, segmentIndex: number): void {\n    this._setActiveSegment(segmentationId, segmentIndex, false);\n  }\n\n  /**\n   * Get all segmentations.\n   *\n   * * @param filterNonHydratedSegmentations - If true, only return hydrated segmentations\n   * hydrated segmentations are those that have been loaded and persisted\n   * in the state, but non hydrated segmentations are those that are\n   * only created for the SEG displayset (SEG viewport) and the user might not\n   * have loaded them yet fully.\n   *\n\n   * @return Array of segmentations\n   */\n  public getSegmentations(filterNonHydratedSegmentations = true): Segmentation[] {\n    const segmentations = this._getSegmentations();\n\n    return (\n      segmentations &&\n      segmentations.filter(segmentation => {\n        return !filterNonHydratedSegmentations || segmentation.hydrated;\n      })\n    );\n  }\n\n  private _getSegmentations(): Segmentation[] {\n    const segmentations = this.arrayOfObjects(this.segmentations);\n    return segmentations && segmentations.map(m => this.segmentations[Object.keys(m)[0]]);\n  }\n\n  /**\n   * Get specific segmentation by its id.\n   *\n   * @param segmentationId If of the segmentation\n   * @return segmentation instance\n   */\n  public getSegmentation(segmentationId: string): Segmentation {\n    return this.segmentations[segmentationId];\n  }\n\n  public addOrUpdateSegmentation(\n    segmentation: Segmentation,\n    suppressEvents = false,\n    notYetUpdatedAtSource = false\n  ): string {\n    const { id: segmentationId } = segmentation;\n    let cachedSegmentation = this.segmentations[segmentationId];\n    if (cachedSegmentation) {\n      // Update the segmentation (mostly for assigning metadata/labels)\n      Object.assign(cachedSegmentation, segmentation);\n\n      this._updateCornerstoneSegmentations({\n        segmentationId,\n        notYetUpdatedAtSource,\n      });\n\n      if (!suppressEvents) {\n        this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n          segmentation: cachedSegmentation,\n        });\n      }\n\n      return segmentationId;\n    }\n\n    const representationType = segmentation.type;\n    const representationData = segmentation.representationData[representationType];\n    cstSegmentation.addSegmentations([\n      {\n        segmentationId,\n        representation: {\n          type: representationType,\n          data: {\n            ...representationData,\n          },\n        },\n      },\n    ]);\n\n    // if first segmentation, we can use the default colorLUT, otherwise\n    // we need to generate a new one and use a new colorLUT\n    const colorLUTIndex = 0;\n    if (Object.keys(this.segmentations).length !== 0) {\n      const newColorLUT = this.generateNewColorLUT();\n      const colorLUTIndex = this.getNextColorLUTIndex();\n      cstSegmentation.config.color.addColorLUT(newColorLUT, colorLUTIndex);\n    }\n\n    this.segmentations[segmentationId] = {\n      ...segmentation,\n      label: segmentation.label || '',\n      segments: segmentation.segments || [null],\n      activeSegmentIndex: segmentation.activeSegmentIndex ?? null,\n      segmentCount: segmentation.segmentCount ?? 0,\n      isActive: false,\n      isVisible: true,\n      colorLUTIndex,\n    };\n\n    cachedSegmentation = this.segmentations[segmentationId];\n\n    this._updateCornerstoneSegmentations({\n      segmentationId,\n      notYetUpdatedAtSource: true,\n    });\n\n    if (!suppressEvents) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_ADDED, {\n        segmentation: cachedSegmentation,\n      });\n    }\n\n    return cachedSegmentation.id;\n  }\n\n  public async createSegmentationForSEGDisplaySet(\n    segDisplaySet,\n    segmentationId?: string,\n    suppressEvents = false\n  ): Promise<string> {\n    // Todo: we only support creating labelmap for SEG displaySets for now\n    const representationType = LABELMAP;\n\n    segmentationId = segmentationId ?? segDisplaySet.displaySetInstanceUID;\n\n    const defaultScheme = this._getDefaultSegmentationScheme();\n\n    const segmentation: Segmentation = {\n      ...defaultScheme,\n      id: segmentationId,\n      displaySetInstanceUID: segDisplaySet.displaySetInstanceUID,\n      type: representationType,\n      label: segDisplaySet.SeriesDescription,\n      representationData: {\n        [LABELMAP]: {\n          volumeId: segmentationId,\n          referencedVolumeId: segDisplaySet.referencedVolumeId,\n        },\n      },\n    };\n\n    const labelmap = this.getLabelmapVolume(segmentationId);\n    const cachedSegmentation = this.getSegmentation(segmentationId);\n    if (labelmap && cachedSegmentation) {\n      // if the labelmap with the same segmentationId already exists, we can\n      // just assume that the segmentation is already created and move on with\n      // updating the state\n      return this.addOrUpdateSegmentation(\n        Object.assign(segmentation, cachedSegmentation),\n        suppressEvents\n      );\n    }\n\n    const { labelmapBufferArray, referencedVolumeId } = segDisplaySet;\n\n    if (!labelmapBufferArray || !referencedVolumeId) {\n      throw new Error('No labelmapBufferArray or referencedVolumeId found for the SEG displaySet');\n    }\n\n    // if the labelmap doesn't exist, we need to create it first from the\n    // DICOM SEG displaySet data\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n\n    if (!referencedVolume) {\n      throw new Error(`No volume found for referencedVolumeId: ${referencedVolumeId}`);\n    }\n\n    // Force use of a Uint8Array SharedArrayBuffer for the segmentation to save space and so\n    // it is easily compressible in worker thread.\n    const derivedVolume = await volumeLoader.createAndCacheDerivedVolume(referencedVolumeId, {\n      volumeId: segmentationId,\n      targetBuffer: {\n        type: 'Uint8Array',\n        sharedArrayBuffer: true,\n      },\n    });\n    const derivedVolumeScalarData = derivedVolume.getScalarData();\n\n    const segmentsInfo = segDisplaySet.segMetadata.data;\n    derivedVolumeScalarData.set(new Uint8Array(labelmapBufferArray[0]));\n\n    segmentation.segments = segmentsInfo.map((segmentInfo, segmentIndex) => {\n      if (segmentIndex === 0) {\n        return;\n      }\n\n      const {\n        SegmentedPropertyCategoryCodeSequence,\n        SegmentNumber,\n        SegmentLabel,\n        SegmentAlgorithmType,\n        SegmentAlgorithmName,\n        SegmentedPropertyTypeCodeSequence,\n        rgba,\n      } = segmentInfo;\n\n      const { x, y, z } = segDisplaySet.centroids.get(segmentIndex);\n      const centerWorld = derivedVolume.imageData.indexToWorld([x, y, z]);\n\n      segmentation.cachedStats = {\n        ...segmentation.cachedStats,\n        segmentCenter: {\n          ...segmentation.cachedStats.segmentCenter,\n          [segmentIndex]: {\n            center: {\n              image: [x, y, z],\n              world: centerWorld,\n            },\n            modifiedTime: segDisplaySet.SeriesDate,\n          },\n        },\n      };\n\n      return {\n        label: SegmentLabel || `Segment ${SegmentNumber}`,\n        segmentIndex: Number(SegmentNumber),\n        category: SegmentedPropertyCategoryCodeSequence\n          ? SegmentedPropertyCategoryCodeSequence.CodeMeaning\n          : '',\n        type: SegmentedPropertyTypeCodeSequence\n          ? SegmentedPropertyTypeCodeSequence.CodeMeaning\n          : '',\n        algorithmType: SegmentAlgorithmType,\n        algorithmName: SegmentAlgorithmName,\n        color: rgba,\n        opacity: 255,\n        isVisible: true,\n        isLocked: false,\n      };\n    });\n\n    segmentation.segmentCount = segmentsInfo.length - 1;\n\n    segDisplaySet.isLoaded = true;\n\n    this._broadcastEvent(EVENTS.SEGMENTATION_LOADING_COMPLETE, {\n      segmentationId,\n      segDisplaySet,\n    });\n\n    return this.addOrUpdateSegmentation(segmentation, suppressEvents);\n  }\n\n  public async createSegmentationForRTDisplaySet(\n    rtDisplaySet,\n    segmentationId?: string,\n    suppressEvents = false\n  ): Promise<string> {\n    // Todo: we currently only have support for contour representation for initial\n    // RT display\n    const representationType = CONTOUR;\n    segmentationId = segmentationId ?? rtDisplaySet.displaySetInstanceUID;\n    const { structureSet } = rtDisplaySet;\n\n    if (!structureSet) {\n      throw new Error(\n        'To create the contours from RT displaySet, the displaySet should be loaded first, you can perform rtDisplaySet.load() before calling this method.'\n      );\n    }\n\n    const defaultScheme = this._getDefaultSegmentationScheme();\n    const rtDisplaySetUID = rtDisplaySet.displaySetInstanceUID;\n\n    const allRTStructData = mapROIContoursToRTStructData(structureSet, rtDisplaySetUID);\n\n    // sort by segmentIndex\n    allRTStructData.sort((a, b) => a.segmentIndex - b.segmentIndex);\n\n    const geometryIds = allRTStructData.map(({ geometryId }) => geometryId);\n\n    const segmentation: Segmentation = {\n      ...defaultScheme,\n      id: segmentationId,\n      displaySetInstanceUID: rtDisplaySetUID,\n      type: representationType,\n      label: rtDisplaySet.SeriesDescription,\n      representationData: {\n        [CONTOUR]: {\n          geometryIds,\n        },\n      },\n    };\n\n    const cachedSegmentation = this.getSegmentation(segmentationId);\n\n    if (cachedSegmentation) {\n      // if the labelmap with the same segmentationId already exists, we can\n      // just assume that the segmentation is already created and move on with\n      // updating the state\n      return this.addOrUpdateSegmentation(\n        Object.assign(segmentation, cachedSegmentation),\n        suppressEvents\n      );\n    }\n\n    if (!structureSet.ROIContours?.length) {\n      throw new Error(\n        'The structureSet does not contain any ROIContours. Please ensure the structureSet is loaded first.'\n      );\n    }\n    const segmentsCachedStats = {};\n    const initializeContour = async rtStructData => {\n      const { data, id, color, segmentIndex, geometryId } = rtStructData;\n\n      // catch error instead of failing to allow loading to continue\n      try {\n        const geometry = await geometryLoader.createAndCacheGeometry(geometryId, {\n          geometryData: {\n            data,\n            id,\n            color,\n            frameOfReferenceUID: structureSet.frameOfReferenceUID,\n            segmentIndex,\n          },\n          type: csEnums.GeometryType.CONTOUR,\n        });\n\n        const contourSet = geometry.data;\n        const centroid = contourSet.getCentroid();\n\n        segmentsCachedStats[segmentIndex] = {\n          center: { world: centroid },\n          modifiedTime: rtDisplaySet.SeriesDate, // we use the SeriesDate as the modifiedTime since this is the first time we are creating the segmentation\n        };\n\n        segmentation.segments[segmentIndex] = {\n          label: id,\n          segmentIndex,\n          color,\n          ...SEGMENT_CONSTANT,\n        };\n\n        const numInitialized = Object.keys(segmentsCachedStats).length;\n\n        // Calculate percentage completed\n        const percentComplete = Math.round((numInitialized / allRTStructData.length) * 100);\n\n        this._broadcastEvent(EVENTS.SEGMENT_LOADING_COMPLETE, {\n          percentComplete,\n          // Note: this is not the geometryIds length since there might be\n          // some missing ROINumbers\n          numSegments: allRTStructData.length,\n        });\n      } catch (e) {\n        console.warn(e);\n      }\n    };\n\n    const promiseArray = [];\n\n    for (let i = 0; i < allRTStructData.length; i++) {\n      const promise = new Promise<void>((resolve, reject) => {\n        setTimeout(() => {\n          initializeContour(allRTStructData[i]).then(() => {\n            resolve();\n          });\n        }, 0);\n      });\n\n      promiseArray.push(promise);\n    }\n\n    await Promise.all(promiseArray);\n\n    segmentation.segmentCount = allRTStructData.length;\n    rtDisplaySet.isLoaded = true;\n\n    segmentation.cachedStats = {\n      ...segmentation.cachedStats,\n      segmentCenter: {\n        ...segmentation.cachedStats.segmentCenter,\n        ...segmentsCachedStats,\n      },\n    };\n\n    this._broadcastEvent(EVENTS.SEGMENTATION_LOADING_COMPLETE, {\n      segmentationId,\n      rtDisplaySet,\n    });\n\n    return this.addOrUpdateSegmentation(segmentation, suppressEvents);\n  }\n\n  // Todo: this should not run on the main thread\n  public calculateCentroids = (\n    segmentationId: string,\n    segmentIndex?: number\n  ): Map<number, { x: number; y: number; z: number; world: number[] }> => {\n    const segmentation = this.getSegmentation(segmentationId);\n    const volume = this.getLabelmapVolume(segmentationId);\n    const { dimensions, imageData } = volume;\n    const scalarData = volume.getScalarData();\n    const [dimX, dimY, numFrames] = dimensions;\n    const frameLength = dimX * dimY;\n\n    const segmentIndices = segmentIndex\n      ? [segmentIndex]\n      : segmentation.segments\n          .filter(segment => segment?.segmentIndex)\n          .map(segment => segment.segmentIndex);\n\n    const segmentIndicesSet = new Set(segmentIndices);\n\n    const centroids = new Map();\n    for (const index of segmentIndicesSet) {\n      centroids.set(index, { x: 0, y: 0, z: 0, count: 0 });\n    }\n\n    let voxelIndex = 0;\n    for (let frame = 0; frame < numFrames; frame++) {\n      for (let p = 0; p < frameLength; p++) {\n        const segmentIndex = scalarData[voxelIndex++];\n        if (segmentIndicesSet.has(segmentIndex)) {\n          const centroid = centroids.get(segmentIndex);\n          centroid.x += p % dimX;\n          centroid.y += (p / dimX) | 0;\n          centroid.z += frame;\n          centroid.count++;\n        }\n      }\n    }\n\n    const result = new Map();\n    for (const [index, centroid] of centroids) {\n      const count = centroid.count;\n      const normalizedCentroid = {\n        x: centroid.x / count,\n        y: centroid.y / count,\n        z: centroid.z / count,\n      };\n      normalizedCentroid.world = imageData.indexToWorld([\n        normalizedCentroid.x,\n        normalizedCentroid.y,\n        normalizedCentroid.z,\n      ]);\n      result.set(index, normalizedCentroid);\n    }\n\n    this.setCentroids(segmentationId, result);\n    return result;\n  };\n\n  private setCentroids = (\n    segmentationId: string,\n    centroids: Map<number, { image: number[]; world?: number[] }>\n  ): void => {\n    const segmentation = this.getSegmentation(segmentationId);\n    const imageData = this.getLabelmapVolume(segmentationId).imageData; // Assuming this method returns imageData\n\n    if (!segmentation.cachedStats) {\n      segmentation.cachedStats = { segmentCenter: {} };\n    } else if (!segmentation.cachedStats.segmentCenter) {\n      segmentation.cachedStats.segmentCenter = {};\n    }\n\n    for (const [segmentIndex, centroid] of centroids) {\n      let world = centroid.world;\n\n      // If world coordinates are not provided, calculate them\n      if (!world || world.length === 0) {\n        world = imageData.indexToWorld(centroid.image);\n      }\n\n      segmentation.cachedStats.segmentCenter[segmentIndex] = {\n        center: {\n          image: centroid.image,\n          world: world,\n        },\n      };\n    }\n\n    this.addOrUpdateSegmentation(segmentation, true, true);\n  };\n\n  public jumpToSegmentCenter(\n    segmentationId: string,\n    segmentIndex: number,\n    toolGroupId?: string,\n    highlightAlpha = 0.9,\n    highlightSegment = true,\n    animationLength = 750,\n    highlightHideOthers = false,\n    highlightFunctionType = 'ease-in-out' // todo: make animation functions configurable from outside\n  ): void {\n    const { toolGroupService } = this.servicesManager.services;\n    const center = this._getSegmentCenter(segmentationId, segmentIndex);\n\n    if (!center?.world) {\n      return;\n    }\n\n    const { world } = center;\n\n    // todo: generalize\n    toolGroupId = toolGroupId || this._getToolGroupIdsWithSegmentation(segmentationId);\n\n    const toolGroups = [];\n\n    if (Array.isArray(toolGroupId)) {\n      toolGroupId.forEach(toolGroup => {\n        toolGroups.push(toolGroupService.getToolGroup(toolGroup));\n      });\n    } else {\n      toolGroups.push(toolGroupService.getToolGroup(toolGroupId));\n    }\n\n    toolGroups.forEach(toolGroup => {\n      const viewportsInfo = toolGroup.getViewportsInfo();\n\n      // @ts-ignore\n      for (const { viewportId, renderingEngineId } of viewportsInfo) {\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        cstUtils.viewport.jumpToWorld(viewport, world);\n      }\n\n      if (highlightSegment) {\n        this.highlightSegment(\n          segmentationId,\n          segmentIndex,\n          toolGroup.id,\n          highlightAlpha,\n          animationLength,\n          highlightHideOthers,\n          highlightFunctionType\n        );\n      }\n    });\n  }\n\n  public highlightSegment(\n    segmentationId: string,\n    segmentIndex: number,\n    toolGroupId?: string,\n    alpha = 0.9,\n    animationLength = 750,\n    hideOthers = true,\n    highlightFunctionType = 'ease-in-out'\n  ): void {\n    if (this.highlightIntervalId) {\n      clearInterval(this.highlightIntervalId);\n    }\n\n    const segmentation = this.getSegmentation(segmentationId);\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    const { type } = segmentationRepresentation;\n    const { segments } = segmentation;\n\n    const highlightFn =\n      type === LABELMAP ? this._highlightLabelmap.bind(this) : this._highlightContour.bind(this);\n\n    const adjustedAlpha = type === LABELMAP ? alpha : 1 - alpha;\n\n    highlightFn(\n      segmentIndex,\n      adjustedAlpha,\n      hideOthers,\n      segments,\n      toolGroupId,\n      animationLength,\n      segmentationRepresentation\n    );\n  }\n\n  public createSegmentationForDisplaySet = async (\n    displaySetInstanceUID: string,\n    options?: {\n      segmentationId: string;\n      FrameOfReferenceUID: string;\n      label: string;\n    }\n  ): Promise<string> => {\n    const { displaySetService } = this.servicesManager.services;\n\n    const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n    // Todo: we currently only support labelmap for segmentation for a displaySet\n    const representationType = LABELMAP;\n\n    const volumeId = this._getVolumeIdForDisplaySet(displaySet);\n\n    const segmentationId = options?.segmentationId ?? `${csUtils.uuidv4()}`;\n\n    // Force use of a Uint8Array SharedArrayBuffer for the segmentation to save space and so\n    // it is easily compressible in worker thread.\n    await volumeLoader.createAndCacheDerivedVolume(volumeId, {\n      volumeId: segmentationId,\n      targetBuffer: {\n        type: 'Uint8Array',\n        sharedArrayBuffer: true,\n      },\n    });\n\n    const defaultScheme = this._getDefaultSegmentationScheme();\n\n    const segmentation: Segmentation = {\n      ...defaultScheme,\n      id: segmentationId,\n      displaySetInstanceUID,\n      label: options?.label,\n      // We should set it as active by default, as it created for display\n      isActive: true,\n      type: representationType,\n      FrameOfReferenceUID:\n        options?.FrameOfReferenceUID || displaySet.instances?.[0]?.FrameOfReferenceUID,\n      representationData: {\n        LABELMAP: {\n          volumeId: segmentationId,\n          referencedVolumeId: volumeId, // Todo: this is so ugly\n        },\n      },\n    };\n\n    this.addOrUpdateSegmentation(segmentation);\n\n    return segmentationId;\n  };\n\n  /**\n   * Toggles the visibility of a segmentation in the state, and broadcasts the event.\n   * Note: this method does not update the segmentation state in the source. It only\n   * updates the state, and there should be separate listeners for that.\n   * @param ids segmentation ids\n   */\n  public toggleSegmentationVisibility = (segmentationId: string): void => {\n    this._toggleSegmentationVisibility(segmentationId, false);\n  };\n\n  public addSegmentationRepresentationToToolGroup = async (\n    toolGroupId: string,\n    segmentationId: string,\n    hydrateSegmentation = false,\n    representationType = csToolsEnums.SegmentationRepresentations.Labelmap,\n    suppressEvents = false\n  ): Promise<void> => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (!segmentation) {\n      throw new Error(`Segmentation with segmentationId ${segmentationId} not found.`);\n    }\n\n    if (hydrateSegmentation) {\n      // hydrate the segmentation if it's not hydrated yet\n      segmentation.hydrated = true;\n    }\n\n    const { colorLUTIndex } = segmentation;\n\n    // Based on the segmentationId, set the colorLUTIndex.\n    const segmentationRepresentationUIDs = await cstSegmentation.addSegmentationRepresentations(\n      toolGroupId,\n      [\n        {\n          segmentationId,\n          type: representationType,\n        },\n      ]\n    );\n\n    // set the latest segmentation representation as active one\n    this._setActiveSegmentationForToolGroup(\n      segmentationId,\n      toolGroupId,\n      segmentationRepresentationUIDs[0]\n    );\n\n    cstSegmentation.config.color.setColorLUT(\n      toolGroupId,\n      segmentationRepresentationUIDs[0],\n      colorLUTIndex\n    );\n\n    // add the segmentation segments properly\n    for (const segment of segmentation.segments) {\n      if (segment === null || segment === undefined) {\n        continue;\n      }\n\n      const { segmentIndex, color, isLocked, isVisible: visibility, opacity } = segment;\n\n      const suppressEvents = true;\n\n      if (color !== undefined) {\n        this._setSegmentColor(segmentationId, segmentIndex, color, toolGroupId, suppressEvents);\n      }\n\n      if (opacity !== undefined) {\n        this._setSegmentOpacity(segmentationId, segmentIndex, opacity, toolGroupId, suppressEvents);\n      }\n\n      if (visibility !== undefined) {\n        this._setSegmentVisibility(\n          segmentationId,\n          segmentIndex,\n          visibility,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (isLocked) {\n        this._setSegmentLocked(segmentationId, segmentIndex, isLocked, suppressEvents);\n      }\n    }\n\n    if (!suppressEvents) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  public setSegmentRGBAColor = (\n    segmentationId: string,\n    segmentIndex: number,\n    rgbaColor,\n    toolGroupId?: string\n  ) => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    this._setSegmentOpacity(\n      segmentationId,\n      segmentIndex,\n      rgbaColor[3],\n      toolGroupId, // toolGroupId\n      true\n    );\n    this._setSegmentColor(\n      segmentationId,\n      segmentIndex,\n      [rgbaColor[0], rgbaColor[1], rgbaColor[2]],\n      toolGroupId, // toolGroupId\n      true\n    );\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  };\n\n  public getToolGroupIdsWithSegmentation = (segmentationId: string): string[] => {\n    const toolGroupIds = cstSegmentation.state.getToolGroupIdsWithSegmentation(segmentationId);\n    return toolGroupIds;\n  };\n\n  public hydrateSegmentation = (segmentationId: string, suppressEvents = false): void => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (!segmentation) {\n      throw new Error(`Segmentation with segmentationId ${segmentationId} not found.`);\n    }\n    segmentation.hydrated = true;\n\n    // Not all segmentations have dipslaysets, some of them are derived in the client\n    this._setDisplaySetIsHydrated(segmentationId, true);\n\n    if (!suppressEvents) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _setDisplaySetIsHydrated(displaySetUID: string, isHydrated: boolean): void {\n    const { displaySetService } = this.servicesManager.services;\n    const displaySet = displaySetService.getDisplaySetByUID(displaySetUID);\n\n    if (!displaySet) {\n      return;\n    }\n\n    displaySet.isHydrated = isHydrated;\n    displaySetService.setDisplaySetMetadataInvalidated(displaySetUID, false);\n  }\n\n  private _highlightLabelmap(\n    segmentIndex: number,\n    alpha: number,\n    hideOthers: boolean,\n    segments: Segment[],\n    toolGroupId: string,\n    animationLength: number,\n    segmentationRepresentation: cstTypes.ToolGroupSpecificRepresentation\n  ) {\n    const newSegmentSpecificConfig = {\n      [segmentIndex]: {\n        LABELMAP: {\n          fillAlpha: alpha,\n        },\n      },\n    };\n\n    if (hideOthers) {\n      for (let i = 0; i < segments.length; i++) {\n        if (i !== segmentIndex) {\n          newSegmentSpecificConfig[i] = {\n            LABELMAP: {\n              fillAlpha: 0,\n            },\n          };\n        }\n      }\n    }\n\n    const { fillAlpha } = this.getConfiguration(toolGroupId);\n\n    let startTime: number = null;\n    const animation = (timestamp: number) => {\n      if (startTime === null) {\n        startTime = timestamp;\n      }\n\n      const elapsed = timestamp - startTime;\n      const progress = Math.min(elapsed / animationLength, 1);\n\n      cstSegmentation.config.setSegmentSpecificConfig(\n        toolGroupId,\n        segmentationRepresentation.segmentationRepresentationUID,\n        {\n          [segmentIndex]: {\n            LABELMAP: {\n              fillAlpha: easeInOutBell(progress, fillAlpha),\n            },\n          },\n        }\n      );\n\n      if (progress < 1) {\n        requestAnimationFrame(animation);\n      } else {\n        cstSegmentation.config.setSegmentSpecificConfig(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          {}\n        );\n      }\n    };\n\n    requestAnimationFrame(animation);\n  }\n\n  private _highlightContour(\n    segmentIndex: number,\n    alpha: number,\n    hideOthers: boolean,\n    segments: Segment[],\n    toolGroupId: string,\n    animationLength: number,\n    segmentationRepresentation: cstTypes.ToolGroupSpecificRepresentation\n  ) {\n    const startTime = performance.now();\n\n    const animate = (currentTime: number) => {\n      const progress = (currentTime - startTime) / animationLength;\n      if (progress >= 1) {\n        cstSegmentation.config.setSegmentSpecificConfig(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          {}\n        );\n        return;\n      }\n\n      const reversedProgress = reverseEaseInOutBell(progress, 0.1);\n      cstSegmentation.config.setSegmentSpecificConfig(\n        toolGroupId,\n        segmentationRepresentation.segmentationRepresentationUID,\n        {\n          [segmentIndex]: {\n            CONTOUR: {\n              fillAlpha: reversedProgress,\n            },\n          },\n        }\n      );\n\n      requestAnimationFrame(animate);\n    };\n\n    requestAnimationFrame(animate);\n  }\n\n  public removeSegmentationRepresentationFromToolGroup(\n    toolGroupId: string,\n    segmentationRepresentationUIDsIds?: string[]\n  ): void {\n    const uids = segmentationRepresentationUIDsIds || [];\n    if (!uids.length) {\n      const representations = cstSegmentation.state.getSegmentationRepresentations(toolGroupId);\n\n      if (!representations || !representations.length) {\n        return;\n      }\n\n      uids.push(...representations.map(rep => rep.segmentationRepresentationUID));\n    }\n\n    cstSegmentation.removeSegmentationsFromToolGroup(toolGroupId, uids);\n  }\n\n  /**\n   * Removes a segmentation and broadcasts the removed event.\n   *\n   * @param {string} segmentationId The segmentation id\n   */\n  public remove(segmentationId: string): void {\n    const segmentation = this.segmentations[segmentationId];\n    const wasActive = segmentation.isActive;\n\n    if (!segmentationId || !segmentation) {\n      console.warn(`No segmentationId provided, or unable to find segmentation by id.`);\n      return;\n    }\n\n    const { colorLUTIndex } = segmentation;\n    this._removeSegmentationFromCornerstone(segmentationId);\n\n    // Delete associated colormap\n    // Todo: bring this back\n    cstSegmentation.state.removeColorLUT(colorLUTIndex);\n\n    delete this.segmentations[segmentationId];\n\n    // If this segmentation was active, and there is another segmentation, set another one active.\n\n    if (wasActive) {\n      const remainingSegmentations = this._getSegmentations();\n\n      const remainingHydratedSegmentations = remainingSegmentations.filter(\n        segmentation => segmentation.hydrated\n      );\n\n      if (remainingHydratedSegmentations.length) {\n        const { id } = remainingHydratedSegmentations[0];\n\n        this._setActiveSegmentationForToolGroup(id, this._getFirstToolGroupId(), false);\n      }\n    }\n\n    this._setDisplaySetIsHydrated(segmentationId, false);\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_REMOVED, {\n      segmentationId,\n    });\n  }\n\n  public getConfiguration = (toolGroupId?: string): SegmentationConfig => {\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const brushSize = 1;\n    // const brushSize = cstUtils.segmentation.getBrushSizeForToolGroup(\n    //   toolGroupId\n    // );\n\n    const brushThresholdGate = 1;\n    // const brushThresholdGate = cstUtils.segmentation.getBrushThresholdForToolGroup(\n    //   toolGroupId\n    // );\n\n    const segmentationRepresentations =\n      this.getSegmentationRepresentationsForToolGroup(toolGroupId);\n\n    const typeToUse = segmentationRepresentations?.[0]?.type || LABELMAP;\n\n    const config = cstSegmentation.config.getGlobalConfig();\n    const { renderInactiveSegmentations } = config;\n\n    const representation = config.representations[typeToUse];\n\n    const {\n      renderOutline,\n      outlineWidthActive,\n      renderFill,\n      fillAlpha,\n      fillAlphaInactive,\n      outlineOpacity,\n      outlineOpacityInactive,\n    } = representation;\n\n    return {\n      brushSize,\n      brushThresholdGate,\n      fillAlpha,\n      fillAlphaInactive,\n      outlineWidthActive,\n      renderFill,\n      renderInactiveSegmentations,\n      renderOutline,\n      outlineOpacity,\n      outlineOpacityInactive,\n    };\n  };\n\n  public setConfiguration = (configuration: SegmentationConfig): void => {\n    const {\n      brushSize,\n      brushThresholdGate,\n      fillAlpha,\n      fillAlphaInactive,\n      outlineWidthActive,\n      outlineOpacity,\n      renderFill,\n      renderInactiveSegmentations,\n      renderOutline,\n    } = configuration;\n\n    const setConfigValueIfDefined = (key, value, transformFn = null) => {\n      if (value !== undefined) {\n        const transformedValue = transformFn ? transformFn(value) : value;\n        this._setSegmentationConfig(key, transformedValue);\n      }\n    };\n\n    setConfigValueIfDefined('renderOutline', renderOutline);\n    setConfigValueIfDefined('outlineWidthActive', outlineWidthActive);\n    setConfigValueIfDefined('outlineOpacity', outlineOpacity, v => v / 100);\n    setConfigValueIfDefined('fillAlpha', fillAlpha, v => v / 100);\n    setConfigValueIfDefined('renderFill', renderFill);\n    setConfigValueIfDefined('fillAlphaInactive', fillAlphaInactive, v => v / 100);\n    setConfigValueIfDefined('outlineOpacityInactive', fillAlphaInactive, v =>\n      Math.max(0.75, v / 100)\n    );\n\n    if (renderInactiveSegmentations !== undefined) {\n      const config = cstSegmentation.config.getGlobalConfig();\n      config.renderInactiveSegmentations = renderInactiveSegmentations;\n      cstSegmentation.config.setGlobalConfig(config);\n    }\n\n    // if (brushSize !== undefined) {\n    //   const { toolGroupService } = this.servicesManager.services;\n\n    //   const toolGroupIds = toolGroupService.getToolGroupIds();\n\n    //   toolGroupIds.forEach(toolGroupId => {\n    //     cstUtils.segmentation.setBrushSizeForToolGroup(toolGroupId, brushSize);\n    //   });\n    // }\n\n    // if (brushThresholdGate !== undefined) {\n    //   const { toolGroupService } = this.servicesManager.services;\n\n    //   const toolGroupIds = toolGroupService.getFirstToolGroupIds();\n\n    //   toolGroupIds.forEach(toolGroupId => {\n    //     cstUtils.segmentation.setBrushThresholdForToolGroup(\n    //       toolGroupId,\n    //       brushThresholdGate\n    //     );\n    //   });\n    // }\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_CONFIGURATION_CHANGED, this.getConfiguration());\n  };\n\n  public getLabelmapVolume = (segmentationId: string) => {\n    return cache.getVolume(segmentationId);\n  };\n\n  public getSegmentationRepresentationsForToolGroup = toolGroupId => {\n    return cstSegmentation.state.getSegmentationRepresentations(toolGroupId);\n  };\n\n  public setSegmentLabel(segmentationId: string, segmentIndex: number, label: string) {\n    this._setSegmentLabel(segmentationId, segmentIndex, label);\n  }\n\n  private _setSegmentLabel(\n    segmentationId: string,\n    segmentIndex: number,\n    label: string,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = segmentation.segments[segmentIndex];\n\n    if (segmentInfo === undefined) {\n      throw new Error(`Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`);\n    }\n\n    segmentInfo.label = label;\n\n    if (suppressEvents === false) {\n      // this._setSegmentationModified(segmentationId);\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  public shouldRenderSegmentation(viewportDisplaySetInstanceUIDs, segmentationFrameOfReferenceUID) {\n    if (!viewportDisplaySetInstanceUIDs?.length) {\n      return false;\n    }\n\n    const { displaySetService } = this.servicesManager.services;\n\n    let shouldDisplaySeg = false;\n\n    // check if the displaySet is sharing the same frameOfReferenceUID\n    // with the new segmentation\n    for (const displaySetInstanceUID of viewportDisplaySetInstanceUIDs) {\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n      // Todo: this might not be ideal for use cases such as 4D, since we\n      // don't want to show the segmentation for all the frames\n      if (\n        displaySet.isReconstructable &&\n        displaySet?.images?.[0]?.FrameOfReferenceUID === segmentationFrameOfReferenceUID\n      ) {\n        shouldDisplaySeg = true;\n        break;\n      }\n    }\n\n    return shouldDisplaySeg;\n  }\n\n  private _getDefaultSegmentationScheme() {\n    return {\n      activeSegmentIndex: 1,\n      cachedStats: {},\n      label: '',\n      segmentsLocked: [],\n      displayText: [],\n      hydrated: false, // by default we don't hydrate the segmentation for SEG displaySets\n      segmentCount: 0,\n      segments: [],\n      isVisible: true,\n      isActive: false,\n      colorLUTIndex: 0,\n    };\n  }\n\n  private _setActiveSegmentationForToolGroup(\n    segmentationId: string,\n    toolGroupId: string,\n    suppressEvents = false\n  ) {\n    const segmentations = this._getSegmentations();\n    const targetSegmentation = this.getSegmentation(segmentationId);\n\n    if (targetSegmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    segmentations.forEach(segmentation => {\n      segmentation.isActive = segmentation.id === segmentationId;\n    });\n\n    const representation = this._getSegmentationRepresentation(segmentationId, toolGroupId);\n\n    cstSegmentation.activeSegmentation.setActiveSegmentationRepresentation(\n      toolGroupId,\n      representation.segmentationRepresentationUID\n    );\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation: targetSegmentation,\n      });\n    }\n  }\n\n  private _toggleSegmentationVisibility = (segmentationId: string, suppressEvents = false) => {\n    const segmentation = this.segmentations[segmentationId];\n\n    if (!segmentation) {\n      throw new Error(`Segmentation with segmentationId ${segmentationId} not found.`);\n    }\n\n    segmentation.isVisible = !segmentation.isVisible;\n\n    this._updateCornerstoneSegmentationVisibility(segmentationId);\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _setActiveSegment(segmentationId: string, segmentIndex: number, suppressEvents = false) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    cstSegmentation.segmentIndex.setActiveSegmentIndex(segmentationId, segmentIndex);\n\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _getSegmentInfo(segmentation: Segmentation, segmentIndex: number) {\n    const segments = segmentation.segments;\n\n    if (!segments) {\n      return;\n    }\n\n    if (segments && segments.length > 0) {\n      return segments[segmentIndex];\n    }\n  }\n\n  private _getVolumeIdForDisplaySet(displaySet) {\n    const volumeLoaderSchema = displaySet.volumeLoaderSchema ?? VOLUME_LOADER_SCHEME;\n\n    return `${volumeLoaderSchema}:${displaySet.displaySetInstanceUID}`;\n  }\n\n  private _setSegmentColor = (\n    segmentationId: string,\n    segmentIndex: number,\n    color: ohifTypes.RGB,\n    toolGroupId?: string,\n    suppressEvents = false\n  ) => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(`Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`);\n    }\n\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (!segmentationRepresentation) {\n      throw new Error('Must add representation to toolgroup before setting segments');\n    }\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n\n    const rgbaColor = cstSegmentation.config.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    cstSegmentation.config.color.setColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex,\n      [...color, rgbaColor[3]]\n    );\n\n    segmentInfo.color = color;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _getSegmentCenter(segmentationId, segmentIndex) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (!segmentation) {\n      return;\n    }\n\n    const { cachedStats } = segmentation;\n\n    if (!cachedStats) {\n      return;\n    }\n\n    const { segmentCenter } = cachedStats;\n\n    if (!segmentCenter) {\n      return;\n    }\n\n    const { center } = segmentCenter[segmentIndex];\n\n    return center;\n  }\n\n  private _setSegmentLocked(\n    segmentationId: string,\n    segmentIndex: number,\n    isLocked: boolean,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(`Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`);\n    }\n\n    segmentInfo.isLocked = isLocked;\n\n    cstSegmentation.segmentLocking.setSegmentIndexLocked(segmentationId, segmentIndex, isLocked);\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _setSegmentVisibility(\n    segmentationId: string,\n    segmentIndex: number,\n    isVisible: boolean,\n    toolGroupId?: string,\n    suppressEvents = false\n  ) {\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const { segmentationRepresentationUID, segmentation } = this._getSegmentationInfo(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(`Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`);\n    }\n\n    segmentInfo.isVisible = isVisible;\n\n    cstSegmentation.config.visibility.setSegmentVisibility(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex,\n      isVisible\n    );\n\n    // make sure to update the isVisible flag on the segmentation\n    // if a segment becomes invisible then the segmentation should be invisible\n    // in the status as well, and show correct icon\n    segmentation.isVisible = segmentation.segments\n      .filter(Boolean)\n      .every(segment => segment.isVisible);\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _setSegmentOpacity = (\n    segmentationId: string,\n    segmentIndex: number,\n    opacity: number,\n    toolGroupId?: string,\n    suppressEvents = false\n  ) => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(`Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`);\n    }\n\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (!segmentationRepresentation) {\n      throw new Error('Must add representation to toolgroup before setting segments');\n    }\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n\n    const rgbaColor = cstSegmentation.config.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    cstSegmentation.config.color.setColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex,\n      [rgbaColor[0], rgbaColor[1], rgbaColor[2], opacity]\n    );\n\n    segmentInfo.opacity = opacity;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _setSegmentLabel(\n    segmentationId: string,\n    segmentIndex: number,\n    segmentLabel: string,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(`Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`);\n    }\n\n    segmentInfo.label = segmentLabel;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _getSegmentationRepresentation(segmentationId, toolGroupId) {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentationsForToolGroup(toolGroupId);\n\n    if (!segmentationRepresentations?.length) {\n      return;\n    }\n\n    // Todo: this finds the first segmentation representation that matches the segmentationId\n    // If there are two labelmap representations from the same segmentation, this will not work\n    const representation = segmentationRepresentations.find(\n      representation => representation.segmentationId === segmentationId\n    );\n\n    return representation;\n  }\n\n  private _setSegmentationConfig = (property, value) => {\n    // Todo: currently we only support global config, and we get the type\n    // from the first segmentation\n    const typeToUse = this.getSegmentations()[0].type;\n\n    const { cornerstoneViewportService } = this.servicesManager.services;\n\n    const config = cstSegmentation.config.getGlobalConfig();\n\n    config.representations[typeToUse][property] = value;\n\n    // Todo: add non global (representation specific config as well)\n    cstSegmentation.config.setGlobalConfig(config);\n\n    const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n    const viewportIds = cornerstoneViewportService.getViewportIds();\n\n    renderingEngine.renderViewports(viewportIds);\n  };\n\n  private _initSegmentationService() {\n    // Connect Segmentation Service to Cornerstone3D.\n    eventTarget.addEventListener(\n      csToolsEnums.Events.SEGMENTATION_MODIFIED,\n      this._onSegmentationModifiedFromSource\n    );\n\n    eventTarget.addEventListener(\n      csToolsEnums.Events.SEGMENTATION_DATA_MODIFIED,\n      this._onSegmentationDataModified\n    );\n  }\n\n  private _onSegmentationDataModified = evt => {\n    const { segmentationId } = evt.detail;\n\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      // Part of add operation, not update operation, exit early.\n      return;\n    }\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_DATA_MODIFIED, {\n      segmentation,\n    });\n  };\n\n  private _onSegmentationModifiedFromSource = evt => {\n    const { segmentationId } = evt.detail;\n\n    const segmentation = this.segmentations[segmentationId];\n\n    if (segmentation === undefined) {\n      // Part of add operation, not update operation, exit early.\n      return;\n    }\n\n    const segmentationState = cstSegmentation.state.getSegmentation(segmentationId);\n\n    if (!segmentationState) {\n      return;\n    }\n\n    const { activeSegmentIndex, cachedStats, segmentsLocked, label, type } = segmentationState;\n\n    if (![LABELMAP, CONTOUR].includes(type)) {\n      throw new Error(\n        `Unsupported segmentation type: ${type}. Only ${LABELMAP} and ${CONTOUR} are supported.`\n      );\n    }\n\n    const representationData = segmentationState.representationData[type];\n\n    // TODO: handle other representations when available in cornerstone3D\n    const segmentationSchema = {\n      ...segmentation,\n      activeSegmentIndex,\n      cachedStats,\n      displayText: [],\n      id: segmentationId,\n      label,\n      segmentsLocked,\n      type,\n      representationData: {\n        [type]: {\n          ...representationData,\n        },\n      },\n    };\n\n    try {\n      this.addOrUpdateSegmentation(segmentationSchema);\n    } catch (error) {\n      console.warn(`Failed to add/update segmentation ${segmentationId}`, error);\n    }\n  };\n\n  private _getSegmentationInfo(segmentationId: string, toolGroupId: string) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (!segmentationRepresentation) {\n      throw new Error('Must add representation to toolgroup before setting segments');\n    }\n\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n\n    return { segmentationRepresentationUID, segmentation };\n  }\n\n  private _removeSegmentationFromCornerstone(segmentationId: string) {\n    // TODO: This should be from the configuration\n    const removeFromCache = true;\n    const segmentationState = cstSegmentation.state;\n    const sourceSegState = segmentationState.getSegmentation(segmentationId);\n\n    if (!sourceSegState) {\n      return;\n    }\n\n    const toolGroupIds = segmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n    toolGroupIds.forEach(toolGroupId => {\n      const segmentationRepresentations =\n        segmentationState.getSegmentationRepresentations(toolGroupId);\n\n      const UIDsToRemove = [];\n      segmentationRepresentations.forEach(representation => {\n        if (representation.segmentationId === segmentationId) {\n          UIDsToRemove.push(representation.segmentationRepresentationUID);\n        }\n      });\n\n      // remove segmentation representations\n      cstSegmentation.removeSegmentationsFromToolGroup(\n        toolGroupId,\n        UIDsToRemove,\n        true // immediate\n      );\n    });\n\n    // cleanup the segmentation state too\n    segmentationState.removeSegmentation(segmentationId);\n\n    if (removeFromCache && cache.getVolumeLoadObject(segmentationId)) {\n      cache.removeVolumeLoadObject(segmentationId);\n    }\n  }\n\n  private _updateCornerstoneSegmentations({ segmentationId, notYetUpdatedAtSource }) {\n    if (notYetUpdatedAtSource === false) {\n      return;\n    }\n    const segmentationState = cstSegmentation.state;\n    const sourceSegmentation = segmentationState.getSegmentation(segmentationId);\n    const segmentation = this.segmentations[segmentationId];\n    const { label, cachedStats } = segmentation;\n\n    // Update the label in the source if necessary\n    if (sourceSegmentation.label !== label) {\n      sourceSegmentation.label = label;\n    }\n\n    if (!isEqual(sourceSegmentation.cachedStats, cachedStats)) {\n      sourceSegmentation.cachedStats = cachedStats;\n    }\n  }\n\n  private _updateCornerstoneSegmentationVisibility = segmentationId => {\n    const segmentationState = cstSegmentation.state;\n    const toolGroupIds = segmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n    toolGroupIds.forEach(toolGroupId => {\n      const segmentationRepresentations =\n        cstSegmentation.state.getSegmentationRepresentations(toolGroupId);\n\n      if (segmentationRepresentations.length === 0) {\n        return;\n      }\n\n      // Todo: this finds the first segmentation representation that matches the segmentationId\n      // If there are two labelmap representations from the same segmentation, this will not work\n      const representation = segmentationRepresentations.find(\n        representation => representation.segmentationId === segmentationId\n      );\n\n      const { segmentsHidden } = representation;\n\n      const currentVisibility = segmentsHidden.size === 0 ? true : false;\n      const newVisibility = !currentVisibility;\n\n      cstSegmentation.config.visibility.setSegmentationVisibility(\n        toolGroupId,\n        representation.segmentationRepresentationUID,\n        newVisibility\n      );\n\n      // update segments visibility\n      const { segmentation } = this._getSegmentationInfo(segmentationId, toolGroupId);\n\n      const segments = segmentation.segments.filter(Boolean);\n\n      segments.forEach(segment => {\n        segment.isVisible = newVisibility;\n      });\n    });\n  };\n\n  private _getToolGroupIdsWithSegmentation(segmentationId: string) {\n    const segmentationState = cstSegmentation.state;\n    const toolGroupIds = segmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n    return toolGroupIds;\n  }\n\n  private _getFrameOfReferenceUIDForSeg(displaySet) {\n    const frameOfReferenceUID = displaySet.instance?.FrameOfReferenceUID;\n\n    if (frameOfReferenceUID) {\n      return frameOfReferenceUID;\n    }\n\n    // if not found we should try the ReferencedFrameOfReferenceSequence\n    const referencedFrameOfReferenceSequence =\n      displaySet.instance?.ReferencedFrameOfReferenceSequence;\n\n    if (referencedFrameOfReferenceSequence) {\n      return referencedFrameOfReferenceSequence.FrameOfReferenceUID;\n    }\n  }\n\n  private _getFirstToolGroupId = () => {\n    const { toolGroupService } = this.servicesManager.services;\n    const toolGroupIds = toolGroupService.getToolGroupIds();\n\n    return toolGroupIds[0];\n  };\n\n  private getNextColorLUTIndex = (): number => {\n    let i = 0;\n    while (true) {\n      if (cstSegmentation.state.getColorLUT(i) === undefined) {\n        return i;\n      }\n\n      i++;\n    }\n  };\n\n  private generateNewColorLUT() {\n    const newColorLUT = cloneDeep(COLOR_LUT);\n\n    return newColorLUT;\n  }\n\n  /**\n   * Converts object of objects to array.\n   *\n   * @return {Array} Array of objects\n   */\n  private arrayOfObjects = obj => {\n    return Object.entries(obj).map(e => ({ [e[0]]: e[1] }));\n  };\n}\n\nexport default SegmentationService;\nexport { EVENTS, VALUE_TYPES };\n","/**\n * Maps a DICOM RT Struct ROI Contour to a RTStruct data that can be used\n * in Segmentation Service\n *\n * @param structureSet - A DICOM RT Struct ROI Contour\n * @param rtDisplaySetUID - A CornerstoneTools DisplaySet UID\n * @returns An array of object that includes data, id, segmentIndex, color\n * and geometry Id\n */\nexport function mapROIContoursToRTStructData(structureSet: unknown, rtDisplaySetUID: unknown) {\n  return structureSet.ROIContours.map(({ contourPoints, ROINumber, ROIName, colorArray }) => {\n    const data = contourPoints.map(({ points, ...rest }) => {\n      const newPoints = points.map(({ x, y, z }) => {\n        return [x, y, z];\n      });\n\n      return {\n        ...rest,\n        points: newPoints,\n      };\n    });\n\n    const id = ROIName || ROINumber;\n\n    return {\n      data,\n      id,\n      segmentIndex: ROINumber,\n      color: colorArray,\n      geometryId: `${rtDisplaySetUID}:${id}:segmentIndex-${ROINumber}`,\n    };\n  });\n}\n","import SegmentationService from './SegmentationService';\n\nexport default SegmentationService;\n","import { Enums } from '@cornerstonejs/core';\n\nconst STACK = 'stack';\nconst VOLUME = 'volume';\nconst ORTHOGRAPHIC = 'orthographic';\nconst VOLUME_3D = 'volume3d';\n\nexport default function getCornerstoneViewportType(viewportType: string): Enums.ViewportType {\n  const lowerViewportType = viewportType.toLowerCase();\n  if (lowerViewportType === STACK) {\n    return Enums.ViewportType.STACK;\n  }\n\n  if (lowerViewportType === VOLUME || lowerViewportType === ORTHOGRAPHIC) {\n    return Enums.ViewportType.ORTHOGRAPHIC;\n  }\n\n  if (lowerViewportType === VOLUME_3D) {\n    return Enums.ViewportType.VOLUME_3D;\n  }\n\n  throw new Error(`Invalid viewport type: ${viewportType}. Valid types are: stack, volume`);\n}\n","import { ServicesManager, Types } from '@ohif/core';\nimport { cache as cs3DCache, Enums, volumeLoader, utilities as utils } from '@cornerstonejs/core';\n\nimport getCornerstoneViewportType from '../../utils/getCornerstoneViewportType';\nimport { StackViewportData, VolumeViewportData } from '../../types/CornerstoneCacheService';\n\nconst VOLUME_LOADER_SCHEME = 'cornerstoneStreamingImageVolume';\n\nclass CornerstoneCacheService {\n  static REGISTRATION = {\n    name: 'cornerstoneCacheService',\n    altName: 'CornerstoneCacheService',\n    create: ({ servicesManager }: Types.Extensions.ExtensionParams): CornerstoneCacheService => {\n      return new CornerstoneCacheService(servicesManager);\n    },\n  };\n\n  stackImageIds: Map<string, string[]> = new Map();\n  volumeImageIds: Map<string, string[]> = new Map();\n  readonly servicesManager: ServicesManager;\n\n  constructor(servicesManager: ServicesManager) {\n    this.servicesManager = servicesManager;\n  }\n\n  public getCacheSize() {\n    return cs3DCache.getCacheSize();\n  }\n\n  public getCacheFreeSpace() {\n    return cs3DCache.getBytesAvailable();\n  }\n\n  public async createViewportData(\n    displaySets: unknown[],\n    viewportOptions: Record<string, unknown>,\n    dataSource: unknown,\n    initialImageIndex?: number\n  ): Promise<StackViewportData | VolumeViewportData> {\n    let viewportType = viewportOptions.viewportType as string;\n\n    // Todo: Since Cornerstone 3D currently doesn't support segmentation\n    // on stack viewport, we should check if whether the the displaySets\n    // that are about to be displayed are referenced in a segmentation\n    // as a reference volume, if so, we should hang a volume viewport\n    // instead of a stack viewport\n    if (this._shouldRenderSegmentation(displaySets)) {\n      viewportType = 'volume';\n\n      // update viewportOptions to reflect the new viewport type\n      viewportOptions.viewportType = viewportType;\n    }\n\n    const cs3DViewportType = getCornerstoneViewportType(viewportType);\n    let viewportData: StackViewportData | VolumeViewportData;\n\n    if (cs3DViewportType === Enums.ViewportType.STACK) {\n      viewportData = await this._getStackViewportData(\n        dataSource,\n        displaySets,\n        initialImageIndex,\n        cs3DViewportType\n      );\n    }\n\n    if (\n      cs3DViewportType === Enums.ViewportType.ORTHOGRAPHIC ||\n      cs3DViewportType === Enums.ViewportType.VOLUME_3D\n    ) {\n      viewportData = await this._getVolumeViewportData(dataSource, displaySets, cs3DViewportType);\n    }\n\n    viewportData.viewportType = cs3DViewportType;\n\n    return viewportData;\n  }\n\n  public async invalidateViewportData(\n    viewportData: VolumeViewportData,\n    invalidatedDisplaySetInstanceUID: string,\n    dataSource,\n    displaySetService\n  ) {\n    if (viewportData.viewportType === Enums.ViewportType.STACK) {\n      return this._getCornerstoneStackImageIds(\n        displaySetService.getDisplaySetByUID(invalidatedDisplaySetInstanceUID),\n        dataSource\n      );\n    }\n\n    // Todo: grab the volume and get the id from the viewport itself\n    const volumeId = `${VOLUME_LOADER_SCHEME}:${invalidatedDisplaySetInstanceUID}`;\n\n    const volume = cs3DCache.getVolume(volumeId);\n\n    if (volume) {\n      cs3DCache.removeVolumeLoadObject(volumeId);\n      this.volumeImageIds.delete(volumeId);\n    }\n\n    const displaySets = viewportData.data.map(({ displaySetInstanceUID }) =>\n      displaySetService.getDisplaySetByUID(displaySetInstanceUID)\n    );\n\n    const newViewportData = await this._getVolumeViewportData(\n      dataSource,\n      displaySets,\n      viewportData.viewportType\n    );\n\n    return newViewportData;\n  }\n\n  private _getStackViewportData(\n    dataSource,\n    displaySets,\n    initialImageIndex,\n    viewportType: Enums.ViewportType\n  ): StackViewportData {\n    // For Stack Viewport we don't have fusion currently\n    const displaySet = displaySets[0];\n\n    let stackImageIds = this.stackImageIds.get(displaySet.displaySetInstanceUID);\n\n    if (!stackImageIds) {\n      stackImageIds = this._getCornerstoneStackImageIds(displaySet, dataSource);\n      this.stackImageIds.set(displaySet.displaySetInstanceUID, stackImageIds);\n    }\n\n    const { displaySetInstanceUID, StudyInstanceUID, isCompositeStack } = displaySet;\n\n    const StackViewportData: StackViewportData = {\n      viewportType,\n      data: {\n        StudyInstanceUID,\n        displaySetInstanceUID,\n        isCompositeStack,\n        imageIds: stackImageIds,\n      },\n    };\n\n    if (typeof initialImageIndex === 'number') {\n      StackViewportData.data.initialImageIndex = initialImageIndex;\n    }\n\n    return StackViewportData;\n  }\n\n  private async _getVolumeViewportData(\n    dataSource,\n    displaySets,\n    viewportType: Enums.ViewportType\n  ): Promise<VolumeViewportData> {\n    // Todo: Check the cache for multiple scenarios to see if we need to\n    // decache the volume data from other viewports or not\n\n    const volumeData = [];\n\n    for (const displaySet of displaySets) {\n      // Don't create volumes for the displaySets that have custom load\n      // function (e.g., SEG, RT, since they rely on the reference volumes\n      // and they take care of their own loading after they are created in their\n      // getSOPClassHandler method\n\n      if (displaySet.load && displaySet.load instanceof Function) {\n        const { userAuthenticationService } = this.servicesManager.services;\n        const headers = userAuthenticationService.getAuthorizationHeader();\n        await displaySet.load({ headers });\n\n        volumeData.push({\n          studyInstanceUID: displaySet.StudyInstanceUID,\n          displaySetInstanceUID: displaySet.displaySetInstanceUID,\n        });\n\n        // Todo: do some cache check and empty the cache if needed\n        continue;\n      }\n\n      const volumeLoaderSchema = displaySet.volumeLoaderSchema ?? VOLUME_LOADER_SCHEME;\n\n      const volumeId = `${volumeLoaderSchema}:${displaySet.displaySetInstanceUID}`;\n\n      let volumeImageIds = this.volumeImageIds.get(displaySet.displaySetInstanceUID);\n\n      let volume = cs3DCache.getVolume(volumeId);\n\n      if (!volumeImageIds || !volume) {\n        volumeImageIds = this._getCornerstoneVolumeImageIds(displaySet, dataSource);\n\n        volume = await volumeLoader.createAndCacheVolume(volumeId, {\n          imageIds: volumeImageIds,\n        });\n\n        this.volumeImageIds.set(displaySet.displaySetInstanceUID, volumeImageIds);\n      }\n\n      volumeData.push({\n        StudyInstanceUID: displaySet.StudyInstanceUID,\n        displaySetInstanceUID: displaySet.displaySetInstanceUID,\n        volume,\n        volumeId,\n        imageIds: volumeImageIds,\n      });\n    }\n\n    return {\n      viewportType,\n      data: volumeData,\n    };\n  }\n\n  private _shouldRenderSegmentation(displaySets) {\n    const { segmentationService, displaySetService } = this.servicesManager.services;\n\n    const viewportDisplaySetInstanceUIDs = displaySets.map(\n      ({ displaySetInstanceUID }) => displaySetInstanceUID\n    );\n\n    // check inside segmentations if any of them are referencing the displaySets\n    // that are about to be displayed\n    const segmentations = segmentationService.getSegmentations();\n\n    for (const segmentation of segmentations) {\n      const segDisplaySetInstanceUID = segmentation.displaySetInstanceUID;\n      const segDisplaySet = displaySetService.getDisplaySetByUID(segDisplaySetInstanceUID);\n\n      const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\n        viewportDisplaySetInstanceUIDs,\n        segDisplaySet.instances[0].FrameOfReferenceUID\n      );\n\n      if (shouldDisplaySeg) {\n        return true;\n      }\n    }\n  }\n\n  private _getCornerstoneStackImageIds(displaySet, dataSource): string[] {\n    return dataSource.getImageIdsForDisplaySet(displaySet);\n  }\n\n  private _getCornerstoneVolumeImageIds(displaySet, dataSource): string[] {\n    const stackImageIds = this._getCornerstoneStackImageIds(displaySet, dataSource);\n\n    return stackImageIds;\n  }\n}\n\nexport default CornerstoneCacheService;\n","import CornerstoneCacheService from './CornerstoneCacheService';\n\nexport default CornerstoneCacheService;\n","const RENDERING_ENGINE_ID = 'OHIFCornerstoneRenderingEngine';\n\nexport { RENDERING_ENGINE_ID };\n","import { Types, Enums } from '@cornerstonejs/core';\nimport { Types as UITypes } from '@ohif/ui';\nimport { StackViewportData, VolumeViewportData } from '../../types/CornerstoneCacheService';\nimport getCornerstoneBlendMode from '../../utils/getCornerstoneBlendMode';\nimport getCornerstoneOrientation from '../../utils/getCornerstoneOrientation';\nimport getCornerstoneViewportType from '../../utils/getCornerstoneViewportType';\nimport JumpPresets from '../../utils/JumpPresets';\nimport { SyncGroup } from '../SyncGroupService/SyncGroupService';\n\nexport type InitialImageOptions = {\n  index?: number;\n  preset?: JumpPresets;\n};\n\nexport type ViewportOptions = {\n  id?: string;\n  viewportType: Enums.ViewportType;\n  toolGroupId: string;\n  viewportId: string;\n  // Presentation ID to store/load presentation state from\n  presentationIds?: UITypes.PresentationIds;\n  orientation?: Enums.OrientationAxis;\n  background?: Types.Point3;\n  syncGroups?: SyncGroup[];\n  initialImageOptions?: InitialImageOptions;\n  customViewportProps?: Record<string, unknown>;\n  /*\n   * Allows drag and drop of display sets not matching viewport options, but\n   * doesn't show them initially.  Displays initially blank if no required match\n   */\n  allowUnmatchedView?: boolean;\n};\n\nexport type PublicViewportOptions = {\n  id?: string;\n  viewportType?: string;\n  toolGroupId?: string;\n  presentationIds?: UITypes.PresentationIds;\n  viewportId?: string;\n  orientation?: Enums.OrientationAxis;\n  background?: Types.Point3;\n  syncGroups?: SyncGroup[];\n  initialImageOptions?: InitialImageOptions;\n  customViewportProps?: Record<string, unknown>;\n  allowUnmatchedView?: boolean;\n};\n\nexport type DisplaySetSelector = {\n  id?: string;\n  options?: PublicDisplaySetOptions;\n};\n\nexport type PublicDisplaySetOptions = {\n  /** The display set options can have an id in order to distinguish\n   * it from other similar items.\n   */\n  id?: string;\n  voi?: VOI;\n  voiInverted?: boolean;\n  blendMode?: string;\n  slabThickness?: number;\n  colormap?: string;\n  displayPreset?: string;\n};\n\nexport type DisplaySetOptions = {\n  id?: string;\n  voi?: VOI;\n  voiInverted: boolean;\n  blendMode?: Enums.BlendModes;\n  slabThickness?: number;\n  colormap?: string;\n  displayPreset?: string;\n};\n\ntype VOI = {\n  windowWidth: number;\n  windowCenter: number;\n};\n\nexport type DisplaySet = {\n  displaySetInstanceUID: string;\n};\n\nconst STACK = 'stack';\nconst DEFAULT_TOOLGROUP_ID = 'default';\n\n// Return true if the data contains the given display set UID OR the imageId\n// if it is a composite object.\nconst dataContains = (data, displaySetUID: string, imageId?: string): boolean => {\n  if (data.displaySetInstanceUID === displaySetUID) {\n    return true;\n  }\n  if (imageId && data.isCompositeStack && data.imageIds) {\n    return !!data.imageIds.find(dataId => dataId === imageId);\n  }\n  return false;\n};\n\nclass ViewportInfo {\n  private viewportId = '';\n  private element: HTMLDivElement;\n  private viewportOptions: ViewportOptions;\n  private displaySetOptions: Array<DisplaySetOptions>;\n  private viewportData: StackViewportData | VolumeViewportData;\n  private renderingEngineId: string;\n\n  constructor(viewportId: string) {\n    this.viewportId = viewportId;\n    this.setPublicViewportOptions({});\n    this.setPublicDisplaySetOptions([{}]);\n  }\n\n  /**\n   * Return true if the viewport contains the given display set UID,\n   * OR if it is a composite stack and contains the given imageId\n   */\n  public contains(displaySetUID: string, imageId: string): boolean {\n    if (!this.viewportData?.data) {\n      return false;\n    }\n\n    if (this.viewportData.data.length) {\n      return !!this.viewportData.data.find(data => dataContains(data, displaySetUID, imageId));\n    }\n    return dataContains(this.viewportData.data, displaySetUID, imageId);\n  }\n\n  public destroy = (): void => {\n    this.element = null;\n    this.viewportData = null;\n    this.viewportOptions = null;\n    this.displaySetOptions = null;\n  };\n\n  public setRenderingEngineId(renderingEngineId: string): void {\n    this.renderingEngineId = renderingEngineId;\n  }\n\n  public getRenderingEngineId(): string {\n    return this.renderingEngineId;\n  }\n\n  public setViewportId(viewportId: string): void {\n    this.viewportId = viewportId;\n  }\n\n  public setElement(element: HTMLDivElement): void {\n    this.element = element;\n  }\n\n  public setViewportData(viewportData: StackViewportData | VolumeViewportData): void {\n    this.viewportData = viewportData;\n  }\n\n  public getViewportData(): StackViewportData | VolumeViewportData {\n    return this.viewportData;\n  }\n\n  public getElement(): HTMLDivElement {\n    return this.element;\n  }\n\n  public getViewportId(): string {\n    return this.viewportId;\n  }\n\n  public setPublicDisplaySetOptions(\n    publicDisplaySetOptions: PublicDisplaySetOptions[] | DisplaySetSelector[]\n  ): Array<DisplaySetOptions> {\n    // map the displaySetOptions and check if they are undefined then set them to default values\n    const displaySetOptions = this.mapDisplaySetOptions(publicDisplaySetOptions);\n\n    this.setDisplaySetOptions(displaySetOptions);\n\n    return this.displaySetOptions;\n  }\n\n  public hasDisplaySet(displaySetInstanceUID: string): boolean {\n    // Todo: currently this does not work for non image & referenceImage displaySets.\n    // Since SEG and other derived displaySets are loaded in a different way, and not\n    // via cornerstoneViewportService\n    let viewportData = this.getViewportData();\n\n    if (\n      viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC ||\n      viewportData.viewportType === Enums.ViewportType.VOLUME_3D\n    ) {\n      viewportData = viewportData as VolumeViewportData;\n      return viewportData.data.some(\n        ({ displaySetInstanceUID: dsUID }) => dsUID === displaySetInstanceUID\n      );\n    }\n\n    viewportData = viewportData as StackViewportData;\n    return viewportData.data.displaySetInstanceUID === displaySetInstanceUID;\n  }\n\n  public setPublicViewportOptions(viewportOptionsEntry: PublicViewportOptions): ViewportOptions {\n    let viewportType = viewportOptionsEntry.viewportType;\n    const { toolGroupId = DEFAULT_TOOLGROUP_ID, presentationIds } = viewportOptionsEntry;\n    let orientation;\n\n    if (!viewportType) {\n      viewportType = getCornerstoneViewportType(STACK);\n    } else {\n      viewportType = getCornerstoneViewportType(viewportOptionsEntry.viewportType);\n    }\n\n    // map SAGITTAL, AXIAL, CORONAL orientation to be used by cornerstone\n    if (viewportOptionsEntry.viewportType?.toLowerCase() !== STACK) {\n      orientation = getCornerstoneOrientation(viewportOptionsEntry.orientation);\n    }\n\n    if (!toolGroupId) {\n      toolGroupId = DEFAULT_TOOLGROUP_ID;\n    }\n\n    this.setViewportOptions({\n      ...viewportOptionsEntry,\n      viewportId: this.viewportId,\n      viewportType: viewportType as Enums.ViewportType,\n      orientation,\n      toolGroupId,\n      presentationIds,\n    });\n\n    return this.viewportOptions;\n  }\n\n  public setViewportOptions(viewportOptions: ViewportOptions): void {\n    this.viewportOptions = viewportOptions;\n  }\n\n  public getViewportOptions(): ViewportOptions {\n    return this.viewportOptions;\n  }\n\n  public setDisplaySetOptions(displaySetOptions: Array<DisplaySetOptions>): void {\n    this.displaySetOptions = displaySetOptions;\n  }\n\n  public getSyncGroups(): SyncGroup[] {\n    this.viewportOptions.syncGroups ||= [];\n    return this.viewportOptions.syncGroups;\n  }\n\n  public getDisplaySetOptions(): Array<DisplaySetOptions> {\n    return this.displaySetOptions;\n  }\n\n  public getViewportType(): Enums.ViewportType {\n    return this.viewportOptions.viewportType || Enums.ViewportType.STACK;\n  }\n\n  public getToolGroupId(): string {\n    return this.viewportOptions.toolGroupId;\n  }\n\n  public getBackground(): Types.Point3 {\n    return this.viewportOptions.background || [0, 0, 0];\n  }\n\n  public getOrientation(): Enums.OrientationAxis {\n    return this.viewportOptions.orientation;\n  }\n\n  public getInitialImageOptions(): InitialImageOptions {\n    return this.viewportOptions.initialImageOptions;\n  }\n\n  // Handle incoming public display set options or a display set select\n  // with a contained options.\n  private mapDisplaySetOptions(\n    options: PublicDisplaySetOptions[] | DisplaySetSelector[] = [{}]\n  ): Array<DisplaySetOptions> {\n    const displaySetOptions: Array<DisplaySetOptions> = [];\n\n    options.forEach(item => {\n      let option = item?.options || item;\n      if (!option) {\n        option = {\n          blendMode: undefined,\n          slabThickness: undefined,\n          colormap: undefined,\n          voi: {},\n          voiInverted: false,\n        };\n      }\n      const blendMode = getCornerstoneBlendMode(option.blendMode);\n\n      displaySetOptions.push({\n        voi: option.voi,\n        voiInverted: option.voiInverted,\n        colormap: option.colormap,\n        slabThickness: option.slabThickness,\n        blendMode,\n        displayPreset: option.displayPreset,\n      });\n    });\n\n    return displaySetOptions;\n  }\n}\n\nexport default ViewportInfo;\n","import { Enums } from '@cornerstonejs/core';\n\nconst AXIAL = 'axial';\nconst SAGITTAL = 'sagittal';\nconst CORONAL = 'coronal';\n\nexport default function getCornerstoneOrientation(orientation: string): Enums.OrientationAxis {\n  if (orientation) {\n    switch (orientation.toLowerCase()) {\n      case AXIAL:\n        return Enums.OrientationAxis.AXIAL;\n      case SAGITTAL:\n        return Enums.OrientationAxis.SAGITTAL;\n      case CORONAL:\n        return Enums.OrientationAxis.CORONAL;\n      default:\n        return Enums.OrientationAxis.ACQUISITION;\n    }\n  }\n\n  return Enums.OrientationAxis.ACQUISITION;\n}\n","import { Enums } from '@cornerstonejs/core';\n\nconst MIP = 'mip';\n\nexport default function getCornerstoneBlendMode(blendMode: string): Enums.BlendModes {\n  if (!blendMode) {\n    return Enums.BlendModes.COMPOSITE;\n  }\n\n  if (blendMode.toLowerCase() === MIP) {\n    return Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n  }\n\n  throw new Error();\n}\n","/**\n * Jump Presets - This enum defines the 3 jump states which are available\n * to be used with the jumpToSlice utility function.\n */\nenum JumpPresets {\n  /** Jumps to first slice */\n  First = 'first',\n  /** Jumps to last slice */\n  Last = 'last',\n  /** Jumps to the middle slice */\n  Middle = 'middle',\n}\n\nexport default JumpPresets;\n","import { PubSubService, ServicesManager } from '@ohif/core';\nimport * as OhifTypes from '@ohif/core/types';\nimport {\n  RenderingEngine,\n  StackViewport,\n  Types,\n  getRenderingEngine,\n  utilities as csUtils,\n  VolumeViewport,\n  VolumeViewport3D,\n  cache,\n  Enums as csEnums,\n} from '@cornerstonejs/core';\n\nimport { utilities as csToolsUtils, Enums as csToolsEnums } from '@cornerstonejs/tools';\nimport { IViewportService } from './IViewportService';\nimport { RENDERING_ENGINE_ID } from './constants';\nimport ViewportInfo, { DisplaySetOptions, PublicViewportOptions } from './Viewport';\nimport { StackViewportData, VolumeViewportData } from '../../types/CornerstoneCacheService';\nimport { Presentation, Presentations } from '../../types/Presentation';\n\nimport JumpPresets from '../../utils/JumpPresets';\n\nconst EVENTS = {\n  VIEWPORT_DATA_CHANGED: 'event::cornerstoneViewportService:viewportDataChanged',\n};\n\n/**\n * Handles cornerstone viewport logic including enabling, disabling, and\n * updating the viewport.\n */\nclass CornerstoneViewportService extends PubSubService implements IViewportService {\n  static REGISTRATION = {\n    name: 'cornerstoneViewportService',\n    altName: 'CornerstoneViewportService',\n    create: ({\n      servicesManager,\n    }: OhifTypes.Extensions.ExtensionParams): CornerstoneViewportService => {\n      return new CornerstoneViewportService(servicesManager);\n    },\n  };\n\n  renderingEngine: Types.IRenderingEngine | null;\n  viewportsById: Map<string, ViewportInfo> = new Map();\n  viewportGridResizeObserver: ResizeObserver | null;\n  viewportsDisplaySets: Map<string, string[]> = new Map();\n\n  // Some configs\n  enableResizeDetector: true;\n  resizeRefreshRateMs: 200;\n  resizeRefreshMode: 'debounce';\n  servicesManager = null;\n\n  constructor(servicesManager: ServicesManager) {\n    super(EVENTS);\n    this.renderingEngine = null;\n    this.viewportGridResizeObserver = null;\n    this.servicesManager = servicesManager;\n  }\n\n  /**\n   * Adds the HTML element to the viewportService\n   * @param {*} viewportId\n   * @param {*} elementRef\n   */\n  public enableViewport(viewportId: string, elementRef: HTMLDivElement): void {\n    const viewportInfo = new ViewportInfo(viewportId);\n    viewportInfo.setElement(elementRef);\n    this.viewportsById.set(viewportId, viewportInfo);\n  }\n\n  public getViewportIds(): string[] {\n    return Array.from(this.viewportsById.keys());\n  }\n\n  /**\n   * It retrieves the renderingEngine if it does exist, or creates one otherwise\n   * @returns {RenderingEngine} rendering engine\n   */\n  public getRenderingEngine() {\n    // get renderingEngine from cache if it exists\n    const renderingEngine = getRenderingEngine(RENDERING_ENGINE_ID);\n\n    if (renderingEngine) {\n      this.renderingEngine = renderingEngine;\n      return this.renderingEngine;\n    }\n\n    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\n      this.renderingEngine = new RenderingEngine(RENDERING_ENGINE_ID);\n    }\n\n    return this.renderingEngine;\n  }\n\n  /**\n   * It triggers the resize on the rendering engine.\n   */\n  public resize() {\n    const immediate = true;\n    const keepCamera = true;\n\n    this.renderingEngine.resize(immediate, keepCamera);\n    this.renderingEngine.render();\n  }\n\n  /**\n   * Removes the viewport from cornerstone, and destroys the rendering engine\n   */\n  public destroy() {\n    this._removeResizeObserver();\n    this.viewportGridResizeObserver = null;\n    try {\n      this.renderingEngine?.destroy?.();\n    } catch (e) {\n      console.warn('Rendering engine not destroyed', e);\n    }\n    this.viewportsDisplaySets.clear();\n    this.renderingEngine = null;\n    cache.purgeCache();\n  }\n\n  /**\n   * Disables the viewport inside the renderingEngine, if no viewport is left\n   * it destroys the renderingEngine.\n   *\n   * This is called when the element goes away entirely - with new viewportId's\n   * created for every new viewport, this will be called whenever the set of\n   * viewports is changed, but NOT when the viewport position changes only.\n   *\n   * @param viewportId - The viewportId to disable\n   */\n  public disableElement(viewportId: string): void {\n    this.renderingEngine?.disableElement(viewportId);\n\n    // clean up\n    this.viewportsById.delete(viewportId);\n    this.viewportsDisplaySets.delete(viewportId);\n  }\n\n  public setPresentations(viewport, presentations?: Presentations): void {\n    const properties = presentations?.lutPresentation?.properties;\n    if (properties) {\n      viewport.setProperties(properties);\n    }\n    const camera = presentations?.positionPresentation?.camera;\n    if (camera) {\n      viewport.setCamera(camera);\n    }\n  }\n\n  public getPresentation(viewportId: string): Presentation {\n    const viewportInfo = this.viewportsById.get(viewportId);\n    if (!viewportInfo) {\n      return;\n    }\n    const { viewportType, presentationIds } = viewportInfo.getViewportOptions();\n\n    const csViewport = this.getCornerstoneViewport(viewportId);\n    if (!csViewport) {\n      return;\n    }\n\n    const properties = csViewport.getProperties();\n    if (properties.isComputedVOI) {\n      delete properties.voiRange;\n      delete properties.VOILUTFunction;\n    }\n    const initialImageIndex = csViewport.getCurrentImageIdIndex();\n    const camera = csViewport.getCamera();\n    return {\n      presentationIds,\n      viewportType: !viewportType || viewportType === 'stack' ? 'stack' : 'volume',\n      properties,\n      initialImageIndex,\n      camera,\n    };\n  }\n\n  public storePresentation({ viewportId }) {\n    const stateSyncService = this.servicesManager.services.stateSyncService;\n    let presentation;\n    try {\n      presentation = this.getPresentation(viewportId);\n    } catch (error) {\n      console.warn(error);\n    }\n\n    if (!presentation || !presentation.presentationIds) {\n      return;\n    }\n    const { lutPresentationStore, positionPresentationStore } = stateSyncService.getState();\n    const { presentationIds } = presentation;\n    const { lutPresentationId, positionPresentationId } = presentationIds || {};\n    const storeState = {};\n    if (lutPresentationId) {\n      storeState.lutPresentationStore = {\n        ...lutPresentationStore,\n        [lutPresentationId]: presentation,\n      };\n    }\n    if (positionPresentationId) {\n      storeState.positionPresentationStore = {\n        ...positionPresentationStore,\n        [positionPresentationId]: presentation,\n      };\n    }\n    stateSyncService.store(storeState);\n  }\n\n  /**\n   * Sets the viewport data for a viewport.\n   * @param viewportId - The ID of the viewport to set the data for.\n   * @param viewportData - The viewport data to set.\n   * @param publicViewportOptions - The public viewport options.\n   * @param publicDisplaySetOptions - The public display set options.\n   * @param presentations - The presentations to set.\n   */\n  public setViewportData(\n    viewportId: string,\n    viewportData: StackViewportData | VolumeViewportData,\n    publicViewportOptions: PublicViewportOptions,\n    publicDisplaySetOptions: DisplaySetOptions[],\n    presentations?: Presentations\n  ): void {\n    const renderingEngine = this.getRenderingEngine();\n\n    // This is the old viewportInfo, which may have old options but we might be\n    // using its viewport (same viewportId as the new viewportInfo)\n    const viewportInfo = this.viewportsById.get(viewportId);\n\n    // We should store the presentation for the current viewport since we can't only\n    // rely to store it WHEN the viewport is disabled since we might keep around the\n    // same viewport/element and just change the viewportData for it (drag and drop etc.)\n    // the disableElement storePresentation handle would not be called in this case\n    // and we would lose the presentation.\n    this.storePresentation({ viewportId: viewportInfo.getViewportId() });\n\n    if (!viewportInfo) {\n      throw new Error('element is not enabled for the given viewportId');\n    }\n\n    // override the viewportOptions and displaySetOptions with the public ones\n    // since those are the newly set ones, we set them here so that it handles defaults\n    const displaySetOptions = viewportInfo.setPublicDisplaySetOptions(publicDisplaySetOptions);\n    const viewportOptions = viewportInfo.setPublicViewportOptions(publicViewportOptions);\n\n    const element = viewportInfo.getElement();\n    const type = viewportInfo.getViewportType();\n    const background = viewportInfo.getBackground();\n    const orientation = viewportInfo.getOrientation();\n\n    const viewportInput: Types.PublicViewportInput = {\n      viewportId,\n      element,\n      type,\n      defaultOptions: {\n        background,\n        orientation,\n      },\n    };\n\n    // Rendering Engine Id set should happen before enabling the element\n    // since there are callbacks that depend on the renderingEngine id\n    // Todo: however, this is a limitation which means that we can't change\n    // the rendering engine id for a given viewport which might be a super edge\n    // case\n    viewportInfo.setRenderingEngineId(renderingEngine.id);\n\n    // Todo: this is not optimal at all, we are re-enabling the already enabled\n    // element which is not what we want. But enabledElement as part of the\n    // renderingEngine is designed to be used like this. This will trigger\n    // ENABLED_ELEMENT again and again, which will run onEnableElement callbacks\n    renderingEngine.enableElement(viewportInput);\n\n    viewportInfo.setViewportOptions(viewportOptions);\n    viewportInfo.setDisplaySetOptions(displaySetOptions);\n    viewportInfo.setViewportData(viewportData);\n    viewportInfo.setViewportId(viewportId);\n\n    this.viewportsById.set(viewportId, viewportInfo);\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    this._setDisplaySets(viewport, viewportData, viewportInfo, presentations);\n\n    // The broadcast event here ensures that listeners have a valid, up to date\n    // viewport to access.  Doing it too early can result in exceptions or\n    // invalid data.\n    this._broadcastEvent(this.EVENTS.VIEWPORT_DATA_CHANGED, {\n      viewportData,\n      viewportId,\n    });\n  }\n\n  public getCornerstoneViewport(\n    viewportId: string\n  ): Types.IStackViewport | Types.IVolumeViewport | null {\n    const viewportInfo = this.getViewportInfo(viewportId);\n\n    if (!viewportInfo || !this.renderingEngine || this.renderingEngine.hasBeenDestroyed) {\n      return null;\n    }\n\n    const viewport = this.renderingEngine.getViewport(viewportId);\n\n    return viewport;\n  }\n\n  public getViewportInfo(viewportId: string): ViewportInfo {\n    return this.viewportsById.get(viewportId);\n  }\n\n  _setStackViewport(\n    viewport: Types.IStackViewport,\n    viewportData: StackViewportData,\n    viewportInfo: ViewportInfo,\n    presentations: Presentations\n  ): void {\n    const displaySetOptions = viewportInfo.getDisplaySetOptions();\n\n    const { imageIds, initialImageIndex, displaySetInstanceUID } = viewportData.data;\n\n    this.viewportsDisplaySets.set(viewport.id, [displaySetInstanceUID]);\n\n    let initialImageIndexToUse =\n      presentations?.positionPresentation?.initialImageIndex ?? initialImageIndex;\n\n    if (initialImageIndexToUse === undefined || initialImageIndexToUse === null) {\n      initialImageIndexToUse = this._getInitialImageIndexForViewport(viewportInfo, imageIds) || 0;\n    }\n\n    const properties = { ...presentations.lutPresentation?.properties };\n    if (!presentations.lutPresentation?.properties) {\n      const { voi, voiInverted } = displaySetOptions[0];\n      if (voi && (voi.windowWidth || voi.windowCenter)) {\n        const { lower, upper } = csUtils.windowLevel.toLowHighRange(\n          voi.windowWidth,\n          voi.windowCenter\n        );\n        properties.voiRange = { lower, upper };\n      }\n\n      if (voiInverted !== undefined) {\n        properties.invert = voiInverted;\n      }\n    }\n\n    viewport.setStack(imageIds, initialImageIndexToUse).then(() => {\n      viewport.setProperties({ ...properties });\n      const camera = presentations.positionPresentation?.camera;\n      if (camera) {\n        viewport.setCamera(camera);\n      }\n    });\n  }\n\n  private _getInitialImageIndexForViewport(\n    viewportInfo: ViewportInfo,\n    imageIds?: string[]\n  ): number {\n    const initialImageOptions = viewportInfo.getInitialImageOptions();\n\n    if (!initialImageOptions) {\n      return;\n    }\n\n    const { index, preset } = initialImageOptions;\n    const viewportType = viewportInfo.getViewportType();\n\n    let numberOfSlices;\n    if (viewportType === csEnums.ViewportType.STACK) {\n      numberOfSlices = imageIds.length;\n    } else if (viewportType === csEnums.ViewportType.ORTHOGRAPHIC) {\n      const viewport = this.getCornerstoneViewport(viewportInfo.getViewportId());\n      const imageSliceData = csUtils.getImageSliceDataForVolumeViewport(viewport);\n\n      if (!imageSliceData) {\n        return;\n      }\n\n      ({ numberOfSlices } = imageSliceData);\n    } else {\n      return;\n    }\n\n    return this._getInitialImageIndex(numberOfSlices, index, preset);\n  }\n\n  _getInitialImageIndex(numberOfSlices: number, imageIndex?: number, preset?: JumpPresets): number {\n    const lastSliceIndex = numberOfSlices - 1;\n\n    if (imageIndex !== undefined) {\n      return csToolsUtils.clip(imageIndex, 0, lastSliceIndex);\n    }\n\n    if (preset === JumpPresets.First) {\n      return 0;\n    }\n\n    if (preset === JumpPresets.Last) {\n      return lastSliceIndex;\n    }\n\n    if (preset === JumpPresets.Middle) {\n      // Note: this is a simple but yet very important formula.\n      // since viewport reset works with the middle slice\n      // if the below formula is not correct, on a viewport reset\n      // it will jump to a different slice than the middle one which\n      // was the initial slice, and we have some tools such as Crosshairs\n      // which rely on a relative camera modifications and those will break.\n      return lastSliceIndex % 2 === 0 ? lastSliceIndex / 2 : (lastSliceIndex + 1) / 2;\n    }\n\n    return 0;\n  }\n\n  async _setVolumeViewport(\n    viewport: Types.IVolumeViewport,\n    viewportData: VolumeViewportData,\n    viewportInfo: ViewportInfo,\n    presentations: Presentations\n  ): Promise<void> {\n    // TODO: We need to overhaul the way data sources work so requests can be made\n    // async. I think we should follow the image loader pattern which is async and\n    // has a cache behind it.\n    // The problem is that to set this volume, we need the metadata, but the request is\n    // already in-flight, and the promise is not cached, so we have no way to wait for\n    // it and know when it has fully arrived.\n    // loadStudyMetadata(StudyInstanceUID) => Promise([instances for study])\n    // loadSeriesMetadata(StudyInstanceUID, SeriesInstanceUID) => Promise([instances for series])\n    // If you call loadStudyMetadata and it's not in the DicomMetadataStore cache, it should fire\n    // a request through the data source?\n    // (This call may or may not create sub-requests for series metadata)\n    const volumeInputArray = [];\n    const displaySetOptionsArray = viewportInfo.getDisplaySetOptions();\n    const { hangingProtocolService } = this.servicesManager.services;\n\n    const volumeToLoad = [];\n    const displaySetInstanceUIDs = [];\n\n    for (const [index, data] of viewportData.data.entries()) {\n      const { volume, imageIds, displaySetInstanceUID } = data;\n\n      displaySetInstanceUIDs.push(displaySetInstanceUID);\n\n      if (!volume) {\n        console.log('Volume display set not found');\n        continue;\n      }\n\n      volumeToLoad.push(volume);\n\n      const displaySetOptions = displaySetOptionsArray[index];\n      const { volumeId } = volume;\n\n      volumeInputArray.push({\n        imageIds,\n        volumeId,\n        blendMode: displaySetOptions.blendMode,\n        slabThickness: this._getSlabThickness(displaySetOptions, volumeId),\n      });\n    }\n\n    this.viewportsDisplaySets.set(viewport.id, displaySetInstanceUIDs);\n\n    if (hangingProtocolService.getShouldPerformCustomImageLoad()) {\n      // delegate the volume loading to the hanging protocol service if it has a custom image load strategy\n      return hangingProtocolService.runImageLoadStrategy({\n        viewportId: viewport.id,\n        volumeInputArray,\n      });\n    }\n\n    volumeToLoad.forEach(volume => {\n      if (!volume.loadStatus.loaded && !volume.loadStatus.loading) {\n        volume.load();\n      }\n    });\n\n    // This returns the async continuation only\n    return this.setVolumesForViewport(viewport, volumeInputArray, presentations);\n  }\n\n  public async setVolumesForViewport(viewport, volumeInputArray, presentations) {\n    const { displaySetService, toolGroupService } = this.servicesManager.services;\n\n    const viewportInfo = this.getViewportInfo(viewport.id);\n    const displaySetOptions = viewportInfo.getDisplaySetOptions();\n\n    // Todo: use presentations states\n    const volumesProperties = volumeInputArray.map((volumeInput, index) => {\n      const { volumeId } = volumeInput;\n      const displaySetOption = displaySetOptions[index];\n      const { voi, voiInverted, colormap, displayPreset } = displaySetOption;\n      const properties = {};\n\n      if (voi && (voi.windowWidth || voi.windowCenter)) {\n        const { lower, upper } = csUtils.windowLevel.toLowHighRange(\n          voi.windowWidth,\n          voi.windowCenter\n        );\n        properties.voiRange = { lower, upper };\n      }\n\n      if (voiInverted !== undefined) {\n        properties.invert = voiInverted;\n      }\n\n      if (colormap !== undefined) {\n        properties.colormap = colormap;\n      }\n\n      if (displayPreset !== undefined) {\n        properties.preset = displayPreset;\n      }\n\n      return { properties, volumeId };\n    });\n\n    await viewport.setVolumes(volumeInputArray);\n    volumesProperties.forEach(({ properties, volumeId }) => {\n      viewport.setProperties(properties, volumeId);\n    });\n\n    this.setPresentations(viewport, presentations);\n\n    // load any secondary displaySets\n    const displaySetInstanceUIDs = this.viewportsDisplaySets.get(viewport.id);\n\n    // can be SEG or RTSTRUCT for now\n    const overlayDisplaySet = displaySetInstanceUIDs\n      .map(displaySetService.getDisplaySetByUID)\n      .find(displaySet => displaySet?.isOverlayDisplaySet);\n\n    if (overlayDisplaySet) {\n      this.addOverlayRepresentationForDisplaySet(overlayDisplaySet, viewport);\n    } else {\n      // If the displaySet is not a SEG displaySet we assume it is a primary displaySet\n      // and we can look into hydrated segmentations to check if any of them are\n      // associated with the primary displaySet\n\n      // get segmentations only returns the hydrated segmentations\n      this._addSegmentationRepresentationToToolGroupIfNecessary(displaySetInstanceUIDs, viewport);\n    }\n\n    const toolGroup = toolGroupService.getToolGroupForViewport(viewport.id);\n    csToolsUtils.segmentation.triggerSegmentationRender(toolGroup.id);\n\n    const imageIndex = this._getInitialImageIndexForViewport(viewportInfo);\n\n    if (imageIndex !== undefined) {\n      csToolsUtils.jumpToSlice(viewport.element, {\n        imageIndex,\n      });\n    }\n\n    viewport.render();\n  }\n\n  private _addSegmentationRepresentationToToolGroupIfNecessary(\n    displaySetInstanceUIDs: string[],\n    viewport: any\n  ) {\n    const { segmentationService, toolGroupService } = this.servicesManager.services;\n\n    const toolGroup = toolGroupService.getToolGroupForViewport(viewport.id);\n\n    // this only returns hydrated segmentations\n    const segmentations = segmentationService.getSegmentations();\n\n    for (const segmentation of segmentations) {\n      const toolGroupSegmentationRepresentations =\n        segmentationService.getSegmentationRepresentationsForToolGroup(toolGroup.id) || [];\n\n      // if there is already a segmentation representation for this segmentation\n      // for this toolGroup, don't bother at all\n      const isSegmentationInToolGroup = toolGroupSegmentationRepresentations.find(\n        representation => representation.segmentationId === segmentation.id\n      );\n\n      if (isSegmentationInToolGroup) {\n        continue;\n      }\n\n      // otherwise, check if the hydrated segmentations are in the same FrameOfReferenceUID\n      // as the primary displaySet, if so add the representation (since it was not there)\n      const { id: segDisplaySetInstanceUID } = segmentation;\n      let segFrameOfReferenceUID = this._getFrameOfReferenceUID(segDisplaySetInstanceUID);\n\n      if (!segFrameOfReferenceUID) {\n        // if the segmentation displaySet does not have a FrameOfReferenceUID, we might check the\n        // segmentation itself maybe it has a FrameOfReferenceUID\n        const { FrameOfReferenceUID } = segmentation;\n        if (FrameOfReferenceUID) {\n          segFrameOfReferenceUID = FrameOfReferenceUID;\n        }\n      }\n\n      if (!segFrameOfReferenceUID) {\n        return;\n      }\n\n      let shouldDisplaySeg = false;\n\n      for (const displaySetInstanceUID of displaySetInstanceUIDs) {\n        const primaryFrameOfReferenceUID = this._getFrameOfReferenceUID(displaySetInstanceUID);\n\n        if (segFrameOfReferenceUID === primaryFrameOfReferenceUID) {\n          shouldDisplaySeg = true;\n          break;\n        }\n      }\n\n      if (!shouldDisplaySeg) {\n        return;\n      }\n\n      segmentationService.addSegmentationRepresentationToToolGroup(\n        toolGroup.id,\n        segmentation.id,\n        false, // already hydrated,\n        segmentation.type\n      );\n    }\n  }\n\n  private addOverlayRepresentationForDisplaySet(displaySet: any, viewport: any) {\n    const { segmentationService, toolGroupService } = this.servicesManager.services;\n\n    const { referencedVolumeId } = displaySet;\n    const segmentationId = displaySet.displaySetInstanceUID;\n\n    const toolGroup = toolGroupService.getToolGroupForViewport(viewport.id);\n\n    const representationType =\n      referencedVolumeId && cache.getVolume(referencedVolumeId) !== undefined\n        ? csToolsEnums.SegmentationRepresentations.Labelmap\n        : csToolsEnums.SegmentationRepresentations.Contour;\n\n    segmentationService.addSegmentationRepresentationToToolGroup(\n      toolGroup.id,\n      segmentationId,\n      false,\n      representationType\n    );\n  }\n\n  // Todo: keepCamera is an interim solution until we have a better solution for\n  // keeping the camera position when the viewport data is changed\n  public updateViewport(viewportId: string, viewportData, keepCamera = false) {\n    const viewportInfo = this.getViewportInfo(viewportId);\n    const viewport = this.getCornerstoneViewport(viewportId);\n    const viewportCamera = viewport.getCamera();\n\n    if (viewport instanceof VolumeViewport || viewport instanceof VolumeViewport3D) {\n      this._setVolumeViewport(viewport, viewportData, viewportInfo).then(() => {\n        if (keepCamera) {\n          viewport.setCamera(viewportCamera);\n          viewport.render();\n        }\n      });\n\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      this._setStackViewport(viewport, viewportData, viewportInfo);\n      return;\n    }\n  }\n\n  _setDisplaySets(\n    viewport: StackViewport | VolumeViewport,\n    viewportData: StackViewportData | VolumeViewportData,\n    viewportInfo: ViewportInfo,\n    presentations: Presentations = {}\n  ): void {\n    if (viewport instanceof StackViewport) {\n      this._setStackViewport(\n        viewport,\n        viewportData as StackViewportData,\n        viewportInfo,\n        presentations\n      );\n    } else if (viewport instanceof VolumeViewport || viewport instanceof VolumeViewport3D) {\n      this._setVolumeViewport(\n        viewport,\n        viewportData as VolumeViewportData,\n        viewportInfo,\n        presentations\n      );\n    } else {\n      throw new Error('Unknown viewport type');\n    }\n  }\n\n  /**\n   * Removes the resize observer from the viewport element\n   */\n  _removeResizeObserver() {\n    if (this.viewportGridResizeObserver) {\n      this.viewportGridResizeObserver.disconnect();\n    }\n  }\n\n  _getSlabThickness(displaySetOptions, volumeId) {\n    const { blendMode } = displaySetOptions;\n    if (blendMode === undefined || displaySetOptions.slabThickness === undefined) {\n      return;\n    }\n\n    // if there is a slabThickness set as a number then use it\n    if (typeof displaySetOptions.slabThickness === 'number') {\n      return displaySetOptions.slabThickness;\n    }\n\n    if (displaySetOptions.slabThickness.toLowerCase() === 'fullvolume') {\n      // calculate the slab thickness based on the volume dimensions\n      const imageVolume = cache.getVolume(volumeId);\n\n      const { dimensions } = imageVolume;\n      const slabThickness = Math.sqrt(\n        dimensions[0] * dimensions[0] +\n          dimensions[1] * dimensions[1] +\n          dimensions[2] * dimensions[2]\n      );\n\n      return slabThickness;\n    }\n  }\n\n  _getFrameOfReferenceUID(displaySetInstanceUID) {\n    const { displaySetService } = this.servicesManager.services;\n    const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n    if (!displaySet) {\n      return;\n    }\n\n    if (displaySet.frameOfReferenceUID) {\n      return displaySet.frameOfReferenceUID;\n    }\n\n    if (displaySet.Modality === 'SEG') {\n      const { instance } = displaySet;\n      return instance.FrameOfReferenceUID;\n    }\n\n    if (displaySet.Modality === 'RTSTRUCT') {\n      const { instance } = displaySet;\n      return instance.ReferencedFrameOfReferenceSequence.FrameOfReferenceUID;\n    }\n\n    const { images } = displaySet;\n    if (images && images.length) {\n      return images[0].FrameOfReferenceUID;\n    }\n  }\n\n  /**\n   * Looks through the viewports to see if the specified measurement can be\n   * displayed in one of the viewports.\n   *\n   * @param measurement\n   *          The measurement that is desired to view.\n   * @param activeViewportId - the index that was active at the time the jump\n   *          was initiated.\n   * @return the viewportId that the measurement should be displayed in.\n   */\n  public getViewportIdToJump(\n    activeViewportId: string,\n    displaySetInstanceUID: string,\n    cameraProps: unknown\n  ): string {\n    const viewportInfo = this.getViewportInfo(activeViewportId);\n    const { referencedImageId } = cameraProps;\n    if (viewportInfo?.contains(displaySetInstanceUID, referencedImageId)) {\n      return activeViewportId;\n    }\n\n    return (\n      [...this.viewportsById.values()].find(viewportInfo =>\n        viewportInfo.contains(displaySetInstanceUID, referencedImageId)\n      )?.viewportId ?? null\n    );\n  }\n}\n\nexport default CornerstoneViewportService;\n","import { imageLoader } from '@cornerstonejs/core';\nimport dicomImageLoader from '@cornerstonejs/dicom-image-loader';\nimport { api } from 'dicomweb-client';\nimport { DICOMWeb, errorHandler } from '@ohif/core';\n\nconst getImageId = imageObj => {\n  if (!imageObj) {\n    return;\n  }\n\n  return typeof imageObj.getImageId === 'function' ? imageObj.getImageId() : imageObj.url;\n};\n\nconst findImageIdOnStudies = (studies, displaySetInstanceUID) => {\n  const study = studies.find(study => {\n    const displaySet = study.displaySets.some(\n      displaySet => displaySet.displaySetInstanceUID === displaySetInstanceUID\n    );\n    return displaySet;\n  });\n  const { series = [] } = study;\n  const { instances = [] } = series[0] || {};\n  const instance = instances[0];\n\n  return getImageId(instance);\n};\n\nconst someInvalidStrings = strings => {\n  const stringsArray = Array.isArray(strings) ? strings : [strings];\n  const emptyString = string => !string;\n  let invalid = stringsArray.some(emptyString);\n  return invalid;\n};\n\nconst getImageInstance = dataset => {\n  return dataset && dataset.images && dataset.images[0];\n};\n\nconst getNonImageInstance = dataset => {\n  return dataset && dataset.instance;\n};\n\nconst getImageInstanceId = imageInstance => {\n  return getImageId(imageInstance);\n};\n\nconst fetchIt = (url, headers = DICOMWeb.getAuthorizationHeader()) => {\n  return fetch(url, headers).then(response => response.arrayBuffer());\n};\n\nconst cornerstoneRetriever = imageId => {\n  return imageLoader.loadAndCacheImage(imageId).then(image => {\n    return image && image.data && image.data.byteArray.buffer;\n  });\n};\n\nconst wadorsRetriever = (\n  url,\n  studyInstanceUID,\n  seriesInstanceUID,\n  sopInstanceUID,\n  headers = DICOMWeb.getAuthorizationHeader(),\n  errorInterceptor = errorHandler.getHTTPErrorHandler()\n) => {\n  const config = {\n    url,\n    headers,\n    errorInterceptor,\n  };\n  const dicomWeb = new api.DICOMwebClient(config);\n\n  return dicomWeb.retrieveInstance({\n    studyInstanceUID,\n    seriesInstanceUID,\n    sopInstanceUID,\n  });\n};\n\nconst getImageLoaderType = imageId => {\n  const loaderRegExp = /^\\w+\\:/;\n  const loaderType = loaderRegExp.exec(imageId);\n\n  return (\n    (loaderRegExp.lastIndex === 0 &&\n      loaderType &&\n      loaderType[0] &&\n      loaderType[0].replace(':', '')) ||\n    ''\n  );\n};\n\nclass DicomLoaderService {\n  getLocalData(dataset, studies) {\n    // Use referenced imageInstance\n    const imageInstance = getImageInstance(dataset);\n    const nonImageInstance = getNonImageInstance(dataset);\n\n    if (\n      (!imageInstance && !nonImageInstance) ||\n      !nonImageInstance.imageId?.startsWith('dicomfile')\n    ) {\n      return;\n    }\n\n    const instance = imageInstance || nonImageInstance;\n\n    let imageId = getImageInstanceId(instance);\n\n    // or Try to get it from studies\n    if (someInvalidStrings(imageId)) {\n      imageId = findImageIdOnStudies(studies, dataset.displaySetInstanceUID);\n    }\n\n    if (!someInvalidStrings(imageId)) {\n      return dicomImageLoader.wadouri.loadFileRequest(imageId);\n    }\n  }\n\n  getDataByImageType(dataset) {\n    const imageInstance = getImageInstance(dataset);\n\n    if (imageInstance) {\n      const imageId = getImageInstanceId(imageInstance);\n      let getDicomDataMethod = fetchIt;\n      const loaderType = getImageLoaderType(imageId);\n\n      switch (loaderType) {\n        case 'dicomfile':\n          getDicomDataMethod = cornerstoneRetriever.bind(this, imageId);\n          break;\n        case 'wadors':\n          const url = imageInstance.getData().wadoRoot;\n          const studyInstanceUID = imageInstance.getStudyInstanceUID();\n          const seriesInstanceUID = imageInstance.getSeriesInstanceUID();\n          const sopInstanceUID = imageInstance.getSOPInstanceUID();\n          const invalidParams = someInvalidStrings([\n            url,\n            studyInstanceUID,\n            seriesInstanceUID,\n            sopInstanceUID,\n          ]);\n          if (invalidParams) {\n            return;\n          }\n\n          getDicomDataMethod = wadorsRetriever.bind(\n            this,\n            url,\n            studyInstanceUID,\n            seriesInstanceUID,\n            sopInstanceUID\n          );\n          break;\n        case 'wadouri':\n          // Strip out the image loader specifier\n          imageId = imageId.substring(imageId.indexOf(':') + 1);\n\n          if (someInvalidStrings(imageId)) {\n            return;\n          }\n          getDicomDataMethod = fetchIt.bind(this, imageId);\n          break;\n        default:\n          throw new Error(`Unsupported image type: ${loaderType} for imageId: ${imageId}`);\n      }\n\n      return getDicomDataMethod();\n    }\n  }\n\n  getDataByDatasetType(dataset) {\n    const {\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      authorizationHeaders,\n      wadoRoot,\n      wadoUri,\n    } = dataset;\n    // Retrieve wadors or just try to fetch wadouri\n    if (!someInvalidStrings(wadoRoot)) {\n      return wadorsRetriever(\n        wadoRoot,\n        StudyInstanceUID,\n        SeriesInstanceUID,\n        SOPInstanceUID,\n        authorizationHeaders\n      );\n    } else if (!someInvalidStrings(wadoUri)) {\n      return fetchIt(wadoUri, { headers: authorizationHeaders });\n    }\n  }\n\n  *getLoaderIterator(dataset, studies, headers) {\n    yield this.getLocalData(dataset, studies);\n    yield this.getDataByImageType(dataset);\n    yield this.getDataByDatasetType(dataset);\n  }\n\n  findDicomDataPromise(dataset, studies, headers) {\n    dataset.authorizationHeaders = headers;\n    const loaderIterator = this.getLoaderIterator(dataset, studies);\n    // it returns first valid retriever method.\n    for (const loader of loaderIterator) {\n      if (loader) {\n        return loader;\n      }\n    }\n\n    // in case of no valid loader\n    throw new Error('Invalid dicom data loader');\n  }\n}\n\nconst dicomLoaderService = new DicomLoaderService();\n\nexport default dicomLoaderService;\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nexport { id };\n","export default function getHandlesFromPoints(points) {\n  if (points.longAxis && points.shortAxis) {\n    const handles = {};\n    handles.start = points.longAxis[0];\n    handles.end = points.longAxis[1];\n    handles.perpendicularStart = points.longAxis[0];\n    handles.perpendicularEnd = points.longAxis[1];\n    return handles;\n  }\n\n  return points\n    .map((p, i) => (i % 10 === 0 ? { start: p } : { end: p }))\n    .reduce((obj, item) => Object.assign(obj, { ...item }), {});\n}\n","import React from 'react';\nimport * as cornerstone from '@cornerstonejs/core';\nimport * as cornerstoneTools from '@cornerstonejs/tools';\nimport {\n  Enums as cs3DEnums,\n  imageLoadPoolManager,\n  imageRetrievalPoolManager,\n} from '@cornerstonejs/core';\nimport { Enums as cs3DToolsEnums } from '@cornerstonejs/tools';\nimport { ServicesManager, Types } from '@ohif/core';\n\nimport init from './init';\nimport getCustomizationModule from './getCustomizationModule';\nimport getCommandsModule from './commandsModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport ToolGroupService from './services/ToolGroupService';\nimport SyncGroupService from './services/SyncGroupService';\nimport SegmentationService from './services/SegmentationService';\nimport CornerstoneCacheService from './services/CornerstoneCacheService';\nimport CornerstoneViewportService from './services/ViewportService/CornerstoneViewportService';\nimport * as CornerstoneExtensionTypes from './types';\n\nimport { toolNames } from './initCornerstoneTools';\nimport { getEnabledElement, reset as enabledElementReset } from './state';\nimport dicomLoaderService from './utils/dicomLoaderService';\nimport getActiveViewportEnabledElement from './utils/getActiveViewportEnabledElement';\n\nimport { id } from './id';\nimport * as csWADOImageLoader from './initWADOImageLoader.js';\nimport { measurementMappingUtils } from './utils/measurementServiceMappings';\nimport type { PublicViewportOptions } from './services/ViewportService/Viewport';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './Viewport/OHIFCornerstoneViewport');\n});\n\nconst OHIFCornerstoneViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n *\n */\nconst cornerstoneExtension: Types.Extensions.Extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n\n  onModeExit: (): void => {\n    // Empty out the image load and retrieval pools to prevent memory leaks\n    // on the mode exits\n    Object.values(cs3DEnums.RequestType).forEach(type => {\n      imageLoadPoolManager.clearRequestStack(type);\n      imageRetrievalPoolManager.clearRequestStack(type);\n    });\n\n    enabledElementReset();\n  },\n\n  /**\n   * Register the Cornerstone 3D services and set them up for use.\n   *\n   * @param configuration.csToolsConfig - Passed directly to `initCornerstoneTools`\n   */\n  preRegistration: function (props: Types.Extensions.ExtensionParams): Promise<void> {\n    const { servicesManager } = props;\n    servicesManager.registerService(CornerstoneViewportService.REGISTRATION);\n    servicesManager.registerService(ToolGroupService.REGISTRATION);\n    servicesManager.registerService(SyncGroupService.REGISTRATION);\n    servicesManager.registerService(SegmentationService.REGISTRATION);\n    servicesManager.registerService(CornerstoneCacheService.REGISTRATION);\n\n    return init.call(this, props);\n  },\n\n  getHangingProtocolModule,\n  getViewportModule({ servicesManager, commandsManager }) {\n    const ExtendedOHIFCornerstoneViewport = props => {\n      // const onNewImageHandler = jumpData => {\n      //   commandsManager.runCommand('jumpToImage', jumpData);\n      // };\n      const { toolbarService } = (servicesManager as ServicesManager).services;\n\n      return (\n        <OHIFCornerstoneViewport\n          {...props}\n          toolbarService={toolbarService}\n          servicesManager={servicesManager}\n          commandsManager={commandsManager}\n        />\n      );\n    };\n\n    return [\n      {\n        name: 'cornerstone',\n        component: ExtendedOHIFCornerstoneViewport,\n      },\n    ];\n  },\n  getCommandsModule,\n  getCustomizationModule,\n  getUtilityModule({ servicesManager }) {\n    return [\n      {\n        name: 'common',\n        exports: {\n          getCornerstoneLibraries: () => {\n            return { cornerstone, cornerstoneTools };\n          },\n          getEnabledElement,\n          dicomLoaderService,\n        },\n      },\n      {\n        name: 'core',\n        exports: {\n          Enums: cs3DEnums,\n        },\n      },\n      {\n        name: 'tools',\n        exports: {\n          toolNames,\n          Enums: cs3DToolsEnums,\n        },\n      },\n    ];\n  },\n};\n\nexport type { PublicViewportOptions };\nexport {\n  measurementMappingUtils,\n  CornerstoneExtensionTypes as Types,\n  toolNames,\n  getActiveViewportEnabledElement,\n};\nexport default cornerstoneExtension;\n","const state = {\n  // The `defaultContext` of an extension's commandsModule\n  DEFAULT_CONTEXT: 'CORNERSTONE',\n  enabledElements: {},\n};\n\n/**\n * Sets the enabled element `dom` reference for an active viewport.\n * @param {HTMLElement} dom Active viewport element.\n * @return void\n */\nconst setEnabledElement = (viewportId: string, element: HTMLElement, context?: string): void => {\n  const targetContext = context || state.DEFAULT_CONTEXT;\n\n  state.enabledElements[viewportId] = {\n    element,\n    context: targetContext,\n  };\n};\n\n/**\n * Grabs the enabled element `dom` reference of an active viewport.\n *\n * @return {HTMLElement} Active viewport element.\n */\nconst getEnabledElement = viewportId => {\n  return state.enabledElements[viewportId];\n};\n\nconst reset = () => {\n  state.enabledElements = {};\n};\n\nexport { setEnabledElement, getEnabledElement, reset };\n","import * as cornerstone from '@cornerstonejs/core';\n\n/**\n * It checks if the imageId is provided then it uses it to query\n * the metadata and get the SOPInstanceUID, SeriesInstanceUID and StudyInstanceUID.\n * If the imageId is not provided then undefined is returned.\n * @param {string} imageId The image id of the referenced image\n * @returns\n */\nexport default function getSOPInstanceAttributes(imageId) {\n  if (imageId) {\n    return _getUIDFromImageID(imageId);\n  }\n\n  // Todo: implement for volume viewports and use the referencedSeriesInstanceUID\n}\n\nfunction _getUIDFromImageID(imageId) {\n  const instance = cornerstone.metaData.get('instance', imageId);\n\n  return {\n    SOPInstanceUID: instance.SOPInstanceUID,\n    SeriesInstanceUID: instance.SeriesInstanceUID,\n    StudyInstanceUID: instance.StudyInstanceUID,\n    frameNumber: instance.frameNumber || 1,\n  };\n}\n"],"names":["sortImageIdsAndGetSpacing","imageIds","scanAxisNormal","imagePositionPatient","referenceImagePositionPatient","metaData","refIppVec","vec3","usingWadoUri","split","sortedImageIds","zSpacing","getDistance","imageId","positionVector","prefetchedImageIds","Math","floor","length","reverse","metadataForMiddleImage","Error","distanceBetweenFirstAndMiddleImages","abs","distanceImagePairs","map","distance","sort","a","b","numImages","origin","sliceThickness","strictZSpacingForVolumeViewport","getConfiguration","rendering","console","log","createUint8SharedArray","createFloat32SharedArray","utilities","volumeId","renderingEngineAndViewportIds","renderingEnginesArray","getRenderingEngines","i","renderingEngine","viewports","id","push","viewportIds","viewport","getRenderingEngineAndViewportsContainingVolume","forEach","_ref","hasBeenDestroyed","renderViewports","scaleArray","array","scalingParameters","arrayLength","rescaleSlope","rescaleIntercept","suvbw","modality","requestType","Enums","Prefetch","getMinMax","csUtils","BaseStreamingImageVolume","ImageVolume","constructor","imageVolumeProperties","streamingProperties","_this","super","this","framesLoaded","framesProcessed","cornerstoneImageMetaData","cancelLoading","loadStatus","loading","cancelled","clearLoadCallbacks","imageLoadPoolManager","filterRequests","additionalDetails","load","callback","priority","arguments","undefined","numFrames","loaded","totalNumFrames","success","callbacks","_prefetchImageIds","getImageIdsRequests","scalarData","cachedFrames","vtkOpenGLTexture","imageData","metadata","FrameOfReferenceUID","arrayBuffer","buffer","lengthInBytes","byteLength","type","Uint8Array","Float32Array","Uint16Array","Int16Array","autoRenderOnLoad","reRenderFraction","reRenderTarget","callLoadStatusCallback","evt","autoLoad","eventDetail","triggerEvent","eventTarget","IMAGE_VOLUME_LOADING_COMPLETED","updateTextureAndTriggerEvents","volume","imageIdIndex","frameIndex","_imageIdIndexToFrameIndex","setUpdatedFrame","modified","imageVolume","IMAGE_VOLUME_MODIFIED","successCallback","cachedImage","cache","getCachedImageBasedOnImageURI","cachedVolume","getVolumeContainingImageId","warn","image","isFromImageCache","cachedImageOrVolume","handleImageComingFromCache","errorCallback","error","IMAGE_LOAD_ERROR","requests","getImageIdIndex","modalityLutModule","generalSeriesModule","suvFactor","_addScalingToVolume","isSlopeAndInterceptNumbers","isPreScaled","callLoadImage","options","imageLoader","then","ArrayBuffer","offset","targetBuffer","pixelData","getPixelData","bytesInFloat","floatView","set","bytesInInt16","intView","bytesInUint16","bytesInUint8","e","handleArrayBufferLoad","call","skipCreateImage","preScale","enabled","_getNumFrames","_createCornerstoneImageMetaData","scalarDataCount","isDynamicVolume","_getScalarDataLength","bytesPerImage","sizeInBytes","numComponents","numVoxels","pixelsPerImage","dimensions","PhotometricInterpretation","voiLut","VOILUTFunction","windowCenter","windowWidth","voi","color","rgba","spacing","photometricInterpretation","voiLUTFunction","invert","getScalarDataArrays","_getScalarDataByImageIdIndex","invalidateVolume","immediate","imageLoadObject","convertToCornerstoneImage","promise","imageScalarData","_scaleIfNecessary","TypedArray","byteOffset","bytePerPixel","BYTES_PER_ELEMENT","catch","err","getImageLoadRequests","_priority","request","addRequest","bind","scalingParametersToUse","imageIsAlreadyScaled","scaled","noScalingParametersToUse","slice","rescaleSlopeToUse","rescaleInterceptToUse","suvbwToUse","rescaleSlopeUsed","rescaleInterceptUsed","suvbwUsed","newSuvbw","newRescaleSlope","newRescaleIntercept","scaling","suvlbm","suvbsa","petScaling","suvbwToSuvlbm","suvbwToSuvbsa","PT","_removeFromCache","removeVolumeLoadObject","getCornerstoneImage","volumeBuffer","volumeBufferView","volumeImageId","minMax","intercept","numComps","rows","columns","minPixelValue","min","maxPixelValue","max","slope","getCanvas","height","width","columnPixelSpacing","rowPixelSpacing","getCornerstoneImageLoadObject","Promise","resolve","getCornerstoneImages","_convertToImages","bytesRemaining","decacheIfNecessaryUntilBytesAvailable","getImageLoadObject","putImageLoadObject","decache","StreamingImageVolume","getScalarData","createUint16SharedArray","createInt16SharedArray","useNorm16Texture","preferSizeOverAccuracy","use16BitDataType","streamingImageVolumePromise","async","middleImageIndex","lastImageIndex","indexesToPrefetch","all","index","reject","volumeMetadata","imageId0","pixelRepresentation","bitsAllocated","bitsStored","highBit","samplesPerPixel","voiLutModule","Array","isArray","seriesInstanceUID","imageOrientationPatient","pixelSpacing","frameOfReferenceUID","BitsAllocated","BitsStored","SamplesPerPixel","HighBit","PixelRepresentation","Modality","ImageOrientationPatient","PixelSpacing","Columns","Rows","SeriesInstanceUID","makeVolumeMetadata","hasNegativeRescale","hasFloatRescale","rowCosineVec","colCosineVec","direction","signed","useSharedArrayBuffer","getShouldUseSharedArrayBuffer","handleCache","isCacheable","CACHE_SIZE_EXCEEDED","getStreamingImageVolume","streamingImageVolume","destroy","cancel","registerVolumeLoader","volumeLoader","initialized","initWADOImageLoader","userAuthenticationService","appConfig","extensionManager","dicomImageLoader","cornerstone","dicomParser","cornerstoneStreamingImageVolumeLoader","decodeConfig","convertFloatPixelDataToInt","Boolean","beforeSend","xhr","sourceConfig","getActiveDataSource","getConfig","headers","getAuthorizationHeader","xhrRequestHeaders","Accept","utils","generateAcceptHeader","acceptHeader","requestTransferSyntaxUID","omitQuotationForMultipartRequest","Object","assign","errorInterceptor","errorHandler","getHTTPErrorHandler","config","maxWebWorkers","navigator","hardwareConcurrency","maxNumberOfWebWorkers","startWebWorkersOnDemand","taskConfiguration","decodeTask","initializeCodecsOnStartup","usePDFJS","strict","initialize","initWebWorkers","uiDialogService","data","dialogConfig","dialogId","label","text","dialogTitle","inputLabel","validateFunc","value","onSubmitHandler","action","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","title","noCloseButton","onClose","actions","ButtonEnums","secondary","primary","onSubmit","body","_ref2","setValue","React","Input","autoFocus","className","labelClassName","onChange","event","persist","target","onKeyPress","key","getActiveViewportEnabledElement","viewportGridService","activeViewportId","getState","element","OHIFgetEnabledElement","getEnabledElement","calibrateImageSpacing","CalibrationLineTool","LengthTool","_renderingViewport","_lengthToolRenderAnnotation","renderAnnotation","enabledElement","svgDrawingHelper","_getTextLines","targetId","canvasPoint1","canvasPoint2","handles","points","p","worldToCanvas","round","point1","point2","dx","dy","sqrt","calculateLength2","toolName","onCompletedCalibrationLine","servicesManager","csToolsEvent","services","annotationAddedEventDetail","detail","annotation","annotationData","referencedImageId","pos1","pos2","dz","calculateLength3","calibratedPixelSpacing","imagePlaneModule","callInputDialog","newLength","spacingScale","getRenderingEngine","scale","adjustCalibration","Number","parseFloat","val","v","isNaN","ImageOverlayViewerTool","AnnotationDisplayTool","supportedInteractionTypes","configuration","fillColor","_cachedOverlayMetadata","Map","_cachedStats","onSetToolDisabled","getReferencedImageId","overlays","get","_getCachedStat","cachedStat","overlay","_renderOverlay","VolumeViewport","getTargetId","overlayData","_id","x","y","overlayTopLeftWorldPos","overlayTopLeftOnCanvas","overlayBottomRightWorldPos","overlayBottomRightOnCanvas","svgNodeHash","existingImageElement","getSvgNode","attributes","href","dataUrl","drawing","setNodeTouched","newImageElement","document","createElementNS","appendNode","overlayMetadata","_isSameColor","filter","idx","Value","retrieveBulkData","_renderOverlayToDataUrl","guid","color1","color2","pixelDataRaw","pixelDataView","DataView","totalBits","canvas","createElement","ctx","getContext","clearRect","globalCompositeOperation","getImageData","bitIdx","byteIdx","getUint8","putImageData","toDataURL","toolNames","Pan","PanTool","ArrowAnnotate","ArrowAnnotateTool","WindowLevel","WindowLevelTool","StackScroll","StackScrollTool","StackScrollMouseWheel","StackScrollMouseWheelTool","Zoom","ZoomTool","VolumeRotateMouseWheel","VolumeRotateMouseWheelTool","MipJumpToClick","MIPJumpToClickTool","Length","DragProbe","DragProbeTool","Probe","ProbeTool","RectangleROI","RectangleROITool","EllipticalROI","EllipticalROITool","CircleROI","CircleROITool","Bidirectional","BidirectionalTool","Angle","AngleTool","CobbAngle","CobbAngleTool","PlanarFreehandROI","PlanarFreehandROITool","Magnify","MagnifyTool","Crosshairs","CrosshairsTool","SegmentationDisplay","SegmentationDisplayTool","ReferenceLines","ReferenceLinesTool","CalibrationLine","TrackballRotateTool","CircleScissors","CircleScissorsTool","RectangleScissors","RectangleScissorsTool","SphereScissors","SphereScissorsTool","ImageOverlayViewer","toAnnotation","measurement","toMeasurement","csToolsEventDetail","displaySetService","cornerstoneViewportService","getValueTypeFromToolType","viewportId","annotationUID","SUPPORTED_TOOLS","includes","SOPInstanceUID","StudyInstanceUID","getSOPInstanceAttributes","displaySet","getDisplaySetForSOPInstanceUID","getDisplaySetsForSeries","mappedAnnotations","cachedStats","keys","annotations","targetStats","frameNumber","SeriesNumber","unit","getMappedAnnotations","displayText","instance","images","find","InstanceNumber","instanceText","frameText","isMultiFrame","roundedLength","roundNumber","getDisplayText","uid","referenceSeriesUID","referenceStudyUID","displaySetInstanceUID","getReport","values","join","_getReport","referencedSeriesInstanceUID","roundedWidth","mean","stdDev","area","areaUnit","modalityUnit","roundedArea","mappedAnnotation","maxStr","str","DisplaySetService","CornerstoneViewportService","angle","roundedAngle","_SOPInstanceUID","_SeriesInstanceUID","measurementServiceMappingsFactory","measurementService","_getValueTypeFromToolType","toolType","POLYLINE","ELLIPSE","CIRCLE","RECTANGLE","BIDIRECTIONAL","POINT","ANGLE","MeasurementService","VALUE_TYPES","csToolsAnnotation","matchingCriteria","valueType","removeAnnotation","csToolsEvents","CORNERSTONE_3D_TOOLS_SOURCE_NAME","connectToolsToMeasurementService","csTools3DVer1MeasurementSource","initMeasurementService","createSource","addMapping","connectMeasurementServiceToTools","annotationToMeasurement","remove","addMeasurement","completedEvt","finally","removeMeasurement","resize","annotationRemovedEventDetail","getMeasurement","addedEvt","ANNOTATION_ADDED","ANNOTATION_COMPLETED","updatedEvt","ANNOTATION_MODIFIED","removedEvt","ANNOTATION_REMOVED","selectionEvt","ANNOTATION_SELECTION_CHANGE","addEventListener","annotationModifiedEventDetail","annotationSelectionEventDetail","added","addedSelectedAnnotationUIDs","removed","removedSelectedAnnotationUIDs","setMeasurementSelected","measurementSource","MEASUREMENT_REMOVED","MEASUREMENTS_CLEARED","MEASUREMENT_UPDATED","RAW_MEASUREMENT_ADDED","EVENTS","getSource","subscribe","measurements","source","name","notYetUpdatedAtSource","sourceAnnotation","_ref3","dataSource","DicomMetadataStore","getInstance","getImageIdsForInstance","addAnnotation","highlighted","isLocked","invalidated","_ref4","removedMeasurementId","render","cineService","setServiceImplementation","playClip","playClipOptions","stopClip","volumeIdMapsToLoad","viewportIdVolumeInputArrayMap","interleaveCenterLoader","volumeInputArray","displaySetsMatchDetails","viewportMatchDetails","matchDetails","volumeInput","getVolume","has","size","_","details","entries","from","volumes","AllRequests","reOrderedRequests","maxImageIdIndex","middleImageIdIndex","lowerImageIdIndex","upperImageIdIndex","imageIdsToPrefetch","prefetchQueuedFilled","currentPositionDownToMinimum","currentPositionUpToMaximum","getInterleavedFrames","req","interleavedRequests","compact","flatten","zip","finalRequests","volumeRequests","volumeImageIdRequest","callLoadImageBound","clear","viewportIdVolumeInputArrayMapCopy","interleaveNthLoader","lists","time","useLists","ret","list","splice","indexOf","timeEnd","interleave","frames","centerStart","centerEnd","getNthFrames","interleaveTopToBottom","findNearbyToolData","commandsManager","currentPoints","runCommand","canvasCoordinates","cs3DToolsEvents","DEFAULT_CONTEXT_MENU_CLICKS","button1","commands","commandName","button3","commandOptions","requireNearbyToolData","menuId","customizationService","cornerstoneViewportHandleClick","button","which","nameArr","altKey","ctrlKey","shiftKey","getEventName","cornerstoneViewportHandleEvent","toRun","nearbyToolData","some","command","run","ELEMENT_ENABLED","getViewportInfo","setEnabledElement","MOUSE_CLICK","ELEMENT_DISABLED","removeEventListener","DEFAULT_DOUBLE_CLICK","doubleClick","cornerstoneViewportHandleDoubleClick","eventName","getDoubleClickEventName","MOUSE_DOUBLE_CLICK","init","csEnums","AUTO","FALSE","TRUE","cs3DInit","useCPURendering","maxCacheSize","setMaxCacheSize","isAnnotation","addTool","defaultStyles","getDefaultToolStyles","setDefaultToolStyles","global","textBoxFontSize","lineWidth","initCornerstoneTools","Settings","getRuntimeSettings","useCursors","uiModalService","uiNotificationService","hangingProtocolService","toolGroupService","stateSyncService","window","showWarningMessageForCrossOrigin","crossOriginIsolated","show","message","showCPUFallbackMessage","progress","CPUModal","unsubscribe","PROTOCOL_CHANGED","_showCPURenderingModal","register","clearOnModeExit","labelmapRepresentation","cornerstoneTools","Labelmap","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","metadataProvider","OHIF","MetadataProvider","registerImageLoadStrategy","nthLoader","csUtilities","maxNumRequests","interaction","thumbnail","prefetch","measurementServiceSource","initCineService","CUSTOM_IMAGE_LOAD_PERFORMED","volumeInputArrayMap","entry","getCornerstoneViewport","ohifViewport","lutPresentationStore","positionPresentationStore","presentationIds","getViewportOptions","presentations","positionPresentation","positionPresentationId","lutPresentation","lutPresentationId","setVolumesForViewport","initContextMenu","initDoubleClick","newStackCallback","enable","resetCrosshairs","renderingEngineId","toolGroup","_toolInstances","mode","Active","setToolActive","Passive","setToolPassive","Enabled","setToolEnabled","CAMERA_RESET","STACK_VIEWPORT_NEW_STACK","ACTIVE_VIEWPORT_ID_CHANGED","getToolGroupForViewport","setToolConfiguration","sourceViewportId","PROGRESS","UploadStatus","UploadRejection","status","DicomFileUploader","PubSubService","file","_file","_fileId","_dataSource","_loadPromise","_abortController","AbortController","_status","NotStarted","_percentComplete","fileManager","add","getFileId","getFileName","getFileSize","abort","getStatus","getPercentComplete","uploadCallbacks","lengthComputable","InProgress","total","_broadcastEvent","fileId","percentComplete","timeout","_reject","Failed","Cancelled","loadFileRequest","dicomFile","signal","aborted","_checkDicomFile","XMLHttpRequest","_addRequestCallbacks","store","dicom","Success","reason","_isRejected","abortCallback","upload","cleanUpCallback","arr","every","char","charCodeAt","DicomUploadProgressItem","memo","dicomFileUploader","setPercentComplete","useState","failedReason","setFailedReason","setStatus","isComplete","useCallback","useEffect","progressSubscription","dicomFileUploaderProgressEvent","cancelUpload","getStatusIcon","Icon","onClick","propTypes","PropTypes","isRequired","ONE_SECOND","ONE_MINUTE","ONE_HOUR","BASE_INTERVAL_TIME","NO_WRAP_ELLIPSIS_CLASS_NAMES","DicomUploadProgress","dicomFileUploaderArr","onComplete","totalUploadSize","reduce","acc","fileUploader","currentUploadSizeRef","useRef","uploadRateRef","timeRemaining","setTimeRemaining","numFilesCompleted","setNumFilesCompleted","numFails","setNumFails","showFailedOnly","setShowFailedOnly","progressBarContainerRef","timeoutId","intervalStartUploadSize","intervalStartTime","Date","now","setUploadRateRef","uploadSizeFromStartOfInterval","current","timeSinceStartOfInterval","setTimeout","clearTimeout","currentTimeRemaining","subscriptions","currentFileUploadSize","updateProgress","previousFileUploadSize","uploadSizeRemaining","currentSecondsRemaining","ceil","delta","currentMinutesRemaining","rejection","numCompleted","progressEvent","subscription","cancelAllUploads","getFormattedTimeRemaining","secondsRemaining","minutesRemaining","hoursRemaining","getPercentCompleteRounded","showInfiniteProgressBar","offsetWidth","getNofMFilesStyle","toString","getShowFailedOnlyIconComponent","currentShowFailedOnly","Button","disabled","style","classNames","ref","ProgressLoadingBar","DicomUpload","onStarted","baseClassNames","setDicomFileUploaderArr","onDrop","acceptedFiles","Dropzone","noClick","getRootProps","_extends","noDrag","getInputProps","webkitdirectory","mozdirectory","tools","active","bindings","mouseButton","Primary","Auxiliary","Secondary","component","DEFAULT_SIZE","MAX_TEXTURE_SIZE","VIEWPORT_ID","CornerstoneViewportDownloadForm","activeViewportIdProp","activeViewportElement","activeViewportEnabledElement","ToolGroupManager","toolModeAndBindings","toolOptions","tool","setToolMode","ViewportDownloadForm","minimumSize","maximumSize","defaultSize","canvasClass","enableViewport","viewportElement","viewportInput","defaultOptions","background","orientation","enableElement","disableViewport","disableElement","updateViewportPreview","downloadViewportElement","internalCanvas","fileType","downloadViewport","IMAGE_RENDERED","updateViewport","downloadCanvas","getOrCreateCanvas","newWidth","offsetHeight","newHeight","multiplier","loadImage","getViewport","StackViewport","getCurrentImageId","properties","getProperties","setStack","setProperties","getActors","actor","addActor","setCamera","getCamera","toggleAnnotations","toggle","downloadViewportId","addViewport","setToolDisabled","downloadBlob","filename","divForDownloadViewport","querySelector","html2canvas","link","download","click","_getViewportPairs","viewportPairs","j","STACK_IMAGE_SYNC_GROUPS_INFO","toggleStackImageSync","toggledState","syncGroupService","syncGroupInfo","synchronizerId","removeViewportFromSyncGroup","viewportsByOrientation","displaySetInstanceUIDs","getDisplaySetByUID","isReconstructable","viewportType","viewportOptions","csViewport","viewPlaneNormal","nextViewport","renderingEngine1","renderingEngine2","csViewport1","csViewport2","calculateViewportRegistrations","addViewportToSyncGroup","isAnnotationSelected","cs3dToolAnnotationUtils","setAnnotationSelected","selected","getFirstAnnotationSelected","selectedAnnotationUID","toolbarService","_getActiveViewportEnabledElement","showCornerstoneContextMenu","optionsToUse","useSelectedAnnotation","firstAnnotationSelected","allowedSelectedTools","defaultPointsPosition","selectorProps","getNearbyToolData","cstUtils","getNearbyAnnotation","toolInstance","getToolInstance","deleteMeasurement","setMeasurementLabel","_ref5","actionId","updatedMeasurement","update","updateMeasurement","props","code","textLabel","measurementKey","CodeValue","substring","CodeMeaning","CodingSchemeDesignator","findingSites","it","setViewportActive","_ref6","setActiveViewportId","arrowTextCallback","_ref7","toggleCine","isCineEnabled","setIsCineEnabled","setButton","isActive","setCine","isPlaying","setWindowLevel","_ref8","level","toolGroupId","windowWidthNum","windowCenterNum","viewportToolGroupId","lower","upper","voiRange","toolbarServiceRecordInteraction","recordInteraction","_ref9","getToolGroup","duration","toolGroupViewportIds","getViewportIds","activeToolName","getActivePrimaryMouseButtonTool","showDownloadViewportModal","hide","rotateViewport","_ref10","rotation","currentRotation","newRotation","flipViewportHorizontal","flipHorizontal","flipViewportVertical","flipVertical","invertViewport","_ref11","resetViewport","resetProperties","resetCamera","scaleViewport","_ref12","scaleFactor","parallelScale","jumpToImage","_ref13","imageIndex","gridViewport","numberOfSlices","getImageIds","jumpIndex","scroll","_ref14","setViewportColormap","_ref15","colormap","actorEntry","volumeActor","changeActiveViewport","_ref16","nextViewportIndex","_ref17","setSourceViewportForReferenceLinesTool","_ref18","getViewportId","storePresentation","_ref19","definitions","commandFn","storeContexts","menuCustomizationId","rotateViewportCW","rotateViewportCCW","incrementActiveViewport","decrementActiveViewport","scaleUpViewport","scaleDownViewport","fitViewportToWindow","nextImage","previousImage","firstImage","lastImage","defaultContext","mpr","locked","createdDate","modifiedDate","availableTo","editableBy","numberOfPriorsReferenced","protocolMatchingRules","imageLoadStrategy","onLayoutChange","protocolId","context","onProtocolExit","interactionType","displaySetSelectors","activeDisplaySet","seriesMatchingRules","weight","attribute","constraint","equals","required","stages","viewportStructure","layoutType","layoutOptions","initialImageOptions","preset","syncGroups","displaySets","mprAnd3DVolumeViewport","mprDisplaySet","customViewportProps","hideOverlays","displayPreset","protocol","VIEWPORT_ADDED","TOOLGROUP_CREATED","ToolGroupService","serviceManager","toolGroupIds","Set","listeners","pubSubServiceInterface","onModeExit","toolGroupIdToUse","getToolGroupIds","getActiveToolForViewport","destroyToolGroup","delete","removeViewportFromToolGroup","deleteToolGroupIfEmpty","removeViewports","addViewportToToolGroup","createToolGroup","addToolsToToolGroup","configs","_addTools","_setToolsMode","createToolGroupAndAddTools","getToolConfiguration","passive","addTools","parentTool","addToolInstance","REGISTRATION","altName","TOOL_GROUP_CREATED","SyncGroupService","synchronizerCreators","synchronizers","_createSynchronizer","syncCreator","toLowerCase","addSynchronizerType","creator","_getOrCreateSynchronizer","synchronizer","SynchronizerManager","syncGroup","syncGroupObj","asSyncGroup","setOptions","viewportInfo","addSource","addTarget","syncGroupId","s","sourceViewports","getSourceViewports","targetViewports","getTargetViewports","easeInOutBell","baseline","alpha","pow","COLOR_LUT","cstConstants","LABELMAP","csToolsEnums","CONTOUR","Contour","SEGMENTATION_UPDATED","SEGMENTATION_DATA_MODIFIED","SEGMENTATION_ADDED","SEGMENTATION_REMOVED","SEGMENTATION_CONFIGURATION_CHANGED","SEGMENT_LOADING_COMPLETE","SEGMENTATION_LOADING_COMPLETE","SEGMENT_CONSTANT","opacity","isVisible","SegmentationService","segmentations","highlightIntervalId","SEGMENTATION_MODIFIED","_onSegmentationModifiedFromSource","_onSegmentationDataModified","segmentationId","_removeSegmentationFromCornerstone","setSegmentRGBA","segmentIndex","rgbaColor","segmentation","getSegmentation","_setSegmentOpacity","_setSegmentColor","calculateCentroids","getLabelmapVolume","dimX","dimY","frameLength","segmentIndices","segments","segment","segmentIndicesSet","centroids","z","count","voxelIndex","frame","centroid","result","normalizedCentroid","world","indexToWorld","setCentroids","segmentCenter","center","addOrUpdateSegmentation","createSegmentationForDisplaySet","representationType","_getVolumeIdForDisplaySet","sharedArrayBuffer","_getDefaultSegmentationScheme","instances","representationData","referencedVolumeId","toggleSegmentationVisibility","_toggleSegmentationVisibility","addSegmentationRepresentationToToolGroup","hydrateSegmentation","suppressEvents","hydrated","colorLUTIndex","segmentationRepresentationUIDs","cstSegmentation","_setActiveSegmentationForToolGroup","visibility","_setSegmentVisibility","_setSegmentLocked","setSegmentRGBAColor","getToolGroupIdsWithSegmentation","_setDisplaySetIsHydrated","_getFirstToolGroupId","segmentationRepresentations","getSegmentationRepresentationsForToolGroup","typeToUse","renderInactiveSegmentations","representation","representations","renderOutline","outlineWidthActive","renderFill","brushSize","brushThresholdGate","setConfiguration","setConfigValueIfDefined","transformFn","transformedValue","_setSegmentationConfig","_updateCornerstoneSegmentationVisibility","segmentInfo","_getSegmentInfo","segmentationRepresentation","_getSegmentationRepresentation","segmentationRepresentationUID","property","getSegmentations","segmentationState","activeSegmentIndex","segmentsLocked","segmentationSchema","segmentsHidden","newVisibility","_getSegmentationInfo","getNextColorLUTIndex","arrayOfObjects","obj","_initSegmentationService","addSegment","segmentCount","_setActiveSegment","newColor","removeSegment","labelmapVolume","modifiedFrames","modifiedFramesArray","newActiveSegmentIndex","setSegmentVisibility","setSegmentLocked","toggleSegmentLocked","setSegmentColor","setSegmentOpacity","setActiveSegmentationForToolGroup","setActiveSegment","filterNonHydratedSegmentations","_getSegmentations","m","cachedSegmentation","_updateCornerstoneSegmentations","newColorLUT","generateNewColorLUT","createSegmentationForSEGDisplaySet","segDisplaySet","SeriesDescription","labelmap","labelmapBufferArray","derivedVolume","derivedVolumeScalarData","segmentsInfo","segMetadata","SegmentedPropertyCategoryCodeSequence","SegmentNumber","SegmentLabel","SegmentAlgorithmType","SegmentAlgorithmName","SegmentedPropertyTypeCodeSequence","centerWorld","modifiedTime","SeriesDate","category","algorithmType","algorithmName","isLoaded","createSegmentationForRTDisplaySet","rtDisplaySet","structureSet","defaultScheme","rtDisplaySetUID","allRTStructData","ROIContours","contourPoints","ROINumber","ROIName","colorArray","rest","geometryId","mapROIContoursToRTStructData","geometryIds","segmentsCachedStats","initializeContour","rtStructData","geometry","geometryLoader","geometryData","getCentroid","numInitialized","numSegments","promiseArray","jumpToSegmentCenter","highlightAlpha","highlightSegment","animationLength","highlightHideOthers","highlightFunctionType","_getSegmentCenter","_getToolGroupIdsWithSegmentation","toolGroups","viewportsInfo","getViewportsInfo","getEnabledElementByIds","hideOthers","clearInterval","_highlightLabelmap","_highlightContour","displaySetUID","isHydrated","setDisplaySetMetadataInvalidated","newSegmentSpecificConfig","startTime","animation","timestamp","elapsed","requestAnimationFrame","performance","animate","currentTime","reversedProgress","removeSegmentationRepresentationFromToolGroup","segmentationRepresentationUIDsIds","uids","rep","wasActive","remainingHydratedSegmentations","setSegmentLabel","_setSegmentLabel","shouldRenderSegmentation","viewportDisplaySetInstanceUIDs","segmentationFrameOfReferenceUID","shouldDisplaySeg","targetSegmentation","volumeLoaderSchema","segmentLabel","getSegmentationRepresentations","UIDsToRemove","removeSegmentation","getVolumeLoadObject","sourceSegmentation","isEqual","_getFrameOfReferenceUIDForSeg","referencedFrameOfReferenceSequence","ReferencedFrameOfReferenceSequence","cloneDeep","getCornerstoneViewportType","lowerViewportType","STACK","ORTHOGRAPHIC","VOLUME_3D","VOLUME_LOADER_SCHEME","CornerstoneCacheService","stackImageIds","volumeImageIds","getCacheSize","cs3DCache","getCacheFreeSpace","getBytesAvailable","createViewportData","initialImageIndex","_shouldRenderSegmentation","cs3DViewportType","viewportData","_getStackViewportData","_getVolumeViewportData","invalidateViewportData","invalidatedDisplaySetInstanceUID","_getCornerstoneStackImageIds","isCompositeStack","StackViewportData","volumeData","Function","studyInstanceUID","_getCornerstoneVolumeImageIds","segmentationService","segDisplaySetInstanceUID","getImageIdsForDisplaySet","RENDERING_ENGINE_ID","DEFAULT_TOOLGROUP_ID","dataContains","dataId","displaySetOptions","setPublicViewportOptions","setPublicDisplaySetOptions","contains","setRenderingEngineId","getRenderingEngineId","setViewportId","setElement","setViewportData","getViewportData","getElement","publicDisplaySetOptions","mapDisplaySetOptions","setDisplaySetOptions","hasDisplaySet","dsUID","viewportOptionsEntry","AXIAL","SAGITTAL","CORONAL","ACQUISITION","getCornerstoneOrientation","setViewportOptions","getSyncGroups","getDisplaySetOptions","getViewportType","getToolGroupId","getBackground","getOrientation","getInitialImageOptions","item","option","blendMode","slabThickness","voiInverted","COMPOSITE","MAXIMUM_INTENSITY_BLEND","getCornerstoneBlendMode","JumpPresets","VIEWPORT_DATA_CHANGED","viewportsById","viewportGridResizeObserver","viewportsDisplaySets","enableResizeDetector","resizeRefreshRateMs","resizeRefreshMode","elementRef","ViewportInfo","RenderingEngine","_removeResizeObserver","purgeCache","setPresentations","camera","getPresentation","isComputedVOI","getCurrentImageIdIndex","presentation","storeState","publicViewportOptions","_setDisplaySets","_setStackViewport","initialImageIndexToUse","_getInitialImageIndexForViewport","imageSliceData","_getInitialImageIndex","lastSliceIndex","csToolsUtils","First","Last","Middle","_setVolumeViewport","displaySetOptionsArray","volumeToLoad","_getSlabThickness","getShouldPerformCustomImageLoad","runImageLoadStrategy","volumesProperties","displaySetOption","setVolumes","overlayDisplaySet","isOverlayDisplaySet","addOverlayRepresentationForDisplaySet","_addSegmentationRepresentationToToolGroupIfNecessary","segFrameOfReferenceUID","_getFrameOfReferenceUID","keepCamera","viewportCamera","VolumeViewport3D","disconnect","getViewportIdToJump","cameraProps","getImageId","imageObj","url","someInvalidStrings","strings","string","getImageInstance","dataset","getImageInstanceId","imageInstance","fetchIt","DICOMWeb","fetch","response","cornerstoneRetriever","byteArray","wadorsRetriever","sopInstanceUID","api","DICOMwebClient","retrieveInstance","getLocalData","studies","nonImageInstance","getNonImageInstance","startsWith","findImageIdOnStudies","study","series","getDataByImageType","getDicomDataMethod","loaderType","loaderRegExp","exec","lastIndex","replace","getImageLoaderType","getData","wadoRoot","getStudyInstanceUID","getSeriesInstanceUID","getSOPInstanceUID","getDataByDatasetType","authorizationHeaders","wadoUri","getLoaderIterator","findDicomDataPromise","loaderIterator","loader","packageJson","getHandlesFromPoints","longAxis","shortAxis","start","end","perpendicularStart","perpendicularEnd","Component","OHIFCornerstoneViewport","fallback","cs3DEnums","clearRequestStack","imageRetrievalPoolManager","enabledElementReset","preRegistration","registerService","getHangingProtocolModule","getViewportModule","getCommandsModule","getCustomizationModule","getUtilityModule","exports","getCornerstoneLibraries","dicomLoaderService","cs3DToolsEnums","state","DEFAULT_CONTEXT","enabledElements","targetContext","reset","_getUIDFromImageID"],"sourceRoot":""}