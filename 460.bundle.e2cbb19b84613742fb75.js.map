{"version":3,"file":"460.bundle.e2cbb19b84613742fb75.js","mappings":"64TAMKA,EAiBAC,GCpBAC,G,aDGL,SAAKF,GAEHA,EAAAA,EAAA,qBAEAA,EAAAA,EAAA,yBACAA,EAAAA,EAAA,iDAEAA,EAAAA,EAAA,yBACAA,EAAAA,EAAA,iDACAA,EAAAA,EAAA,qDACAA,EAAAA,EAAA,6EAEAA,EAAAA,EAAA,iCAEAA,EAAAA,EAAA,+BACD,CAfD,CAAKA,IAAAA,EAAa,KAiBlB,SAAKC,GACHA,EAAAA,EAAA,kBACAA,EAAAA,EAAA,gBACAA,EAAAA,EAAA,cACAA,EAAAA,EAAA,gBACAA,EAAAA,EAAA,4BACAA,EAAAA,EAAA,0BACAA,EAAAA,EAAA,4BACAA,EAAAA,EAAA,wBACAA,EAAAA,EAAA,0BACAA,EAAAA,EAAA,uBACD,CAXD,CAAKA,KAAAA,GAAgB,KCpBrB,SAAKC,GAQHA,EAAA,gBAMAA,EAAA,kBAKAA,EAAA,kBAKAA,EAAA,mBACD,CAzBD,CAAKA,KAAAA,GAAS,KA2Bd,YChBA,IAAKC,IAAL,SAAKA,GACHA,EAAA,WACAA,EAAA,0BACAA,EAAA,oBACAA,EAAA,eACD,CALD,CAAKA,KAAAA,GAAqB,KAO1B,YCfA,IAAKC,IAAL,SAAKA,GAYHA,EAAA,kDASAA,EAAA,wDAaAA,EAAA,sDAQAA,EAAA,8DAQAA,EAAA,4DAQAA,EAAA,0DAQAA,EAAA,4EAQAA,EAAA,kEAQAA,EAAA,8EAQAA,EAAA,4DAYAA,EAAA,gEAQAA,EAAA,gEAQAA,EAAA,8FAQAA,EAAA,8DAQAA,EAAA,4FAQAA,EAAA,0EAYAA,EAAA,sCAQAA,EAAA,kCAYAA,EAAA,0CAQAA,EAAA,sCASAA,EAAA,4DAQAA,EAAA,0CAUAA,EAAA,0CAQAA,EAAA,4CAQAA,EAAA,0DAQAA,EAAA,4CAeAA,EAAA,4CACAA,EAAA,8DACAA,EAAA,4CACAA,EAAA,0CACAA,EAAA,wCACAA,EAAA,kCACAA,EAAA,qCACD,CA/PD,CAAKA,KAAAA,GAAM,KAiQX,YClQA,IAAKC,IAAL,SAAKA,GACHA,EAAA,oBACAA,EAAA,kBACAA,EAAA,iBACD,CAJD,CAAKA,KAAAA,GAA2B,KAMhC,YCXA,IAAKC,IAAL,SAAKA,GACHA,EAAA,QACAA,EAAA,YACAA,EAAA,YACAA,EAAA,aACD,CALD,CAAKA,KAAAA,GAAK,K,2BCQV,MAAMC,GAA8C,IAAIC,IAiBxD,SAASC,GAAoBC,GAAqC,IAAbC,IAAMC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACzD,MAAMG,EAASC,KACXN,IACEC,EA+ER,SACED,EACAO,EACAF,GAEKE,EAAqBC,IAAIR,KAC5BO,EAAqBE,IAAIT,GACzBK,EAAOK,MAAMC,KAAKX,GAEtB,CAvFMY,CAAKZ,EAAYH,GAA4BQ,GAE7CQ,GAAOb,EAAYH,GAA4BQ,IAGnDS,GAAQT,EAAQR,GAClB,CAMA,SAASkB,KACP,MAAMV,EAASC,MAsFjB,SACEC,EACAF,GAEAE,EAAqBS,SAAShB,IAC5Ba,GAAOb,EAAYO,EAAsBF,EAAO,GAEpD,CA5FEY,CAA0BpB,GAA4BQ,GACtDS,GAAQT,EAAQR,GAClB,CAOA,SAASqB,KACP,OAAOC,MAAMC,KAAKvB,GACpB,CAOA,SAASwB,GAAmBrB,GAC1B,OAAOH,GAA2BW,IAAIR,EACxC,CAQA,SAASsB,KACP,OAAOzB,GAA2B0B,IACpC,CAOA,SAASC,GAA+BxB,GACtC,GAAIA,EAAY,CACd,MAAMyB,IAAazB,EAAWyB,UAiElC,SAAsCzB,GACpC,MAAM0B,EAAaC,OAAOC,yBAAyB5B,EAAY,YAC/D,GAAI0B,EACF,OACEA,EAAWG,eACVH,EAAWI,MAAQC,IAAeL,EAAWM,MAAQC,IAG1D,OAAON,OAAOO,aAAalC,EAC7B,EAzEQmC,CAA6BnC,IAC/B2B,OAAOS,eAAepC,EAAY,WAAY,CAC5C6B,cAAc,EACdQ,YAAY,EACZP,IAAKC,GACLC,IAAKC,KAGTlC,GAAoBC,EAAYyB,E,CAEpC,CAMA,SAASnB,KACP,OAAOqB,OAAOW,OAAO,CACnB5B,MAAO,GACP6B,QAAS,GACTtC,OAAQ,IAEZ,CAaA,SAASY,GACPb,EACAO,EACAF,GAEIE,EAAqBiC,OAAOxC,IAC9BK,EAAOkC,QAAQ5B,KAAKX,EAExB,CAWA,SAASc,GACPT,EACAE,IAEIF,EAAOK,MAAMP,OAAS,GAAKE,EAAOkC,QAAQpC,OAAS,KACrDI,EAAqBS,SAASyB,IAAcpC,EAAOJ,OAAOU,KAAK8B,EAAK,KACpEC,EAAAA,GAAAA,cAAaC,GAAAA,YAAajD,GAAOkD,uBAAwBvC,GAE7D,CAaA,SAAS0B,GAAY9B,GACnBF,GAAoB8C,KAAoB5C,EAC1C,CAEA,SAASgC,KACP,OAAOZ,GAAmBwB,KAC5B,CC3JA,MAAMC,GAAsC,IAAIhD,IAiBhD,SAASiD,GACPC,KACQ9C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAmBV,SACE8C,GACwB,IAAxBC,EAAgB/C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAEhB,MAAMG,EAASC,KACV2C,GACHC,GAAkBJ,GAAwBzC,GAExC2C,IAAkBF,GAAuBtC,IAAIwC,KAC/CF,GAAuBrC,IAAIuC,GAC3B3C,EAAOK,MAAMC,KAAKqC,IAEpBlC,GAAQT,EAAQyC,GAClB,CA5BIK,CAAiBH,EAHH9C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,IAKdkD,GAAmBJ,EAEvB,CAgCA,SAASI,GAAmBJ,GAC1B,MAAM3C,EAASC,KACX0C,EACEF,GAAuBN,OAAOQ,IAChC3C,EAAOkC,QAAQ5B,KAAKqC,GAGtBE,GAAkBJ,GAAwBzC,GAE5CS,GAAQT,EAAQyC,GAClB,CAMA,SAASO,KACP,OAAOlC,MAAMC,KAAK0B,GACpB,CAOA,SAASQ,GAAiCC,GACxC,OAAOF,KAAyBG,QAAQR,GACnBS,GAAcT,GACfU,SAASH,WAAaA,GAE5C,CAQA,SAASI,GAAqBX,GAC5B,OAAOF,GAAuBtC,IAAIwC,EACpC,CAMA,SAASY,KACP,OAAOd,GAAuBvB,IAChC,CAMA,SAASjB,KACP,OAAOqB,OAAOW,OAAO,CACnB5B,MAAO,GACP6B,QAAS,GACTsB,UAAW,IAEf,CAEA,SAASX,GACPY,EACAzD,GAEAyD,EAAa9C,SAAS+C,IAChBD,EAAatB,OAAOuB,IACtB1D,EAAOkC,QAAQ5B,KAAKoD,E,GAG1B,CAEA,SAASjD,GACPT,EACAyD,IAEIzD,EAAOK,MAAMP,OAAS,GAAKE,EAAOkC,QAAQpC,OAAS,KACrD2D,EAAa9C,SAASyB,IAAcpC,EAAOwD,UAAUlD,KAAK8B,EAAK,KAC/DC,EAAAA,GAAAA,cAAaC,GAAAA,YAAajD,GAAOsE,4BAA6B3D,GAElE,CCxIA,MAAM4D,GAA6C,IAAInE,IAiBvD,SAASoE,GAAwBlB,GAAqC,IAAdmB,IAAOjE,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAC7D,MAAMG,EAASC,KACX0C,IACEmB,EACFC,GAAKpB,EAAeiB,GAA+B5D,GA0EzD,SACE2C,EACAqB,EACAhE,GAEKgE,EAAkB7D,IAAIwC,KACzBqB,EAAkB5D,IAAIuC,GAClBW,GAAqBX,IACvBI,GAAmBJ,GAErB3C,EAAOiE,WAAW3D,KAAKqC,GAE3B,CApFMuB,CAAKvB,EAAeiB,GAA+B5D,IAGvDS,GAAQT,EACV,CAMA,SAASmE,KACP,MAAMnE,EAASC,KACf2D,GAA8BjD,SAASgC,IACrCoB,GAAKpB,EAAeiB,GAA+B5D,EAAO,IAE5DS,GAAQT,EACV,CAOA,SAASoE,GAAoBzB,GAG3B,GAFmBS,GAAcT,GAG/B,OAAQiB,GAA8BzD,IAAIwC,EAE9C,CAOA,SAAS0B,GAAgC1E,GACvC,GAAIA,EAAY,CACd,MAAM2E,EAAY3E,EAAW2E,YAAa,GAyD9C,SAAuC3E,GACrC,MAAM0B,EAAaC,OAAOC,yBAAyB5B,EAAY,aAC/D,GAAI0B,EACF,OACEA,EAAWG,eACVH,EAAWI,MAAQ8C,IAAgBlD,EAAWM,MAAQ6C,IAG3D,OAAOlD,OAAOO,aAAalC,EAC7B,EAjEQ8E,CAA8B9E,IAChC2B,OAAOS,eAAepC,EAAY,YAAa,CAC7C6B,cAAc,EACdQ,YAAY,EACZP,IAAK8C,GACL5C,IAAK6C,KAGTX,GAAwBlE,EAAWgD,cAAe2B,E,CAEtD,CAKA,SAASrE,KACP,OAAOqB,OAAOW,OAAO,CACnByC,YAAa,GACbT,WAAY,GACZU,OAAQ,IAEZ,CAEA,SAASZ,GACPpB,EACAqB,EACAhE,GAEIgE,EAAkB7B,OAAOQ,IAC3B3C,EAAO0E,YAAYpE,KAAKqC,EAE5B,CAgBA,SAASlC,GAAQT,IACXA,EAAOiE,WAAWnE,OAAS,GAAKE,EAAO0E,YAAY5E,OAAS,KAC9D8D,GAA8BjD,SAC3ByB,IAAcpC,EAAO2E,OAAOrE,KAAK8B,EAAK,KAEzCC,EAAAA,GAAAA,cAAaC,GAAAA,YAAajD,GAAOuF,6BAA8B5E,GAEnE,CAaA,SAASuE,GAAaI,GACpBd,GAAyBrB,KAAoBG,cAAegC,EAC9D,CAEA,SAASH,KACP,OAAOJ,GAAqB5B,KAAoBG,cAClD,CCrHA,MAAMkC,GAOJC,WAAAA,CAAYC,GAuBZ,KAAAC,YAAeC,IACb,GAAuC,iBAA5BA,EACT,OAAOA,EAGT,MAAMC,EAAUD,EACVE,GAAiBC,EAAAA,GAAAA,mBAAkBF,GAEzC,IAAKC,EACH,MAAM,IAAIE,MACR,wGAIJ,OAAOF,EAAeG,mBAAmB,EAU3C,KAAAC,4BACEC,IAEA,MAAMC,EAAcD,EAAIxF,QAClB,oBAAEsF,GAAwBG,EAG1BC,EADclD,KAAKmD,YAEXL,GAETI,GAILpE,OAAOsE,KAAKF,GAAqC/E,SAASuC,IAEtDwC,EAAoCxC,GAEdvC,SAAShB,SAGXI,IAFAJ,EAAWkG,cAG7BlG,EAAWkG,aAAc,E,GAE3B,GACF,EAOJ,KAAAC,qBAAuB,IACdxE,OAAOsE,KAAKpD,KAAKmD,aAY1B,KAAAI,eAAiB,CACfC,EACA9C,KAEA,MAAMyC,EAAcnD,KAAKmD,YAEzB,OAAKA,EAAYK,GAIb9C,EACKyC,EAAYK,GAAU9C,GAGxByC,EAAYK,GAPV,EAOmB,EAU9B,KAAA5C,cAAiBT,IACf,MAAMgD,EAAcnD,KAAKmD,YAEzB,IAAK,MAAMM,KAAuBN,EAAa,CAC7C,MAAMO,EAA8BP,EAAYM,GAEhD,IAAK,MAAM/C,KAAYgD,EAA6B,CAClD,MAAMC,EAA0BD,EAA4BhD,GAE5D,IAAK,MAAMvD,KAAcwG,EACvB,GAAIxD,IAAkBhD,EAAWgD,cAC/B,OAAOhD,C,IAiBjB,KAAAyG,uBAAyB,CAACJ,EAAkB9C,KAC1C,MAAMyC,EAAcnD,KAAKuD,eAAeC,EAAU9C,GAElD,IAAKyC,EAAY7F,OACf,OAAO,EAGT,GAAIoD,EACF,OAAQyC,EAA4B7F,OAGtC,IAAIuG,EAAQ,EAEZ,IAAK,MAAMnD,KAAYyC,EACrBU,GAASV,EAAYzC,GAAUpD,OAGjC,OAAOuG,CAAK,EASd,KAAAC,cAAgB,CAAC3G,EAAwBqG,KACvC,MAAM,SAAE3C,GAAa1D,GACf,oBAAE2F,EAAmB,SAAEpC,GAAaG,EAE1C2C,EAAWA,GAAYV,EAEvB,MAAMK,EAAcnD,KAAKmD,YAEzB,IAAID,EAAsCC,EAAYK,GAEjDN,IACHC,EAAYK,GAAY,CAAC,EAEzBN,EAAsCC,EAAYK,IAGpD,IAAIG,EAA0BT,EAAoCxC,GAE7DiD,IACHT,EAAoCxC,GAAY,GAEhDiD,EAA0BT,EAAoCxC,IAGhEiD,EAAwB7F,KAAKX,GAC7BwB,GAA+BxB,GAC/B0E,GAAgC1E,EAAW,EAS7C,KAAA4G,iBAAoB5D,IAClB,MAAM,YAAEgD,GAAgBnD,KAExB,IAAK,MAAMwD,KAAYL,EAAa,CAClC,MAAMa,EAAmBb,EAAYK,GAErC,IAAK,MAAM9C,KAAYsD,EAAkB,CACvC,MAAMC,EAAkBD,EAAiBtD,GAEnCwD,EAAQD,EAAgBE,WAC3BhH,GAAeA,EAAWgD,gBAAkBA,KAGhC,IAAX+D,IACFD,EAAgBG,OAAOF,EAAO,GAEC,IAA3BD,EAAgB3G,eACX0G,EAAiBtD,G,CAKe,IAAzC5B,OAAOsE,KAAKY,GAAkB1G,eACzB6F,EAAYK,E,GAYzB,KAAAa,kBAAoB,CAACb,EAAkB9C,KACrC,MAAMyC,EAAcnD,KAAKmD,YACrBA,EAAYK,KACV9C,SACKyC,EAAYK,GAAU9C,UAEtByC,EAAYK,G,EAgBzB,KAAAc,gBAAkB,CAChBd,EACA9C,KAEA,MAAMyC,EAAcnD,KAAKmD,YAEzB,GAAIK,GAAY9C,EAAU,CACxB,MAAMwC,EAAsCC,EAAYK,GAExD,IAAKN,EACH,OAGF,MAAMS,EACJT,EAAoCxC,GAEtC,OAAO6D,KAAUZ,E,CACZ,GAAIH,EAAU,CACnB,MAAMN,EAAsCC,EAAYK,GAExD,OAAOe,KAAUrB,E,CAGnB,OAAOqB,KAAUpB,EAAY,EAe/B,KAAAqB,mBAAqB,CACnBC,EACAjB,EACA9C,KAEA,MAAMyC,EAAcnD,KAAKmD,YAEzB,GAAIK,GAAY9C,EAAU,CAGxB,IAAIwC,EAAsCC,EAAYK,GAEjDN,IACHC,EAAYK,GAAY,CAAC,EAEzBN,EAAsCC,EAAYK,IAGpDN,EAAoCxC,GAAyB+D,C,MACpDjB,EAGTL,EAAYK,GAAsCiB,EAGlDzE,KAAKmD,YAA+BoB,KAAUE,E,EASlD,KAAAC,0BAA4B,KAC1B,IAAIC,EAAQ,EACZ,MAAMxB,EAAcnD,KAAKmD,YACzB,IAAK,MAAMK,KAAYL,EAAa,CAClC,MAAMD,EAAsCC,EAAYK,GACxD,IAAK,MAAM9C,KAAYwC,EAAqC,CAG1DyB,GADEzB,EAAoCxC,GACLpD,M,EAGrC,OAAOqH,CAAK,EAMd,KAAAC,qBAAuB,KACrB5E,KAAKmD,YAAc,CAAC,CAAC,EA/VhBZ,IACHA,EAAMsC,GAAAA,UAAAA,UAER7E,KAAKmD,YAAc,CAAC,EACpBnD,KAAKuC,IAAMA,EAGXzC,GAAAA,YAAYgF,iBACVC,GAAAA,MAAAA,OAAaC,sBACbhF,KAAK+C,4BAET,EAwVF,MAAMkC,GACJ,IAAI5C,GAA0C,WAGhD,MC9YA,IAAI6C,GAAe,CAAC,EAMpB,MCgBMC,GAAyC,CAC7CC,uBAAuB,EACvBC,uBAAuB,EACvBC,MAAO,CAAC,EACRC,WAAY,GACZC,cAAe,GACfN,aDtBF,GCwBEO,gBAAiB,GACjBC,aAAc,GAGhB,IAAIjB,GAAkC,CACpCW,uBAAuB,EACvBC,uBAAuB,EACvBC,MAAO,CAAC,EACRC,WAAY,GACZC,cAAe,GACfN,aDlCF,GCoCEO,gBAAiB,GACjBC,aAAc,GAGhB,SAASC,KD3CPT,GAAe,CAAC,EC6ChBT,GAAQmB,KAAWT,GACrB,CClCM,SAAUU,GAAQC,GAEtB,MAAMpF,EAAWoF,EAAUpF,SACrBqF,OAA6CxI,IAA1BkH,GAAMa,MAAM5E,GAErC,IAAKA,EACH,MAAM,IAAImC,MAAM,mCAAmCiD,EAAUE,QAG/D,GAAID,EACF,MAAM,IAAIlD,MAAM,GAAGnC,qCAIrB+D,GAAMa,MAAM5E,GAAY,CACtBuF,UAAWH,EAEf,CAOM,SAAUI,GAAWJ,GACzB,MAAMpF,EAAWoF,EAAUpF,SAE3B,IAAKA,EACH,MAAM,IAAImC,MAAM,sBAAsBiD,EAAUE,QAGlD,QAA+BzI,KAA1BkH,GAAMa,MAAM5E,GAGf,MAAM,IAAImC,MACR,GAAGnC,4DAHE+D,GAAMa,MAAM5E,EAMvB,CCxCc,SAAUyF,GACtBnD,EACAN,GAEA,MAAM0D,EAAe1D,GAAYM,EAAIqD,eAC/B,SAAEC,IAAa1D,EAAAA,GAAAA,mBAAkBwD,GACjCG,EA4CR,SAAwBvD,GACtB,MAAO,CAACA,EAAIwD,QAASxD,EAAIyD,QAC3B,CA9CsBC,CAAe1D,GAC7B2D,EAmCR,SAAsB3D,GACpB,MAAO,CAACA,EAAI4D,MAAO5D,EAAI6D,MACzB,CArCoBC,CAAa9D,GACzB+D,EAkBR,SACErE,EACAiE,GAEA,MAAMK,EAAOtE,EAAQuE,wBACrB,MAAO,CACLN,EAAU,GAAKK,EAAKE,KAAOC,OAAOC,YAClCT,EAAU,GAAKK,EAAKK,IAAMF,OAAOG,YAErC,CA3BsBC,CAA0BnB,EAAcO,GAG5D,MAAO,CACLa,KAAMb,EACNc,OAAQlB,EACRmB,OAAQX,EACRY,MANiBrB,EAASsB,cAAcb,GAQ5C,CCwBA,SA3CA,SAAkC/D,GAChC,MAAMN,EAA0BM,EAAIqD,eAE9B,WAAEwB,EAAU,kBAAEC,IAAsBlF,EAAAA,GAAAA,mBAAkBF,GAEtDqF,EAAc5B,GAAoBnD,EAAKN,GAQvCO,EAAsD,CAC1D+E,MAAOhF,EACPiF,UAAWpL,GAAOqL,mBAClBL,aACAC,oBACAK,OAAQ,CAAC,EACTzF,UACAqF,cACAK,WAAYL,EACZM,cAAeN,EACfO,YAjB2B,CAC3Bd,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,OAgBE9H,EAAAA,GAAAA,cAChB6C,EACA7F,GAAOqL,mBACPjF,KASAD,EAAIuF,2BACJvF,EAAIwF,iBAER,EC/CMP,GAAYpL,GAAO4L,WAiCzB,SAzBA,SAA2BzF,GACzB,MAAMN,EAA0BM,EAAIqD,cAC9B1D,GAAiBC,EAAAA,GAAAA,mBAAkBF,IACnC,kBAAEoF,EAAiB,WAAED,GAAelF,EAGpCM,EAAoC,CACxC6E,oBACAD,aACAM,OAAQ,CAAC,EACTzF,UACA2F,cANoBlC,GAAoBnD,GAOxCiF,aACAD,MAAOhF,KAGSnD,EAAAA,GAAAA,cAAa6C,EAASuF,GAAWhF,KAIjDD,EAAIuF,2BACJvF,EAAIwF,iBAER,GC5BM,WAAEE,GAAU,oBAAEC,GAAmB,YAAEC,GAAW,SAAEC,GAAQ,WAAEC,IAC9DjM,GAyBIkM,GAA8B,EAsB9B5D,GAAwC,CAC5C6D,iBAAazL,EAEbmF,QAAS,KACToF,uBAAmBvK,EACnBsK,gBAAYtK,EAEZ0L,cAAc,EACdC,WAAY,IACZC,oBAAqB,KACrBpB,YAAa,CACXP,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,IAEhBS,WAAY,CACVZ,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,KAIlB,IAAIlD,GAAiC,CACnCuE,iBAAazL,EAEbuK,uBAAmBvK,EACnBsK,gBAAYtK,EAEZ0L,cAAc,EACdC,WAAY,IACZxG,QAAS,KACTyG,oBAAqB,KACrBpB,YAAa,CACXP,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,IAEhBS,WAAY,CACVZ,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,KAIlB,MAAMyB,GAAsC,CAC1CC,mBAAoB,KACpBC,eAAgB,KAChBC,aAAc,KACdC,mBAAmB,GA4HrB,SAASC,GAAazG,GACpB,MAAMqF,EAAgBlC,GAAoBnD,EAAKyB,GAAM/B,SAC/C0F,EAAasB,GACjBjF,GAAM/B,QACN+B,GAAM2D,YAGFE,EAAcqB,GAAgBtB,EAAeD,GAEnD,GAAIgB,GAAiBC,mBAAoB,CACvC,IAAIO,GAAgCtB,EAAYZ,QAI9C,OAFAmC,I,CAMJ,MAAM5G,EAA+C,CACnD+E,MAAOhF,EACPiF,UAAWa,GACXE,YAAavE,GAAMuE,YACnBlB,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTzF,QAAS+B,GAAM/B,QACfqF,YAAa+B,GAAYrF,GAAMsD,aAC/BK,WAAY0B,GAAY1B,GACxBC,gBACAC,iBAGgBzI,EAAAA,GAAAA,cAAa4E,GAAM/B,QAASoG,GAAY7F,KAIxDD,EAAIuF,2BACJvF,EAAIwF,kBAIN/D,GAAM2D,WAAa0B,GAAYzB,EACjC,CAiBA,SAAS0B,GAAW/G,GAIlB,GAFAgH,aAAavF,GAAM0E,qBAEfC,GAAiBC,mBAGdD,GAAiBG,aAOpBU,MALAb,GAAiBG,aAAevG,EAEhCyB,GAAM/B,QAAQoC,iBAAiB,YAAaoF,SAKzC,CAKL,MAAMjC,EAAYxD,GAAMwE,aAAeL,GAAcC,GAE/CR,EAAgBlC,GAAoBnD,EAAKyB,GAAM/B,SAC/C4F,EAAcqB,GAAgBtB,EAAe5D,GAAM2D,YACnDnF,EAE+B,CACnC+E,MAAOhF,EACPiF,YACAe,YAAavE,GAAMuE,YACnBtG,QAAS+B,GAAM/B,QACfoF,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTJ,YAAa+B,GAAYrF,GAAMsD,aAC/BK,WAAY0B,GAAYrF,GAAM2D,YAC9BC,gBACAC,gBAGFzI,EAAAA,GAAAA,cAAaoD,EAAYP,QAASuF,EAAWhF,GAE7CgH,I,CAMFE,SAASC,oBAAoB,YAAaX,GAC5C,CAQA,SAASS,GAAalH,GASf4G,GAFeD,GANExD,GAAoBnD,EAAKyB,GAAM/B,SAClCgH,GACjBjF,GAAM/B,QACN+B,GAAM2D,aAKyCV,UAIjDmC,KAIAQ,GAAkBrH,GACpB,CAQA,SAAS4G,GAAgCU,GACvC,OAAOC,KAAKC,IAAIF,EAAM,IAAMC,KAAKC,IAAIF,EAAM,IAAMvB,EACnD,CAEA,SAAS0B,KACPhG,GAAMwE,cAAe,CACvB,CAsBA,SAASY,KACPT,GAAiBI,mBAAoB,EAErC,MAAMF,EAAiBF,GAAiBE,eAClCC,EAAeH,GAAiBG,aAEtCmB,KAzNF,SAAsB1H,GACpB,MAAMsF,EAAcqB,GAAgBlF,GAAMsD,YAAatD,GAAMsD,aAEvD9E,EAA+C,CACnD+E,MAAOhF,EACPiF,UAAWS,GACXhG,QAAS+B,GAAM/B,QACfsG,YAAavE,GAAMuE,YACnBlB,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTJ,YAAatD,GAAMsD,YACnBK,WAAY3D,GAAMsD,YAClBM,cAAe5D,GAAMsD,YACrBO,eAGF7D,GAAM2D,WAAa0B,GAAY7G,EAAYmF,aAIvBvI,EAAAA,GAAAA,cAClBoD,EAAYP,QACZgG,GACAzF,KAMApD,EAAAA,GAAAA,cAAaoD,EAAYP,QAASiG,GAAqB1F,EAE3D,CA2LE0H,CAAarB,GAETC,GACFQ,GAAWR,EAEf,CAMA,SAASmB,KACHtB,GAAiBC,qBACnBW,aAAaZ,GAAiBC,oBAC9BD,GAAiBC,mBAAqB,MAGxCD,GAAiBE,eAAiB,KAClCF,GAAiBG,aAAe,IAClC,CAEA,SAASU,KACPE,SAASC,oBAAoB,UAAWL,IACxCtF,GAAM/B,SAAS0H,oBAAoB,YAAaF,IAGhDzF,GAAM/B,SAASoC,iBAAiB,YAAauF,IAE7CK,KAEAjG,GAAQmG,KAAKC,MAAMD,KAAKE,UAAU3F,IACpC,CAQA,SAAS2E,GAAYiB,GACnB,OAAOH,KAAKC,MAAMD,KAAKE,UAAUC,GACnC,CAQA,SAASrB,GACPhH,EACA0F,GAEA,MAAM,SAAE9B,IAAa1D,EAAAA,GAAAA,mBAAkBF,GAGjCiF,EAAQrB,EAASsB,cAAcQ,EAAWV,QAEhD,MAAO,CACLF,KAAMY,EAAWZ,KACjBC,OAAQW,EAAWX,OACnBC,OAAQU,EAAWV,OACnBC,QAEJ,CASA,SAASgC,GAAgBtB,EAAwBD,GAC/C,MAAO,CACLZ,KAAMwD,GAAkB3C,EAAcb,KAAMY,EAAWZ,MACvDC,OAAQuD,GAAkB3C,EAAcZ,OAAQW,EAAWX,QAC3DC,OAAQsD,GAAkB3C,EAAcX,OAAQU,EAAWV,QAC3DC,OAmBFsD,EAnB2B5C,EAAcV,MAoBzCuD,EApBgD9C,EAAWT,MAsBpD,CAACsD,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,MAJ3E,IACED,EACAC,CAlBF,CASA,SAASF,GACPC,EACAC,GAEA,MAAO,CAACD,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,GACpD,CAmBM,SAAUC,GAA+BnI,GACzCoG,GAAiBI,mBACnBJ,GAAiBI,mBAAoB,EAKrCxG,EAAIuF,2BACJvF,EAAIwF,kBAMJyB,IAEJ,CAEA,SA9ZA,SAA2BjH,GACzB,GAAIoG,GAAiBC,mBAAoB,CAEvC,GAAIrG,EAAIoI,UAAYhC,GAAiBE,eAAe8B,QAClD,OAUF,OALAhC,GAAiBE,eAAiBtG,OAIlC6G,I,CASFT,GAAiBC,mBAAqBgC,WACpCxB,GACgB,IAAhB7G,EAAIoI,QAlI0B,IAGA,KAoIhChC,GAAiBE,eAAiBtG,EAClCoG,GAAiBI,mBAAoB,EAErC/E,GAAM/B,QAA0BM,EAAIqD,cAEpC5B,GAAMuE,YAAchG,EAAIoI,QAExB,MAAMzI,GAAiBC,EAAAA,GAAAA,mBAAkB6B,GAAM/B,UACzC,kBAAEoF,EAAiB,WAAED,GAAelF,EAE1C8B,GAAMqD,kBAAoBA,EAC1BrD,GAAMoD,WAAaA,EAEnBpD,GAAM0E,oBAAsBkC,WAC1BZ,GACAhG,GAAMyE,YAIRzE,GAAM/B,QAAQ0H,oBAAoB,YAAaC,IAE/C,MAAMtC,EAAc5B,GAAoBnD,EAAKyB,GAAM/B,SACnD+B,GAAMsD,YAAc+B,GAAY/B,GAChCtD,GAAM2D,WAAa0B,GAAY/B,GAE/BoC,SAASrF,iBAAiB,UAAWiF,IACrCI,SAASrF,iBAAiB,YAAa2E,GACzC,EC1KA,SAAS6B,GAAQ5I,GACfA,EAAQ0H,oBAAoB,WAAYmB,IACxC7I,EAAQ0H,oBAAoB,YAAaoB,IACzC9I,EAAQ0H,oBAAoB,YAAaC,IAKzC3H,EAAQ0H,oBAAoB,WAAYe,GAAgC,CACtEM,SAAS,GAEb,CA0BA,UACEC,OAjBF,SAAgBhJ,GAEd4I,GAAQ5I,GAERA,EAAQoC,iBAAiB,WAAYyG,IACrC7I,EAAQoC,iBAAiB,YAAa0G,IACtC9I,EAAQoC,iBAAiB,YAAauF,IAKtC3H,EAAQoC,iBAAiB,WAAYqG,GAAgC,CACnEM,SAAS,GAEb,EAIEH,YC9CAK,GAAc,CACZC,MAAO,EACPC,MAAO,GAGX,IAAIC,GAAqBC,GAEzB,SAASC,GAAUC,EAAMC,GACvB,MAAMC,EAAMC,KAAKD,MAEjB,GAAIF,IAASH,GAAqB,CAChC,GAAIK,EAAMJ,IAZS,IAiBjB,OAJAG,EAAE1D,iBACF0D,EAAEG,kBACFH,EAAE3D,4BAEK,EAGTuD,GAAsBG,C,CAGxBF,GAAsBI,CACxB,CAKA,MAAMG,GAAiBN,GAAUO,KAAK,KAAMZ,GAAYC,OAClDY,GAAiBR,GAAUO,KAAK,KAAMZ,GAAYE,OAExD,SAASY,GAAa/J,EAASgK,EAAWC,GACxC,MAAMC,EAAaD,EAAkBL,GAAiBE,GAEtDE,EAAUvO,SAAQ,SAAU8J,GAC1BvF,EAAQoC,iBAAiBmD,EAAW2E,EAAY,CAAEC,SAAS,GAC7D,GACF,CAEA,SAASC,GAAapK,EAASgK,EAAWC,GACxC,MAAMC,EAAaD,EAAkBL,GAAiBE,GAEtDE,EAAUvO,SAAQ,SAAU8J,GAC1BvF,EAAQ0H,oBAAoBnC,EAAW2E,EACzC,GACF,CAEA,MAAMG,GAAc,CAAC,YAAa,UAAW,aACvCC,GAAc,CAAC,aAAc,YAEnC,SAAS1B,GAAQ5I,GACfoK,GAAapK,EAASqK,GAAapB,GAAYC,OAC/CkB,GAAapK,EAASsK,GAAarB,GAAYE,MACjD,CAQA,UACEH,OAPF,SAAgBhJ,GACd4I,GAAQ5I,GACR+J,GAAa/J,EAASqK,GAAapB,GAAYC,OAC/Ca,GAAa/J,EAASsK,GAAarB,GAAYE,MACjD,EAIEP,QAAOA,ICzDK,SAAU2B,GACtBjK,EACAN,GAEA,MAAM0D,EAAe1D,GAAYM,EAAIqD,cAC/B6G,EAAuB,aAAblK,EAAIiJ,KAAsBjJ,EAAImK,eAAiBnK,EAAIkK,QACnE,OAAOpO,OAAOsE,KAAK8J,GAASE,KAAKC,IAC/B,MAAM9G,EAoDV,SAAwBsF,GACtB,MAAO,CAACA,EAAMrF,QAASqF,EAAMpF,QAC/B,CAtDwBC,CAAewG,EAAQG,IACrC1G,EA2CV,SAAsBkF,GACpB,MAAO,CAACA,EAAMjF,MAAOiF,EAAMhF,MAC7B,CA7CsBC,CAAaoG,EAAQG,IACjCtG,EA0BV,SACErE,EACAiE,GAEA,MAAMK,EAAOtE,EAAQuE,wBACrB,MAAO,CACLN,EAAU,GAAKK,EAAKE,KAAOC,OAAOC,YAClCT,EAAU,GAAKK,EAAKK,IAAMF,OAAOG,YAErC,CAnCwBC,CAA0BnB,EAAcO,IACtD,SAAEL,IAAa1D,EAAAA,GAAAA,mBAAkBwD,GAEvC,MAAO,CACLoB,KAAMb,EACNc,OAAQlB,EACRmB,OAAQX,EACRY,MALiBrB,EAASsB,cAAcb,GAMxC8E,MAAO,CACLyB,WAAYD,EACZE,QAASL,EAAQG,GAAGE,QACpBC,QAASN,EAAQG,GAAGG,QACpBC,MAAOP,EAAQG,GAAGI,MAClBC,cAAeR,EAAQG,GAAGK,eAE7B,GAEL,CC7BA,SAASC,GACPtF,EACAD,GAEA,MAAMwF,EAAOC,GAAcxF,GACrByF,EAAOD,GAAczF,GAC3B,MAAO,CACLZ,KAAMwD,GAAkB4C,EAAKpG,KAAMsG,EAAKtG,MACxCC,OAAQuD,GAAkB4C,EAAKnG,OAAQqG,EAAKrG,QAC5CC,OAAQsD,GAAkB4C,EAAKlG,OAAQoG,EAAKpG,QAC5CC,OAiKFsD,EAjK2B2C,EAAKjG,MAkKhCuD,EAlKuC4C,EAAKnG,MAoKrC,CAACsD,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,MAJ3E,IACED,EACAC,CAhKF,CASA,SAAS6C,GACP1F,EACAD,GAEA,MAAMwF,EAAOC,GAAcxF,GACrByF,EAAOD,GAAczF,GAC3B,MAAO,CACLZ,KAAMwG,GAAeJ,EAAKpG,KAAMsG,EAAKtG,MACrCC,OAAQuG,GAAeJ,EAAKnG,OAAQqG,EAAKrG,QACzCC,OAAQsG,GAAeJ,EAAKlG,OAAQoG,EAAKpG,QACzCC,MAAOsG,GAAeL,EAAKjG,MAAOmG,EAAKnG,OAE3C,CAEA,SAASuG,GACP7F,EACAD,GAGF,CASA,SAAS+F,GACP9F,EACAD,GAEA,MAAMgG,EAAkBC,GAAkChG,GACpDiG,EAAeD,GAAkCjG,GAOvD,MANsB,CACpBZ,KAAM4G,EAAgB5G,KAAO8G,EAAa9G,KAC1CC,OAAQ2G,EAAgB3G,OAAS6G,EAAa7G,OAC9CC,OAAQ0G,EAAgB1G,OAAS4G,EAAa5G,OAC9CC,MAAOyG,EAAgBzG,MAAQ2G,EAAa3G,MAGhD,CAQA,SAAS4G,GAAexD,GACtB,OAAOH,KAAKC,MAAMD,KAAKE,UAAUC,GACnC,CAEA,SAASyD,GAAWzD,GAClB,OAAOH,KAAKC,MAAMD,KAAKE,UAAUC,GACnC,CAEA,SAAS8C,GAAc9C,GACrB,OAAOA,EAAO0D,QACZ,CAACC,EAAMd,KACE,CACLpG,KAAM,CACJkH,EAAKlH,KAAK,GAAKoG,EAAKpG,KAAK,GAAKuD,EAAOzN,OACrCoR,EAAKlH,KAAK,GAAKoG,EAAKpG,KAAK,GAAKuD,EAAOzN,QAEvCmK,OAAQ,CACNiH,EAAKjH,OAAO,GAAKmG,EAAKnG,OAAO,GAAKsD,EAAOzN,OACzCoR,EAAKjH,OAAO,GAAKmG,EAAKnG,OAAO,GAAKsD,EAAOzN,QAE3CoK,OAAQ,CACNgH,EAAKhH,OAAO,GAAKkG,EAAKlG,OAAO,GAAKqD,EAAOzN,OACzCoR,EAAKhH,OAAO,GAAKkG,EAAKlG,OAAO,GAAKqD,EAAOzN,QAE3CqK,MAAO,CACL+G,EAAK/G,MAAM,GAAKiG,EAAKjG,MAAM,GAAKoD,EAAOzN,OACvCoR,EAAK/G,MAAM,GAAKiG,EAAKjG,MAAM,GAAKoD,EAAOzN,OACvCoR,EAAK/G,MAAM,GAAKiG,EAAKjG,MAAM,GAAKoD,EAAOzN,WAI7C,CACEkK,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,IAGpB,CAEA,SAASgH,GAAmB5D,GAC1B,OAAOA,EAAO0D,QACZ,CAACC,EAAMd,KACE,CACLpG,KAAM,CACJkH,EAAKlH,KAAK,GAAKoG,EAAKpG,KAAK,GAAKuD,EAAOzN,OACrCoR,EAAKlH,KAAK,GAAKoG,EAAKpG,KAAK,GAAKuD,EAAOzN,QAEvCmK,OAAQ,CACNiH,EAAKjH,OAAO,GAAKmG,EAAKnG,OAAO,GAAKsD,EAAOzN,OACzCoR,EAAKjH,OAAO,GAAKmG,EAAKnG,OAAO,GAAKsD,EAAOzN,QAE3CoK,OAAQ,CACNgH,EAAKhH,OAAO,GAAKkG,EAAKlG,OAAO,GAAKqD,EAAOzN,OACzCoR,EAAKhH,OAAO,GAAKkG,EAAKlG,OAAO,GAAKqD,EAAOzN,QAE3CqK,MAAO,CACL+G,EAAK/G,MAAM,GAAKiG,EAAKjG,MAAM,GAAKoD,EAAOzN,OACvCoR,EAAK/G,MAAM,GAAKiG,EAAKjG,MAAM,GAAKoD,EAAOzN,OACvCoR,EAAK/G,MAAM,GAAKiG,EAAKjG,MAAM,GAAKoD,EAAOzN,QAEzCuO,MAAO,CACLyB,WAAY,KACZC,QAASmB,EAAK7C,MAAM0B,QAAUK,EAAK/B,MAAM0B,QAAUxC,EAAOzN,OAC1DkQ,QAASkB,EAAK7C,MAAM2B,QAAUI,EAAK/B,MAAM2B,QAAUzC,EAAOzN,OAC1DmQ,MAAOiB,EAAK7C,MAAM4B,MAAQG,EAAK/B,MAAM4B,MAAQ1C,EAAOzN,OACpDoQ,cACEgB,EAAK7C,MAAM6B,cAAgBE,EAAK/B,MAAM6B,cAAgB3C,EAAOzN,WAIrE,CACEkK,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,GACdkE,MAAO,CACLyB,WAAY,KACZC,QAAS,EACTC,QAAS,EACTC,MAAO,EACPC,cAAe,IAIvB,CAQA,SAAS1C,GACPC,EACAC,GAEA,MAAO,CAACD,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,GACpD,CASA,SAASmD,GAAkCtD,GAEzC,MAAM6D,EAA8B,GACpC,IAAK,IAAIvB,EAAI,EAAGA,EAAItC,EAAOzN,OAAQ+P,IACjC,IAAK,IAAIwB,EAAI,EAAGA,EAAI9D,EAAOzN,OAAQuR,IAC7BxB,EAAIwB,GACND,EAAe9Q,KAAK,CAClB0J,KAAMwG,GAAejD,EAAOsC,GAAG7F,KAAMuD,EAAO8D,GAAGrH,MAC/CC,OAAQuG,GAAejD,EAAOsC,GAAG5F,OAAQsD,EAAO8D,GAAGpH,QACnDC,OAAQsG,GAAejD,EAAOsC,GAAG3F,OAAQqD,EAAO8D,GAAGnH,QACnDC,MAAOsG,GAAelD,EAAOsC,GAAG1F,MAAOoD,EAAO8D,GAAGlH,SAOzD,OAAOiH,EAAeH,QACpB,CAACC,EAAMd,KACE,CACLpG,KAAMkH,EAAKlH,KAAOoG,EAAKpG,KAAOoH,EAAetR,OAC7CmK,OAAQiH,EAAKjH,OAASmG,EAAKnG,OAASmH,EAAetR,OACnDoK,OAAQgH,EAAKhH,OAASkG,EAAKlG,OAASkH,EAAetR,OACnDqK,MAAO+G,EAAK/G,MAAQiG,EAAKjG,MAAQiH,EAAetR,UAGpD,CACEkK,KAAM,EACNC,OAAQ,EACRC,OAAQ,EACRC,MAAO,GAGb,CAEA,SAASqG,GAAe/C,EAAsBC,GAC5C,OAAOX,KAAKuE,KACVvE,KAAKwE,IAAI9D,EAAO,GAAKC,EAAO,GAAI,GAAKX,KAAKwE,IAAI9D,EAAO,GAAKC,EAAO,GAAI,GAEzE,CAEA,SAAS+C,GAAehD,EAAsBC,GAC5C,OAAOX,KAAKuE,KACVvE,KAAKwE,IAAI9D,EAAO,GAAKC,EAAO,GAAI,GAC9BX,KAAKwE,IAAI9D,EAAO,GAAKC,EAAO,GAAI,GAChCX,KAAKwE,IAAI9D,EAAO,GAAKC,EAAO,GAAI,GAEtC,CCxNwB8D,GAAAA,SAASC,qBAAjC,MAEM,YACJC,GAAW,qBACXC,GAAoB,YACpBC,GAAW,WACXC,GAAU,UACVC,GAAS,UACTC,GAAS,YACTC,IACE3S,GAoCE4S,GAAsB,CAC1BjI,KAAM,CAAC,EAAG,GACVC,OAAQ,CAAC,EAAG,GACZC,OAAQ,CAAC,EAAG,GACZC,MAAO,CAAC,EAAG,EAAG,IAGV+H,GAA2B,CAC/BlI,KAAM,EACNC,OAAQ,EACRC,OAAQ,EACRC,MAAO,GAIHxC,GAAyC,CAC7C2C,uBAAmBvK,EACnBsK,gBAAYtK,EACZmF,QAAS,KACTiN,gBAAiB,CACf,IACKF,GACH5D,MAAO,OAGX+D,eAAgB,CACd,IACKH,GACH5D,MAAO,OAGXgE,cAAc,EACdC,UAAW,KAEXC,aAAc,KACdC,WAAY,IACZC,iBAAkB,EAClBC,oBAAqBR,GAErBS,uBAAwB,GACxBC,QAAQ,EACRC,iBAAkB,KAOdC,GAA0C,CAC9CxI,uBAAmBvK,EACnBsK,gBAAYtK,EACZmF,QAAS,KACTiN,gBAAiB,CACf,IACKF,GACH5D,MAAO,OAGX0E,KAAM,EACNC,WAAY,KACZC,eAAgB,GAChBC,eAAgB,KAGlB,IAAIjM,GAAkCmG,KAAKC,MAAMD,KAAKE,UAAU3F,KAC5DwL,GAAmC/F,KAAKC,MAC1CD,KAAKE,UAAUwF,KAGjB,SAASM,GAAqBC,EAAK7K,EAAM/C,GACvC,OAAOpD,EAAAA,GAAAA,cAAagR,EAAK7K,EAAM/C,EACjC,CA8HA,SAAS6N,GAAa9N,GACpB,MAAM+N,EAAoB9D,GAAoBjK,EAAKyB,GAAM/B,SACnDkN,EAAiBoB,GACrBvM,GAAM/B,QACN+B,GAAMmL,gBAGFtH,EACJyI,EAAkBzT,SAAWsS,EAAetS,OACxCqQ,GAAeoD,EAAmBnB,GAClCH,GAEAwB,EACJF,EAAkBzT,SAAWsS,EAAetS,OACxC6Q,GAA+B4C,EAAmBnB,GAClDF,GAEAwB,EACJH,EAAkBzT,SAAWsS,EAAetS,OACxCyQ,GAAiBgD,EAAmBtM,GAAMmL,gBAC1CF,GAENjL,GAAMyL,oBAAsB,CAC1B1I,KAAM/C,GAAMyL,oBAAoB1I,KAAO0J,EAAc1J,KACrDC,OAAQhD,GAAMyL,oBAAoBzI,OAASyJ,EAAczJ,OACzDC,OAAQjD,GAAMyL,oBAAoBxI,OAASwJ,EAAcxJ,OACzDC,MAAOlD,GAAMyL,oBAAoBvI,MAAQuJ,EAAcvJ,OAkBzD,MAAM1E,EAA+C,CACnD+E,MAAOhF,EACPiF,UAAWoH,GACXvH,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTzF,QAAS+B,GAAM/B,QACfqF,YAAa4G,GAAmBlK,GAAMkL,iBACtCvH,WAAYuG,GAAmBiB,GAC/BvH,cAAesG,GAAmBoC,GAClCpB,gBAAiBpB,GAAe9J,GAAMkL,iBACtCC,eAAgBrB,GAAeqB,GAC/BmB,oBACAzI,YAAaA,EACb2I,cAAeA,GAGjBL,GAAqBnM,GAAM/B,QAAS2M,GAAYpM,GA6HlD,SAA0BD,EAAiBsF,GACzC,MAAM6I,GAAc,IAAI/E,MAAOgF,UACzBtB,EAAYrL,GAAMqL,UAAUsB,UAClC,GAAI3M,GAAM2L,QAAUe,EAAcrB,EAAYrL,GAAM4L,iBAClD,OAEF,MAAOgB,EAAGC,GAAKhJ,EAAYZ,OACrBzE,EAAgD,CACpD+E,MAAOhF,EACPiF,UAAWuH,GACX1H,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTzF,QAAS+B,GAAM/B,QACf6O,MAAO,MAELhH,KAAKC,IAAI6G,GAAK5M,GAAM0L,yBACtBlN,EAAYsO,MAAQF,EAAI,EAAItU,GAAMyU,MAAQzU,GAAM0U,KAChDb,GAAqB3N,EAAYP,QAAS8M,GAAavM,GACvDwB,GAAM2L,QAAS,GAGb7F,KAAKC,IAAI8G,GAAK7M,GAAM0L,yBACtBlN,EAAYsO,MAAQD,EAAI,EAAIvU,GAAM2U,KAAO3U,GAAM4U,GAC/Cf,GAAqB3N,EAAYP,QAAS8M,GAAavM,GACvDwB,GAAM2L,QAAS,EAEnB,CArJEwB,CAAiB5O,EAAKsF,GAGtB7D,GAAMmL,eAAiBrB,GAAewC,EACxC,CAQA,SAASc,GAAY7O,GAGnBgH,aAAavF,GAAMsL,cACnB,MAAMgB,EAAoB9D,GAAoBjK,EAAKyB,GAAM/B,SACnDkN,EAAiBoB,GACrBvM,GAAM/B,QACN+B,GAAMmL,gBAEFtH,EACJyI,EAAkBzT,SAAWsS,EAAetS,OACxCqQ,GAAeoD,EAAmBnB,GAClCjC,GAAeoD,EAAmBA,GAClCE,EACJF,EAAkBzT,SAAWsS,EAAetS,OACxC6Q,GAA+B4C,EAAmBnB,GAClDzB,GAA+B4C,EAAmBA,GAClD9N,EAA8C,CAClD+E,MAAOhF,EACPiF,UAAWqH,GACX5M,QAAS+B,GAAM/B,QACfoF,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTwH,gBAAiBpB,GAAe9J,GAAMkL,iBACtCC,eAAgBrB,GAAeqB,GAC/BmB,oBACAhJ,YAAa4G,GAAmBlK,GAAMkL,iBACtCvH,WAAYuG,GAAmBiB,GAC/BvH,cAAesG,GAAmBoC,GAClCzI,cACA2I,iBAGFL,GAAqB3N,EAAYP,QAAS4M,GAAWrM,GASvD,SAAwBD,GACtB,MAAMmO,GAAc,IAAI/E,MAAOgF,UACzBtB,EAAYrL,GAAMqL,UAAUsB,UAClC,GAAID,EAAcrB,EAAYa,GAASD,eACrC,OAIoB,IAAlBC,GAASJ,OACXI,GAASjO,QAAU+B,GAAM/B,QACzBiO,GAAS7I,kBAAoBrD,GAAMqD,kBACnC6I,GAAS9I,WAAapD,GAAMoD,WAC5B8I,GAAShB,gBAAkBlL,GAAMkL,iBAInC,GACEgB,GAASJ,KAAO,IAEdI,GAASjO,SAAW+B,GAAM/B,SAC1BiO,GAAS7I,mBAAqBrD,GAAMqD,mBACpC6I,GAAS9I,YAAcpD,GAAMoD,YAG/B,OAGF,MAAMkJ,EAAoB9D,GAAoBjK,EAAK2N,GAASjO,SACtDoP,EAAoB/D,GACxBgD,EACAJ,GAAShB,iBACTjI,OAYF,GAAIoK,EAAoBnB,GAASF,eAC/B,OAGFzG,aAAa2G,GAASH,YACtBG,GAASJ,MAAQ,EAEjBI,GAASH,WAAanF,YAAW,KAC/B,MAAMpI,EAA8C,CAClD+E,MAAOhF,EACPiF,UAAWsH,GACX7M,QAASiO,GAASjO,QAClBoF,kBAAmB6I,GAAS7I,kBAC5BD,WAAY8I,GAAS9I,WACrBM,OAAQ,CAAC,EACT4I,oBACA1I,cAAesG,GAAmBoC,GAClCR,KAAMI,GAASJ,MAEjBK,GAAqB3N,EAAYP,QAAS6M,GAAWtM,GACrD0N,GAAW/F,KAAKC,MAAMD,KAAKE,UAAUwF,IAAiB,GACrDK,GAASD,eACd,CAzEEqB,CAAe/O,GAGfyB,GAAQmG,KAAKC,MAAMD,KAAKE,UAAU3F,KAClCgF,SAASC,oBAAoB,YAAa0G,IAC1C3G,SAASC,oBAAoB,WAAYyH,GAC3C,CAwGA,SAASb,GACPtO,EACA0F,GAEA,MAAM,SAAE9B,IAAa1D,EAAAA,GAAAA,mBAAkBF,GAGvC,OAAO0F,EAAWgF,KAAK4E,IACrB,MAAMrK,EAAQrB,EAASsB,cAAcoK,EAAGtK,QACxC,MAAO,CACLF,KAAMwK,EAAGxK,KACTC,OAAQuK,EAAGvK,OACXC,OAAQsK,EAAGtK,OACXC,QACAkE,MAAOmG,EAAGnG,MACX,GAEL,CAEA,SA3VA,SAA4B7I,GAG1ByB,GAAM/B,QAA0BM,EAAIqD,cACpC,MAAM1D,GAAiBC,EAAAA,GAAAA,mBAAkB6B,GAAM/B,UACzC,kBAAEoF,EAAiB,WAAED,GAAelF,EAC1C8B,GAAMqD,kBAAoBA,EAC1BrD,GAAMoD,WAAaA,EAEfpD,GAAMoL,eAIV7F,aAAavF,GAAMsL,cACnBtL,GAAMsL,aAAe1E,YAAW,IAclC,SAAuBrI,GAErB,GADsByB,GAAMyL,oBAAoBxI,OAC5BjD,GAAMwL,iBACxB,OAEF,MAAMhN,EAAgD,CACpD+E,MAAOhF,EACPiF,UAAWmH,GACXtH,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTzF,QAAS+B,GAAM/B,QACfiN,gBAAiBpB,GAAe9J,GAAMkL,iBACtCC,eAAgBrB,GAAe9J,GAAMmL,gBACrC7H,YAAayG,GAAWG,GAAmBlK,GAAMkL,kBACjDvH,WAAYoG,GAAWG,GAAmBlK,GAAMmL,kBAElDgB,GAAqB3N,EAAYP,QAAS0M,GAAanM,EACzD,CAhCwCgP,CAAcjP,IAAMyB,GAAMuL,YAwClE,SAAuBhN,GACrByB,GAAMoL,cAAe,EACrBpL,GAAMqL,UAAY,IAAI1D,KACtB,MAAMuD,EAAkB1C,GAAoBjK,EAAKyB,GAAM/B,SACjDqF,EAAc4G,GAAmBgB,GACjCrH,EAAcmH,GACdwB,EAAgBvB,GAEhBzM,EAAgD,CACpD+E,MAAOhF,EACPiF,UAAWiH,GACXxM,QAAS+B,GAAM/B,QACfoF,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBM,OAAQ,CAAC,EACTwH,gBAAiBA,EACjBC,eAAgBD,EAChBoB,kBAAmBpB,EACnB5H,YAAaA,EACbK,WAAYL,EACZM,cAAeN,EACfO,cACA2I,iBAIFxM,GAAMkL,gBAAkBpB,GAAetL,EAAY0M,iBACnDlL,GAAMmL,eAAiBrB,GAAetL,EAAY2M,gBAGxBgB,GACxB3N,EAAYP,QACZwM,GACAjM,IAMA2N,GACE3N,EAAYP,QACZyM,GACAlM,EAGN,CAnFEiP,CAAclP,GACdmH,SAASrF,iBAAiB,YAAagM,IACvC3G,SAASrF,iBAAiB,WAAY+M,IACxC,EClKA,SAASvG,GAAQ5I,GACfyP,GAAkB7G,QAAQ5I,GAC1BA,EAAQ0H,oBAAoB,aAAcgI,GAC5C,CAmBA,UACE1G,OAVF,SAAgBhJ,GAEd4I,GAAQ5I,GACRyP,GAAkBzG,OAAOhJ,GACzBA,EAAQoC,iBAAiB,aAAcsN,GAAoB,CACzDvF,SAAS,GAEb,EAIEvB,QAAOA,IClCH+G,GAAa,GACbC,GAAc,GACdC,GAAc,IC+CpB,SAtCA,SAAuBvP,GACrB,MAAMN,EAA0BM,EAAIqD,cAC9B1D,GAAiBC,EAAAA,GAAAA,mBAAkBF,IACnC,kBAAEoF,EAAiB,WAAED,GAAelF,EAK1C,GAAIK,EAAIwP,QAAU,GAAKxP,EAAIwP,OAAS,EAClC,OAGFxP,EAAIwF,iBAEJ,MAAM,MAAEiK,EAAK,MAAEC,EAAK,OAAEC,EAAM,OAAEC,GDdlB,SAAyB5K,GACrC,IAAIyK,EAAQ,EACVC,EAAQ,EACRC,EAAS,EACTC,EAAS,EA8CX,MA3CI,WAAY5K,IACd0K,EAAQ1K,EAAMxK,QAEZ,eAAgBwK,IAClB0K,GAAS1K,EAAM6K,WAAa,KAE1B,gBAAiB7K,IACnB0K,GAAS1K,EAAM8K,YAAc,KAE3B,gBAAiB9K,IACnByK,GAASzK,EAAM+K,YAAc,KAG/BJ,EAASF,EAAQJ,GACjBO,EAASF,EAAQL,GAEb,WAAYrK,IACd4K,EAAS5K,EAAMwK,QAEb,WAAYxK,IACd2K,EAAS3K,EAAMgL,SAGZL,GAAUC,IAAW5K,EAAMiL,YACN,IAApBjL,EAAMiL,WAERN,GAAUL,GACVM,GAAUN,KAGVK,GAAUJ,GACVK,GAAUL,KAKVI,IAAWF,IACbA,EAAQE,EAAS,GAAK,EAAI,GAExBC,IAAWF,IACbA,EAAQE,EAAS,GAAK,EAAI,GAGrB,CACLH,QACAC,QACAC,SACAC,SAEJ,CC1C2CM,CAAelQ,GAClDmQ,EAAYT,EAAQ,GAAK,EAAI,EAE7BzP,EAAqC,CACzC+E,MAAOhF,EACPiF,UAAWpL,GAAOuW,YAClBtL,oBACAD,aACAnF,UACAyF,OAAQ,CAAC,EACT3K,OAAQwF,EACRqQ,MAAO,CACLZ,QACAC,QACAC,SACAC,SACAO,aAEFpI,OAAQ5E,GAAoBnD,KAG9BnD,EAAAA,GAAAA,cAAa6C,EAAS7F,GAAOuW,YAAanQ,EAC5C,EC7BA,SAASqI,GAAQ5I,GACfA,EAAQ0H,oBAAoB,QAASkJ,GACvC,CAEA,UACE5H,OAhBF,SAAgBhJ,GACd4I,GAAQ5I,GACRA,EAAQoC,iBAAiB,QAASwO,GAAe,CAAEzG,SAAS,GAC9D,EAcEvB,QAAOA,ICZHnG,GAAsC,CAE1C2C,uBAAmBvK,EACnBsK,gBAAYtK,EAEZgW,SAAKhW,EACLiW,aAASjW,EACTmF,QAAS,MAGX,IAAI+B,GAA+B,CAEjCqD,uBAAmBvK,EACnBsK,gBAAYtK,EAEZgW,SAAKhW,EACLiW,aAASjW,EACTmF,QAAS,MAOX,SAAS+Q,GAAYzQ,GACnByB,GAAM/B,QAA0BM,EAAIqD,cAEpC,MAAM1D,GAAiBC,EAAAA,GAAAA,mBAAkB6B,GAAM/B,UACzC,kBAAEoF,EAAiB,WAAED,GAAelF,EAE1C8B,GAAMqD,kBAAoBA,EAC1BrD,GAAMoD,WAAaA,EACnBpD,GAAM8O,IAAMvQ,EAAIuQ,IAChB9O,GAAM+O,QAAUxQ,EAAIwQ,QAEpBxQ,EAAIwF,iBACJ,MAAMvF,EAAkC,CACtC6E,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBnF,QAAS+B,GAAM/B,QACf6Q,IAAK9O,GAAM8O,IACXC,QAAS/O,GAAM+O,UASjB3T,EAAAA,GAAAA,cAAaoD,EAAYP,QAAS7F,GAAO6W,SAAUzQ,GAEnDkH,SAASrF,iBAAiB,QAAS6O,IACnCxJ,SAASrF,iBAAiB,mBAAoB8O,IAG9CnP,GAAM/B,QAAQ0H,oBAAoB,UAAWqJ,GAC/C,CAMA,SAASG,KACPzJ,SAASC,oBAAoB,mBAAoBwJ,IAChB,WAA7BzJ,SAAS0J,iBACXC,IAEJ,CAEA,SAASH,GAAS3Q,GAChB,MAAMC,EAAgC,CACpC6E,kBAAmBrD,GAAMqD,kBACzBD,WAAYpD,GAAMoD,WAClBnF,QAAS+B,GAAM/B,QACf6Q,IAAK9O,GAAM8O,IACXC,QAAS/O,GAAM+O,SAKjBrJ,SAASC,oBAAoB,QAASuJ,IACtCxJ,SAASC,oBAAoB,mBAAoBwJ,IACjDnP,GAAM/B,QAAQoC,iBAAiB,UAAW2O,IAG1ChP,GAAQmB,KAAWT,KACnBtF,EAAAA,GAAAA,cAAaoD,EAAYP,QAAS7F,GAAOkX,OAAQ9Q,EACnD,CAMM,SAAU6Q,KACdrP,GAAM+O,aAAUjW,CAClB,CAEA,YCxGA,SAAS+N,GAAQ5I,GACfA,EAAQ0H,oBAAoB,UAAW4J,GACzC,CAEA,UACEtI,OAVF,SAAgBhJ,GACd4I,GAAQ5I,GACRA,EAAQoC,iBAAiB,UAAWkP,GACtC,EAQE1I,QAAO,GACP2I,eDyFI,WACJ,OAAOxP,GAAM+O,OACf,G,4BEvGA,MAAMU,GAAsC,CAC1CC,eAAe,EACfC,mBAAoB,EACpBC,qBAAsB,EACtBC,eAAgB,EAChBC,uBAAwB,IACxBC,YAAY,EACZC,UAAW,EACXC,kBAAmB,GAOrB,SAJA,WACE,OAAOR,EACT,ECbMS,GAAwC,CAC5CR,eAAe,EACfC,mBAAoB,EACpBC,qBAAsB,EACtBG,YAAY,EACZI,oBAAoB,EACpBH,UAAW,GACXC,kBAAmB,IACnBJ,eAAgB,EAChBC,uBAAwB,KAwB1B,SArBA,WACE,OAAOI,EACT,ECGMA,GAAwBE,KACxBX,GAAuBY,KAWvBC,GAAyC,CAC7CC,SAAU,GACVC,cAAe,GACfC,aAZwD,CACxDC,6BAA6B,EAC7BC,gBAAiB,CACf,CAACtY,GAA4BuY,UAAWV,GACxC,CAAC7X,GAA4BwY,SAAUpB,KASzC3O,WAAY,CAAC,GAqdf,MAAMgQ,GAAkC,IA5c1B,MAIZjT,WAAAA,CAAYC,GACLA,IACHA,EAAMiT,GAAAA,UAAAA,UAERxV,KAAKyE,MAAQF,KAAUwQ,IACvB/U,KAAKuC,IAAMA,CACb,CAMAkT,QAAAA,GACE,OAAOzV,KAAKyE,KACd,CAMAiR,aAAAA,GACE,OAAO5W,OAAOsE,KAAKpD,KAAKyE,MAAMc,WAChC,CAOAoQ,WAAAA,CAAYC,GACV,OAAO5V,KAAKyE,MAAMuQ,SAASY,EAC7B,CAEAC,oBAAAA,GACE,OAAO7V,KAAKyE,MAAMuQ,SAAS1X,MAC7B,CAKAwY,UAAAA,GACE9V,KAAKyE,MAAQF,KAAUwQ,GACzB,CAOAgB,eAAAA,CAAgBC,GACd,OAAOhW,KAAKyE,MAAMwQ,cAAcgB,MAC7BC,GAAiBA,EAAaF,iBAAmBA,GAEtD,CAMAG,eAAAA,CAAgBD,GAEd,GAAIlW,KAAK+V,gBAAgBG,EAAaF,gBACpC,MAAM,IAAInT,MACR,wBAAwBqT,EAAaF,iCAIzChW,KAAKyE,MAAMwQ,cAAcnX,KAAKoY,EAChC,CAOAE,8BAAAA,CACEC,GAEA,MAAMC,EACJtW,KAAKyE,MAAMc,WAAW8Q,GAExB,GAAKC,EAIL,OAAOA,EAAsCC,2BAC/C,CAMAC,iCAAAA,GAIE,MAAMC,EACJ,CAAC,EAOH,OANA3X,OAAO4X,QAAQ1W,KAAKyE,MAAMc,YAAYpH,SACpCwY,IAAyD,IAAvDN,EAAaC,GAAsCK,EACnDF,EAAiBJ,GACfC,EAAsCC,2BAA2B,IAGhEE,CACT,CAOAG,6BAAAA,CACEP,EACAQ,GAGK7W,KAAKyE,MAAMc,WAAW8Q,KACzBrW,KAAKyE,MAAMc,WAAW8Q,GAAe,CACnCE,4BAA6B,GAC7BO,OAAQ,CAAC,IAKb9W,KAAKyE,MAAMc,WAAW8Q,GAAaE,4BAA4BzY,KAC7D+Y,GAGF7W,KAAK+W,0BAA0BV,EAAaQ,EAC9C,CAOAG,eAAAA,GACE,OAAOhX,KAAKyE,MAAMyQ,YACpB,CAOA+B,eAAAA,CAAgBH,GACd9W,KAAKyE,MAAMyQ,aAAe4B,CAC5B,CASAI,kCAAAA,CACEb,EACAc,GAWA,OAREnX,KAAKoW,+BAA+BC,GAEeJ,MAClDmB,GACCA,EAAeD,gCACfA,GAIN,CAMAE,kBAAAA,CAAmBrB,GACjBhW,KAAKyE,MAAMwQ,cAAgBjV,KAAKyE,MAAMwQ,cAActU,QACjDuV,GAAiBA,EAAaF,iBAAmBA,GAEtD,CAQAsB,gCAAAA,CACEjB,EACAc,GAEA,MAAMI,EACJvX,KAAKoW,+BAA+BC,GAEtC,IACGkB,IACAA,EAAqCja,OAEtC,MAAM,IAAIuF,MACR,8DAA8DwT,KAIlE,MAEMnS,EADJqT,EACkBpT,WACjBqT,GACCA,EAAQL,gCAAkCA,KAG/B,IAAXjT,GACFuT,QAAQC,KACN,mEAAmErB,+BAAyCc,KAIhH,MAAMQ,EACJJ,EAAqCrT,GAEvCqT,EAAqCnT,OAAOF,EAAO,GAEnDlE,KAAK+W,0BACHV,EACAsB,EAEJ,CAQAC,mCAAAA,CACEvB,EACAc,GAEA,MAAMU,EACJ7X,KAAKoW,+BAA+BC,GAEtC,IAAKwB,IAA2BA,EAAuBva,OACrD,MAAM,IAAIuF,MACR,+CAA+CwT,KAInD,MAAMyB,EAAmBD,EAAuB5B,MAC7C6B,GACCA,EAAiBX,gCACjBA,IAGJ,IAAKW,EACH,MAAM,IAAIjV,MACR,wDAAwDsU,KAI5DW,EAAiBC,QAAS,EAC1B/X,KAAK+W,0BAA0BV,EAAayB,EAC9C,CAQAE,0BAAAA,CACE3B,GAEA,MAAM4B,EAA2BjY,KAAKyE,MAAMc,WAAW8Q,GAEvD,GAAK4B,EAIL,OAAOA,EAAyBnB,MAClC,CAEAoB,2CAAAA,CACE7B,EACAc,GAEA,MAAMN,EAA6B7W,KAAKkX,mCACtCb,EACAc,GAGF,GAAKN,EAIL,OAAOA,EAA2BsB,wCACpC,CAEAC,2CAAAA,CACE/B,EACAc,EACAL,GAEA,MAAMD,EAA6B7W,KAAKkX,mCACtCb,EACAc,GAGGN,IAILA,EAA2BsB,yCACzBrB,EACJ,CAEAuB,wBAAAA,CACEhC,EACAc,EACAmB,GAEA,MAAMzB,EAA6B7W,KAAKkX,mCACtCb,EACAc,GAGF,GAAKN,EAIL,OAAOA,EAA2B0B,sBAAsBD,EAC1D,CAEAE,wBAAAA,CACEnC,EACAc,EACAL,GAEA,MAAMD,EAA6B7W,KAAKkX,mCACtCb,EACAc,GAGGN,IAILA,EAA2B0B,sBAAwBzB,EACrD,CAUA2B,mCAAAA,CACEpC,EACAS,GAEA,IAAImB,EAA2BjY,KAAKyE,MAAMc,WAAW8Q,GAEhD4B,IACHjY,KAAKyE,MAAMc,WAAW8Q,GAAe,CACnCE,4BAA6B,GAC7BO,OAAQ,CACN3B,6BAA6B,EAC7BC,gBAAiB,CAAC,IAItB6C,EAA2BjY,KAAKyE,MAAMc,WAAW8Q,IAGnD4B,EAAyBnB,OAAS,IAC7BmB,EAAyBnB,UACzBA,EAEP,CAOA4B,WAAAA,CAAY1D,EAA0BY,GAChC5V,KAAKyE,MAAMuQ,SAASY,IACtB6B,QAAQC,KAAK,+CAGf1X,KAAKyE,MAAMuQ,SAASY,GAAY+C,gBAAgB3D,EAClD,CAMA4D,cAAAA,CAAeC,UACN7Y,KAAKyE,MAAMuQ,SAAS6D,EAC7B,CASA9B,yBAAAA,CACEV,EACAyC,GAEA,MAAMvC,EACJvW,KAAKoW,+BAA+BC,GAGtC,GAA2C,IAAvCE,EAA4BjZ,OAC9B,OAIF,GAA2C,IAAvCiZ,EAA4BjZ,OAE9B,YADAiZ,EAA4B,GAAGwB,QAAS,GAUO,IAJ/CxB,EAA4B5V,QACzByW,GAAmBA,EAAeW,SAGDza,OAOlCwb,EAAiDf,QACnDxB,EAA4BpY,SAASiZ,IAEjCA,EAAeD,gCACf2B,EAAiD3B,gCAEjDC,EAAeW,QAAS,E,IAZ5BxB,EAA4B,GAAGwB,QAAS,CAkB5C,GAGmE,WCrerE,SAASgB,GAA2B/C,GAClC,MAAM/S,EAA8C,CAClD+S,mBAGFnW,EAAAA,GAAAA,cAAaC,GAAAA,YAAajD,GAAOmc,qBAAsB/V,EACzD,CASA,SAASgW,GACP5C,EACAc,GAEA,MAAMlU,EAA4D,CAChEoT,cACAc,kCAGFtX,EAAAA,GAAAA,cACEC,GAAAA,YACAjD,GAAOqc,oCACPjW,EAEJ,CAOA,SAASkW,GACP9C,EACAc,GAEA,MAAMlU,EAA6D,CACjEoT,cACAc,iCAGF,GAAIA,EAMF,YALAtX,EAAAA,GAAAA,cACEC,GAAAA,YACAjD,GAAOuc,qCACPnW,IAUFmT,GAA+BC,IAAgB,IAErBlY,SAAS0Y,IACnC,MAAM,8BAAEM,GAAkCN,EACpC5T,EAA6D,CACjEoT,cACAc,kCAGFtX,EAAAA,GAAAA,cACEC,GAAAA,YACAjD,GAAOuc,qCACPnW,EACD,GAEL,CAUA,SAASoW,GAA4BrD,GACnC,IAAIsD,EAGFA,EADEtD,EACgB,CAACA,GAGDuD,KAAmBnM,KACnCuJ,IAAA,IAAC,eAAEX,GAAgBW,EAAA,OAAKX,CAAc,IAM1CsD,EAAgBnb,SAAS6X,IACvB,MAAM/S,EAA+C,CACnD+S,mBAEFnW,EAAAA,GAAAA,cAAaC,GAAAA,YAAajD,GAAO2c,sBAAuBvW,EAAY,GASxE,CAMA,SAASwW,GACPzD,EACA0D,GAEA,MAAMzW,EAAmD,CACvD+S,iBACA0D,wBAGF7Z,EAAAA,GAAAA,cAAaC,GAAAA,YAAajD,GAAO8c,2BAA4B1W,EAC/D,CChHA,SAvBA,SACE2W,GAEA,MAAM,eAAE5D,EAAc,eAAEoB,GAAmBwC,EAI3C,MAAO,CACL5D,iBACA6D,YAAa,CAAC,EACdC,cAAe,CAAC,EAChBC,MAAO,KACPC,eAAgB,IAAI/c,IACpBgP,KAAMmL,EAAenL,KACrBgO,mBAAoB,EACpBC,mBAAoB,CAClB,CAAC9C,EAAenL,MAAO,IAClBmL,EAAe+C,OAI1B,ECTA,SAASC,KACP,OAAO7E,EACT,CAaA,SAASQ,GAAgBC,GAEvB,OADiCoE,KACDrE,gBAAgBC,EAClD,CAMA,SAASuD,KAIP,OAHiCa,KACM3E,WAE1BR,aACf,CAOA,SAASkB,GACPyD,EACAS,GAEA,MAAMC,EAA2BF,KAE3BlE,EAAeqE,GAA2BX,GAEhDU,EAAyBnE,gBAAgBD,GAEpCmE,GACHhB,GAA4BnD,EAAaF,eAE7C,CAQA,SAASI,GACPC,GAGA,OADiC+D,KACDhE,+BAA+BC,EACjE,CAMA,SAASG,KAKP,OADiC4D,KACD5D,mCAClC,CAQA,SAASgE,GAAgCxE,GACvC,IAAKA,EACH,MAAM,IAAInT,MAAM,4DAGlB,MAAMyX,EAA2BF,KAC3B3V,EAAQ6V,EAAyB7E,WACjCgF,EAAe3b,OAAOsE,KAAKqB,EAAMc,YAEjCmV,EAAoB,GAY1B,OAXAD,EAAatc,SAASkY,IAElBiE,EAAyBlE,+BAA+BC,GAErBlY,SAASiZ,IACxCA,EAAepB,iBAAmBA,GACpC0E,EAAkB5c,KAAKuY,E,GAEzB,IAGGqE,CACT,CAQA,SAAS1C,GACP3B,GAGA,OADiC+D,KACDpC,2BAA2B3B,EAC7D,CAaA,SAASsE,GACPtE,EACAS,EACAuD,GAEiCD,KACR3B,oCACvBpC,EACAS,GAGGuD,GACHlB,GAA0C9C,EAE9C,CASA,SAAS+B,GACP/B,EACAc,EACAL,GACsB,IAAtBuD,EAAchd,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAEmB+c,KACRhC,4CACvB/B,EACAc,EACAL,GAGGuD,GACHlB,GACE9C,EACAc,EAGN,CAOA,SAASe,GACP7B,EACAc,GAGA,OADiCiD,KACDlC,4CAC9B7B,EACAc,EAEJ,CAEA,SAASyD,GACPvE,EACAc,EACAmB,GAGA,OADiC8B,KACD/B,yBAC9BhC,EACAc,EACAmB,EAEJ,CAEA,SAASuC,GACPxE,EACAc,EACAL,GACsB,IAAtBuD,EAAchd,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAEmB+c,KACR5B,yBACvBnC,EACAc,EACAL,GAKGuD,GACHlB,GACE9C,EACAc,EAGN,CAYA,SAASP,GACPP,EACAQ,EACAwD,GAEiCD,KACRxD,8BACvBP,EACAQ,GAGGwD,GACHlB,GACE9C,EACAQ,EAA2BM,8BAGjC,CAQA,SAASH,KAEP,OADiCoD,KACDpD,iBAClC,CAUA,SAASC,GACPH,EACAuD,GAEiCD,KACRnD,gBAAgBH,GAEpCuD,GACHhB,IAEJ,CAWA,SAASnC,GACPb,EACAc,GAGA,OADiCiD,KACDlD,mCAC9Bb,EACAc,EAEJ,CASA,SAASE,GAAmBrB,GACOoE,KACR/C,mBAAmBrB,GAC5C+C,GAA2B/C,EAC7B,CAcA,SAASsB,GACPjB,EACAc,GAEiCiD,KACR9C,iCACvBjB,EACAc,GAGF8B,GACE5C,EACAc,EAEJ,CAOA,SAASyB,GAAeC,GACWuB,KACRxB,eAAeC,EAC1C,CAOA,SAASlD,GAAYzR,GAEnB,OADiCkW,KACDzE,YAAYzR,EAC9C,CAEA,SAAS2R,KAEP,OADiCuE,KACDvE,sBAClC,CAOA,SAAS6C,GAAY1D,EAA0B9Q,GACZkW,KACR1B,YAAY1D,EAAU9Q,EAEjD,CC9XA,SAAS4W,GACPC,GAIA,YACkExd,IAA/Dwd,EAAkDC,QAEvD,CCuDA,SA/DAC,eACEvY,EACAwY,EACA/D,GAEA,MAAMxU,GAAiBC,EAAAA,GAAAA,mBAAkBF,IACnC,gBAAEyY,EAAe,SAAE7U,GAAa3D,GAC9ByY,GAAIvT,GAAevB,EAS3B,GAAIwU,GAAqBI,GAAe,CAKtC,MAAMG,EAAqC,CACzC,CACEL,SAAUE,EAAaF,SACvBM,SAAUnE,EACVoE,WAba,KAcbC,UAAWzW,GAAAA,MAAAA,WAAiB0W,gCAK1BC,EAAAA,GAAAA,uBACJP,EACAE,EACA,CAACxT,GArBmB,MACD,K,KAwBhB,CAGL,MAIM8T,EAAmC,CACvC,CACEC,QALFV,EACAW,oBAAoB1c,IAAImH,EAASwV,qBAK/BR,SAAUnE,UAKR4E,EAAAA,GAAAA,2BACJZ,EACAQ,EACA,CAAC9T,GA3CmB,MACD,K,CA+CzB,ECpDA,SAlBA,SACEnF,EACAyU,GAGA,MAAMxU,GAAiBC,EAAAA,GAAAA,mBAAkBF,IACnC,SAAE4D,GAAa3D,EAEjB2D,aAAoB0V,GAAAA,eAKvB1V,EAAmC2V,mBAAmB,CACrD9E,GAEJ,ECCM+E,GAAoB,IACpBC,GAAsB,IAAIC,IAEhC,SAASC,KACP,MAAMC,EAAOC,GAAAA,GAAAA,cACPC,EAAOC,GAAAA,GAAAA,cAEb,OADAD,EAAKE,SAAS,EAAG,GACV,CACLF,OACAF,OAEJ,CAqRA,SAASK,GACPC,EACAC,EACAC,EACAC,GAEA,MAEMC,EAAc,IACfJ,KACAC,KAJyBE,GAA0B,CAAC,GAyBzD,MAAO,CACLtI,UAlBgBqI,EACdE,EAAYvI,UACZuI,EAAYtI,kBAiBduI,aAhBmBH,EACjBE,EAAY5I,mBACZ4I,EAAY3I,qBAedG,WAbiBsI,EACfE,EAAYxI,WACZwI,EAAYpI,mBAYdT,cAVoB6I,EAAY7I,cAWhCG,eATqBwI,EACnBE,EAAY1I,eACZ0I,EAAYzI,uBASlB,CAEA,SAAS2I,GACPrV,EACAyT,EACAhD,EAAoB6E,GAenB,IAdD,UACE1I,EAAS,WACTD,EAAU,cACVL,EAAa,aACbiJ,EAAY,aACZH,EAAY,eACZI,GAQDF,EAED,MAAMG,EAAW,GAAGzV,KAAcyT,KAAYhD,IACxCiF,EAAYpB,GAAoBhd,IAAIme,GAE1C,IAAKC,EAUH,OATApB,GAAoBld,IAAIqe,EAAU,CAChC7I,YACAD,aACAL,gBACA8I,eACAG,aAAcA,EAAaI,QAC3BH,eAAgB,IAAIpgB,IAAIogB,KAGnB,CACLI,oBAAoB,EACpBC,kBAAkB,GAItB,MACEjJ,UAAWkJ,EACXnJ,WAAYoJ,EACZzJ,cAAe0J,EACfZ,aAAca,EACdV,aAAcW,EACdV,eAAgBW,GACdT,EAEEG,EACJK,EAAgB,KAAOX,EAAa,IACpCW,EAAgB,KAAOX,EAAa,IACpCW,EAAgB,KAAOX,EAAa,GAEhCK,EACJM,EAAgB,KAAOX,EAAa,IACpCO,IAAiBlJ,GACjBmJ,IAAkBpJ,GAClBqJ,IAAqB1J,GACrB2J,IAAoBb,GACpBe,EAAkBrgB,IAAI2a,KAAkB+E,EAAe1f,IAAI2a,GAY7D,OATA6D,GAAoBld,IAAIqe,EAAU,CAChC7I,YACAD,aACAL,gBACA8I,eACAG,aAAcA,EAAaI,QAC3BH,eAAgB,IAAIpgB,IAAIogB,KAGnB,CACLI,qBACAC,mBAEJ,CA2BAzC,eAAegD,GACb3X,EACA4X,EACA/G,SAEMgH,GACJ7X,EAAS5D,QACTwb,EACA/G,EAEJ,CAEA,UACEkF,oCACA+B,OApWFnD,eACE3U,EACA8Q,EACAiH,GAEA,MAAM,cACJxF,EAAa,OACbd,EAAM,eACN/B,EAAc,8BACdmB,EAA6B,eAC7BkG,EACAvG,OAAQwH,GACNlH,EAGE8G,EADeK,GAAkCvI,GAExCkE,mBAAmBsE,GAAgBnJ,UAElD,IAAIoJ,EAAanY,EAASoY,SAASvH,GACnC,GAAI2D,GAAqBoD,GAAe,CACtC,MAAQlD,SAAU2D,GAAgBT,EAIlC,IAFiBU,GAAAA,MAAMC,UAAUF,GAG/B,MAAM,IAAI9b,MAAM,mCAAmC8b,KAGrD,IA9DJ,SAAgCrY,EAAUwY,GAIxC,IAAKA,EACH,OAAO,EAET,MAAMC,EAAezY,EAAS0Y,kBAC9B,IAAKD,EACH,OAAO,EAET,MAAQxc,IAAK0c,GAAoBF,EAC3BG,EAASN,GAAAA,MAAMC,UAAUI,GAE/B,GAAIC,EAAQ,CACV,MAAMC,EAAmBP,GAAAA,MAAMC,UAAUC,GACzC,GACEK,GACAD,EAAOre,SAASiC,sBACdqc,EAAiBte,SAASiC,oBAE5B,OAAO,C,CAGX,OAAO,CACT,CAqCSsc,CAAuB9Y,EAAU4X,GAAcY,oBAClD,OAGGL,SAEGR,GACJ3X,EACA4X,EACA/G,GAIJsH,EAAanY,EAASoY,SAASvH,E,KAC1B,CAEL,MAAMyE,EAAUtV,EAASwV,qBACnB,oBAAED,GAAwBqC,EAIhC,IAAKrC,EAAoBle,IAAIie,GAC3B,OAGG6C,SAEGR,GACJ3X,EACA4X,EACA/G,GAIJsH,EAAanY,EAASoY,SAASvH,E,CAGjC,IAAKsH,EACH,OAGF,MAAM,KAAEnC,EAAI,KAAEE,GAAS8B,EAEjBnJ,EACJkJ,EAAgBlJ,6BAgBpB,SACEtN,EACA4W,EACAnC,EACAE,EACA3D,EACA+D,EACA/F,EACAiG,EACA3H,EACAkI,GAEA,MAAM,sBAAE9E,EAAqB,yCAAEJ,GAC7BtB,EAEIgG,EACJ1E,EAAyCqG,GAAgBnJ,UAIrDL,EAAWuJ,GAA8B1F,GACzCwG,EAAY9U,KAAK+U,IAAI,IAAKtK,EAAS1X,SACjCiF,IAAK+Y,GAAamD,GAKpB,aAAExB,EAAY,cAAE9I,EAAa,eAAEG,GAAmBqI,GACtDC,EACAC,EACAC,GAMF,IAAK,IAAIzP,EAAI,EAAGA,EAAIgS,EAAWhS,IAAK,CAClC,MAAMiL,EAAejL,EACf+P,EAAepI,EAASsD,GAExBiH,EACJhH,EAAsBD,KAAgBkG,GAAgBnJ,WAElD,UAAEZ,EAAS,aAAEwI,EAAY,WAAEzI,EAAU,cAAEL,GAC3CwI,GACEC,EACAC,EACAC,EACAyC,IAGE,mBAAE9B,EAAkB,iBAAEC,GAC1BR,GAA6BrV,EAAYyT,EAAUhD,EAAc,CAC/D7D,YACAD,aACAL,gBACAiJ,eACAH,eACAI,mBAYJ,GATIK,GACFpB,EAAKkD,YACHlH,EACA8E,EAAa,GAAKlB,GAClBkB,EAAa,GAAKlB,GAClBkB,EAAa,GAAKlB,IAIlBuB,EACF,GAAIjJ,EAAY,CACd,MAAMiL,EAAiBpC,EAAe1f,IAAI2a,GACtC,EACC8E,EAAa,GAAK,IAAO3I,EAE9B+H,EAAKkD,YAAYpH,GACjBkE,EAAKmD,aAAarH,EAAcmH,EAAgB,GAAK,E,MAErDjD,EAAKmD,aAAarH,EAAc,IAAM,GAAK,E,CAKjD,MAAMsH,EAAQnB,EAAWmB,MAGzBA,EAAMC,cAAcC,uBAAuB,EAAGxD,GAE9CE,EAAKuD,aAAY,GAGjBH,EAAMC,cAAcG,iBAAiB,EAAGxD,GAExCoD,EAAMC,cAAcI,gCAEhBpb,GAAAA,UAAAA,SAAmB4Z,EAAY,eAEjCmB,EAAMC,cAAcK,mBAAmB/L,GAEvCyL,EAAMC,cAAcM,uBAAuB7L,GAE3CsL,EAAMC,cAAcO,yBAAyBnD,IAM/C,MAAM3b,EAAUwb,GAAoB3H,EACpCyK,EAAMS,cAAc/e,EACtB,CA5HEgf,CACEha,EAAS8U,GACTqD,EACAnC,EACAE,EACA3D,EACAwF,EAAgBjJ,gBAAgBoJ,GAAgBnJ,UAChD+B,EACAW,EACA5C,EACAkI,EAEJ,EA+QE/F,iCAxaF,SACEjB,EACAc,GACuB,IAAvBoJ,EAAeljB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAWf,GAkXF,SACEgZ,EACAc,GAEA,MAAMqJ,EAAYC,GAAapK,GAE/B,QAAkB9Y,IAAdijB,EACF,MAAM,IAAI3d,MAAM,8BAA8BwT,oBAGhD,MAAM,cAAEqK,GAAkBF,EAE1B,IAAK,MAAMG,KAAgBD,EAAe,CACxC,MAAM,WAAE7Y,EAAU,kBAAEC,GAAsB6Y,EACpChe,GAAiBie,EAAAA,GAAAA,wBACrB/Y,EACAC,GAEF+Y,GACEle,EAAe2D,SAAS5D,QACxByU,E,CAGN,CAlZE2J,CACEzK,EACAc,GAEFoH,GACElI,EACAc,GAGEoJ,EAAiB,CACGE,GAAapK,GAAa0K,mBAClC5iB,SAAQwY,IAAsC,IAArC,WAAE9O,EAAU,kBAAEC,GAAmB6O,GAC/BiK,EAAAA,GAAAA,wBACrB/Y,EACAC,GAEaxB,SAAS8X,QAAQ,G,CAGtC,G,uFCzDM,SAAU/F,GACd2I,EACAC,EACA/c,GAEA,IAAIqU,EACFyI,EAAsBzI,wBAAwB0I,GAQhD,OANK1I,IAEHA,EACEyI,EAAsBzI,wBAAwBrU,IAG7CqU,EAIEA,EAAsB2I,QAHpB,IAIX,CCzBA,MAAMC,GAA8C,IAAI/E,IAElD,SAAUgF,GACdjK,GAEA,OAAOgK,GAA4ChiB,IACjDgY,EAEJ,CAEM,SAAUkK,GACdlK,EACAL,GAEAqK,GAA4CliB,IAC1CkY,EACAL,EAEJ,CCZM,SAAUwK,GACdhb,EACAib,EACAP,EACAQ,EACAC,GAEA,MAAM,8BAAEtK,EAA6B,eAAEkG,GACrC2D,EACIU,EAAiBC,GAAAA,GAAAA,cAEjBC,EAAmB,IAAIxF,IACvByF,EAAqB,IAAIzF,IAE/BmF,EAAYpjB,SAAS2jB,IACnB,MAAMC,EAAWnD,GAAAA,MAAMoD,YAAYF,GAEnC,IAAKC,EAIH,YAHAtK,QAAQC,KACN,oCAAoCoK,uBAKxC,MAAMxJ,EAAgByJ,EAAS5H,KAA2B8H,mBFExD,SAA2BF,GAC/B,IAAKA,EACH,MAAM,IAAIlf,MAAM,oCAAoCkf,EAAS3G,MAG/D,MAAM0G,EAAaC,EAAS3G,GAE5B,GAAI2G,EAAS9V,OAASlH,GAAAA,MAAAA,aAAmBmc,QACvC,MAAM,IAAIre,MACR,iBAAiBkf,EAAS9V,qCAIzB8V,EAAS5H,MACZ1C,QAAQC,KACN,oCAAoCoK,sBAI1C,CEnBII,CAAiBH,GAEjB,MAAMxJ,EAAwBF,GAC5B2I,EACAc,EACAxJ,GAGI6J,EAAaJ,EAAS5H,KACtBiI,EFoBJ,SAAsBD,GAC1B,MAAME,EAAa,GAEbtX,EAASuX,GAAAA,GAAAA,cACTC,EAAQC,GAAAA,GAAAA,cAId,IAAIC,EAAa,EACjBN,EAAWO,cAAcvkB,SAASwkB,IAChC,MAAMC,EAAYD,EAAQE,YACpBC,EAAaH,EAAQI,qBACrB9W,EAAO0W,EAAQK,UAGfC,EAAeL,EAAUxV,KAC7B,CAAC8V,EAAGC,IAAmBA,EAAiBV,IAItCxW,IAASlH,GAAAA,MAAAA,YAAkBqe,eAC7BH,EAAanlB,KAAKmlB,EAAa,IAGjC,MAAMI,EAAaC,aAAa/kB,KAAKukB,GAErCT,EAAWvkB,QAAQulB,GAEnBd,EAAMgB,eAAe,IAAIN,IAEzBR,GAA0BG,EAAUtlB,MAAM,IAI5CyN,EAAOyY,QAAQnB,EAAY,GAG3B,MAAMoB,EAAUC,GAAAA,GAAAA,cAIhB,OAHAD,EAAQE,UAAU5Y,GAClB0Y,EAAQG,SAASrB,GAEVkB,CACT,CE9DqBI,CAAY1B,GACvB2B,EAAQ3B,EAAW4B,WAEnBrlB,EAAO0jB,EAASS,YAAYmB,oBAE5BC,EAAUC,GAAAA,GAAAA,YAAyB,CACvCxlB,KAAa,EAAPA,EACNylB,mBAAoB,EACpBC,SAAU,eAEZ,IAAK,IAAI/W,EAAI,EAAGA,EAAI3O,IAAQ2O,EAC1B4W,EAAQI,SAAShX,EAAG,IAAIyW,EAAO,MAEjC1B,EAASkC,eAAeC,WAAWN,GAE/B1L,GACFsJ,EAAmB5iB,IAAIqZ,EAAcC,GAGvCqJ,EAAiB3iB,IAAIqZ,EAAc,IAC9BwL,EACHzG,EAAe1f,IAAI2a,GAAgB,EAAI,MAGxB,IAAjBA,EACIoJ,EAAe8C,aAAapC,GAC5BV,EAAe+C,aAAarC,EAAS,IAG3C,MAAMsC,EAAiBhD,EAAeiD,gBAEhCvQ,EACJoN,EAA4BpM,gBAAgB8L,QAAQ9M,mBAEhDwQ,EAASC,GAAAA,GAAAA,cACfD,EAAOJ,aAAaE,GAEpB,MAAM9E,EAAQkF,GAAAA,GAAAA,cACdlF,EAAMmF,UAAUH,GAChBhF,EAAMC,cAAcmF,aAAa5Q,GAGjCiN,GACElK,EACArY,OAAOmmB,OAAO,CAAC,EAAG7D,GAAejK,GAAgC,CAC/DkG,eAAgB,IAAIpgB,IAAIogB,GACxBwE,qBACAzN,wBAIJwL,EAAMsF,gBAAe,GAErB5e,EAAS6e,SAAS,CAChB5iB,IAAKkf,EACL7B,MAAOA,IAETtZ,EAAS8e,cACT9e,EAAS8X,QACX,CCtGM,SAAUiH,GACd/e,EACAib,EACAP,EACAQ,EACAC,GAEA,MAAM,8BAAEtK,EAA6B,eAAEkG,GACrC2D,EACIsE,EAAmB9D,EAA4BpM,gBAAgB8L,QAC/DqE,EAAenE,GAAejK,GAE9BqO,EAAmBlf,EAASoY,SAAS+C,GAE3C,IAAK+D,EAIH,YAHA/N,QAAQC,KACN,uCAAuC+J,uBAK3C,MAAM,MAAE7B,GAAU4F,EAEZC,EAAuBH,EAAiBlR,mBAE1CmR,GAAcnR,qBAAuBqR,IACtC7F,EACEC,cACAmF,aAAaS,GAEhBpE,GACElK,EACArY,OAAOmmB,OAAO,CAAC,EAAGM,EAAc,CAC9BnR,mBAAoBqR,MAK1B,MAAMb,EAAUhF,EAA8B8F,YACxCC,EAAMf,EAAOgB,iBAEbC,EAA2B,GAC3BC,EAAyB,GAE/B,IAAK,MAAMxN,KAAgB+E,EACpBkI,EAAalI,eAAe1f,IAAI2a,IACnCuN,EAAyB/nB,KAAKwa,GAKlC,IAAK,MAAMA,KAAgBiN,EAAalI,eACjCA,EAAe1f,IAAI2a,IACtBwN,EAAuBhoB,KAAKwa,GAIhC,MAAMyN,EAA0BznB,MAAMC,KAAKgnB,EAAalI,gBACrD1c,QAAQ2X,IAAkBwN,EAAuBE,SAAS1N,KAC1D2N,OAAOJ,IAEJ,YAAEK,EAAW,uBAAEC,GAA2B5E,EAAY9S,QAC1D,CAAC2X,EAAKtE,KACJ,MAAMC,EAAWnD,GAAAA,MAAMoD,YAAYF,IAC3B3H,KAAMgI,GAAeJ,EACvBzJ,EAAgB6J,EAAiCF,kBACjD1J,EAAwBF,GAC5B2I,EACAc,EACAxJ,GAMF,OAHA8N,EAAIF,YAAYpoB,KAAKqkB,GACrBiE,EAAID,uBAAuB7N,GAAgBC,GAAyB,CAAC,EAE9D6N,CAAG,GAEZ,CAAEF,YAAa,GAAIC,uBAAwB,CAAC,IAGxCE,EAAmB,IACpBN,KACAD,GAGCQ,EAAiCxnB,OAAOynB,OAC5CJ,GACAK,MAAM1P,GAAWhY,OAAOsE,KAAK0T,GAAQxZ,OAAS,IAEhD,IAAImpB,GAAmB,EAEvB,GAAIJ,EAAiB/oB,QAAUgpB,EAAgC,CAC7D,MAAM5E,EAAiBkD,EAAO8B,eAExBC,EADgBjF,EAAe4C,eAAesC,aACZC,UAGxC,IAAIC,EAAS,EACbZ,EAAY/nB,SAASgkB,IACnB,MAAM7J,EAAgB6J,EAAiCF,kBACjDvjB,EAAOyjB,EAAW4E,yBAExB,GACEV,EAAiBL,SAAS1N,IAC1B6N,EAAuB7N,IAAe7D,UACtC,CACA,MAAMqP,EAAQ3B,EAAW4B,WACzB,IAAIxI,EAAawK,EAAwBC,SAAS1N,GAC9C,EACA,IAEJ,MAAM0O,EAAgBb,EAAuB7N,QACb/a,IAA5BypB,EAAcvS,YAChB8G,EAAuC,IAA1ByL,EAAcvS,WAG7B,IAAK,IAAIpH,EAAI,EAAGA,EAAI3O,IAAQ2O,EAC1BsZ,EAAkBG,EAAa,EAAJzZ,GAASyW,EAAM,GAC1C6C,EAAkBG,EAAa,EAAJzZ,EAAQ,GAAKyW,EAAM,GAC9C6C,EAAkBG,EAAa,EAAJzZ,EAAQ,GAAKyW,EAAM,GAC9C6C,EAAkBG,EAAa,EAAJzZ,EAAQ,GAAKkO,EAG1CkL,GAAmB,C,CAGrBK,GAAyB,EAAPpoB,CAAQ,IAGxB+nB,GACF/E,EAAeuF,WAGjB5F,GACElK,EACArY,OAAOmmB,OAAO,CAAC,EAAGM,EAAc,CAC9BlI,eAAgB,IAAIpgB,IAAIogB,MAI5BuH,EAAOsC,eAAevB,E,CAGxBrf,EAAS8X,QACX,CCxHA,SArBA,SACE1b,EACAyU,GAGA,MAAMxU,GAAiBC,EAAAA,GAAAA,mBAAkBF,IACnC,SAAE4D,GAAa3D,EAKfwkB,EAHgB7gB,EAAmC8gB,YAItDha,KAAIuJ,IAAA,IAAC,IAAEpU,GAAKoU,EAAA,OACXpU,EAAIyjB,SAAS7O,GAAiC5U,OAAMhF,CAAS,IAE9DoD,OAAO0mB,SAGV/gB,EAASghB,aAAaH,EACxB,ECqFA,UACE/I,OAzDFnD,eACE3U,EACAihB,EACAlJ,GAEA,MAAM,eAAErI,GAAmBuR,EAErBC,EADejJ,GAAkCvI,GACtBkE,mBAAmBsE,GAAgBlJ,UAC9D,YAAEiM,GAAgBiG,EAIpBlhB,aAAoB0V,GAAAA,gBAInBuF,GAAajkB,QAChBma,QAAQC,KACN,wCAAwC1B,uBCtExC,SACJ1P,EACAib,EACAP,EACAQ,GAEA,MAAM,8BAAErK,GAAkC6J,EACpC1F,EAAW,WAAWnE,KACd7Q,EAASoY,SAASpD,GAEF+J,GAAoB/D,IAEhDhb,EACAib,EACAP,EACAQ,EACAlG,EAEJ,CDyDEmM,CACEnhB,EACAib,EACAgG,EACAlJ,GAEJ,EA6BE/G,iCA5FF,SACEjB,EACAc,GACuB,IAAvBoJ,EAAeljB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAaf,GAiDF,SACEgZ,EACAc,GAEA,MAAMqJ,EAAYC,GAAapK,GAE/B,QAAkB9Y,IAAdijB,EACF,MAAM,IAAI3d,MAAM,8BAA8BwT,oBAGhD,MAAM,cAAEqK,GAAkBF,EAE1B,IAAK,MAAMG,KAAgBD,EAAe,CACxC,MAAM,WAAE7Y,EAAU,kBAAEC,GAAsB6Y,EACpChe,GAAiBie,EAAAA,GAAAA,wBACrB/Y,EACAC,GAEF4f,GACE/kB,EAAe2D,SAAS5D,QACxByU,E,CAGN,CAnFEwQ,CACEtR,EACAc,GAEFoH,GACElI,EACAc,GJNE,SAA4BA,GAChCgK,GAA4CxhB,OAC1CwX,EAEJ,CIKEyQ,CAAkBzQ,GAEdoJ,EAAiB,CACGE,GAAapK,GAAa0K,mBAClC5iB,SAAQwY,IAAsC,IAArC,WAAE9O,EAAU,kBAAEC,GAAmB6O,GAC/BiK,EAAAA,GAAAA,wBACrB/Y,EACAC,GAEaxB,SAAS8X,QAAQ,G,CAGtC,GEoCA,SA1EA,SACE/H,EACAwR,EACAC,GAEA,MAAMC,EACJ3R,GAA+BC,GAEjC,IACG0R,GACsC,IAAvCA,EAA4BzqB,OAE5B,OAGF,MAAM0qB,EAAiCD,EAA4B3a,KAChEgK,GAAmBA,EAAeD,gCAGrC,IAAI8Q,EAAgCJ,EACpC,GAAII,EAA+B,CAGjC,MAAMC,EAA+BL,EAA+BlnB,QACjEwnB,IACEH,EAA+BhC,SAASmC,KAG7C,GAAID,EAA6B5qB,OAAS,EACxC,MAAM,IAAIuF,MACR,+EAA+E+H,KAAKE,UAClFod,K,MAMND,EAAgCD,EAGlCC,EAA8B9pB,SAASiqB,KAKzC,SACE/R,EACAc,EACA2Q,GAEA,MAAMjR,EAA6BK,GACjCb,EACAc,IAGI,KAAElL,GAAS4K,EAEjB,GAAI5K,IAASnP,GAA4BuY,SACvCgT,GAAgB/Q,iCACdjB,EACAc,EACA2Q,OAEG,IAAI7b,IAASnP,GAA4BwY,QAO9C,MAAM,IAAIzS,MAAM,sBAAsBoJ,0BANtCqc,GAAehR,iCACbjB,EACAc,EACA2Q,E,CAKN,CA/BIS,CAAoBlS,EAAa+R,EAAqBN,EAAU,GAEpE,ECvBA,SA5BA,SAAkBlO,GAChB,IAAKA,EAAkBxC,eAAe+C,KACpC,MAAM,IAAItX,MACR,8GAIJ,MAAMqX,EAAqBN,EAAkBxC,eAC1C+C,KAEH,GAAI,aAAcD,EAAoB,CAMpC,IAJqB0E,GAAAA,MAAMC,UACxB3E,EAAsDc,UAIvD,MAAM,IAAInY,MACR,eACGqX,EAAsDc,2F,CAOjE,ECOA,SA7BA,SACEwN,GAEA,IAAKA,IAA2BA,EAAuBlrB,OACrD,MAAM,IAAIuF,MAAM,0DAGlB2lB,EAAuBrqB,SAASyb,IAC9B,QAAyCrc,IAArCqc,EAAkB5D,eACpB,MAAM,IAAInT,MACR,4FAIJ,QAAyCtF,IAArCqc,EAAkBxC,eACpB,MAAM,IAAIvU,MACR,4FAKF+W,EAAkBxC,eAAenL,OACjClH,GAAkCsQ,UAElCoT,GAAiB7O,E,GAGvB,ECZA,SAZA,SACE4O,GAEAE,GAA0BF,GAE1BA,EAAuBpb,KAAKub,IAG1BC,GAF0BhjB,KAAW+iB,GAEI,GAE7C,ECVA,SAAS3R,KACP,OAAOuH,IACT,CAMA,SAAStH,GACP4R,GAEAtK,GAAkCsK,EACpC,CAOA,SAASC,GACPC,GAGA,OADqB/R,KACD5B,gBAAgB2T,EACtC,CAUA,SAASC,GACPD,EACAjS,GAEA,MAAM5B,EAAe8B,KAErBC,GAAgB,IACX/B,EACHE,gBAAiB,IACZF,EAAaE,gBAChB,CAAC2T,GAAqB,IACjB7T,EAAaE,gBAAgB2T,MAC7BjS,KAIX,CAOA,SAASkB,GACP3B,GAEA,OAAOkI,GAA6ClI,EACtD,CASA,SAASsE,GACPtE,EACA4S,GAEA1K,GACElI,EACA4S,EAEJ,CAcA,SAAS/Q,GACP7B,EACAc,GAEA,OAAOoH,GACLlI,EACAc,EAEJ,CAYA,SAASiB,GACP/B,EACAc,EACAL,GAEAyH,GACElI,EACAc,EACAL,EAEJ,CAUA,SAASuB,GACPhC,EACAc,EACAmB,GAEA,OAAOiG,GACLlI,EACAc,EACAmB,EAEJ,CAWA,SAASE,GACPnC,EACAc,EACAL,GAEAyH,GACElI,EACAc,EACAL,EAEJ,CC7KM,SAAUoS,GACdC,GAEA,MAAM,KAAEld,GAASkd,EAEjB,OAAIld,IAASnP,GAA4BuY,SAChC+T,KAEA,CAAC,CAEZ,CCXA,MAkQA,GAlQ8B,CAC5B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,I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","sources":["webpack:///../../../../cornerstone3D/packages/tools/src/enums/ToolBindings.ts","webpack:///../../../../cornerstone3D/packages/tools/src/enums/ToolModes.ts","webpack:///../../../../cornerstone3D/packages/tools/src/enums/AnnotationStyleStates.ts","webpack:///../../../../cornerstone3D/packages/tools/src/enums/Events.ts","webpack:///../../../../cornerstone3D/packages/tools/src/enums/SegmentationRepresentations.ts","webpack:///../../../../cornerstone3D/packages/tools/src/enums/Touch.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/annotationLocking.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/annotationSelection.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/annotationVisibility.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/svgNodeCache.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/state.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/addTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/mouse/getMouseEventPoints.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/mouse/mouseDoubleClickListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/mouse/mouseMoveListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/mouse/mouseDownListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/mouse/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/touch/preventGhostClick.js","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/touch/getTouchEventPoints.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/touch/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/touch/touchStartListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/touch/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/wheel/normalizeWheel.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/wheel/wheelListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/wheel/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/keyboard/keyDownListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/keyboard/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/contourConfig.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/SegmentationStateManager.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/segmentationState.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/utils/stackVolumeCheck.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Labelmap/addLabelmapToElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Labelmap/removeLabelmapFromElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/utils.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/contourConfigCache.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/addContourSetsToElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/updateContourSets.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/removeContourFromElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/contourDisplay.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Contour/addOrUpdateContourSets.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Labelmap/validateRepresentationData.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/addSegmentations.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/config/segmentationConfig.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/helpers/getRepresentationSpecificConfig.ts","webpack:///../../../../cornerstone3D/packages/tools/src/constants/COLOR_LUT.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/addSegmentationRepresentation.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/activeSegmentation.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/segmentLocking.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/config/segmentationColor.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/segmentation/segmentIndex.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/base/BaseTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/getSvgDrawingHelper.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/draw.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/_getHash.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/setAttributesIfNecessary.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/setNewAttributesIfValid.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawCircle.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawEllipseByCoordinates.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawEllipse.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawHandles.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawLine.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawPolyline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawTextBox.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/vec2/findClosestPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawLink.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawLinkedTextBox.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawRect.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawArrow.ts","webpack:///../../../../cornerstone3D/packages/tools/src/drawingSvg/drawRedactionRect.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/getToolsWithModesForElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/triggerAnnotationRender.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planar/filterAnnotationsWithinSlice.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planar/filterAnnotationsForDisplay.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/config/ToolStyle.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/config/helpers.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/config/getState.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/config/getFont.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/base/AnnotationDisplayTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Surface/removeSurfaceFromElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/pointToString.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Surface/addSurfaceToElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/Surface/surfaceDisplay.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/displayTools/SegmentationDisplayTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/triggerSegmentationRender.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/segmentation/imageChangeEventListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/getAnnotationNearPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/isObject.js","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/debounce.js","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/throttle.js","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/clip.js","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/triggerAnnotationRenderForViewportIds.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/scroll.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewport/jumpToSlice.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/roundNumber.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/utils/isWithinThreshold.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/utils/getStrategyData.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/fillSphere.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/eraseSphere.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/fillCircle.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/eraseCircle.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/MouseCursor.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/ImageMouseCursor.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/SVGMouseCursor.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/setCursorForElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/cursors/elementCursor.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/BrushTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/thresholdVolumeByRange.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/AnnotationGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/PanTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/TrackballRotateTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/WindowLevelTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/StackScrollTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/angle/angleBetweenLines.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/PlanarRotateTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/StackScrollToolMouseWheelTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/ZoomTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/VolumeRotateMouseWheelTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planar/getWorldWidthAndHeightFromCorners.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planar/getPointInLineOfSightWithCriteria.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planar/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/MIPJumpToClickTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/point/mirror.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/polyline/getIntersectionWithPolyline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/polyline/calculateAreaOfPoints.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/CrosshairsTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/MagnifyTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/circle/getCanvasCircleRadius.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/circle/getCanvasCircleCorners.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/AdvancedMagnifyViewport.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/AdvancedMagnifyViewportManager.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/AdvancedMagnifyTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/ReferenceLinesTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/OverlayGridTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/SegmentationIntersectionTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/ReferenceCursors.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/ScaleOverlayTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/LengthTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/getModalityUnit.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/ProbeTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/DragProbeTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/RectangleROITool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planar/getWorldWidthAndHeightFromTwoPoints.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/EllipticalROITool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/CircleROITool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/splines/Spline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/splines/CubicSpline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/splines/CardinalSpline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/splines/LinearSpline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/splines/CatmullRomSpline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/splines/BSpline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/SplineROITool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planarFreehandROITool/interpolation/algorithms/bspline.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planarFreehandROITool/interpolatePoints.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/drawLoop.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/editLoopCommon.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/closedContourEditLoop.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/openContourEditLoop.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/openContourEndEditLoop.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/planarFreehandROITool/renderMethods.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/PlanarFreehandROITool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/ArrowAnnotateTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/AngleTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/midPoint.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/CobbAngleTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/KeyImageTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/fillRectangle.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/strategies/eraseRectangle.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/RectangleScissorsTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/CircleScissorsTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/SphereScissorsTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/segmentation/PaintFillTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/OrientationMarkerTool.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/isValidRepresentationConfig.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/brushSizeForToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/orientation/getOrientationStringLPS.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/orientation/invertOrientationStringLPS.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/cine/events.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/cine/state.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/cine/playClip.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planarFreehandROITool/interpolateAnnotation.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/stackPrefetch/state.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/stackPrefetch/stackPrefetchUtils.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/stackPrefetch/stackPrefetch.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/dynamicVolume/getDataInTime.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/polyData/utils.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/common/isRangeValid.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/math/vec3/interpolateVec3.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/ColorbarTicks.ts","webpack:///../../../../cornerstone3D/packages/tools/src/widgets/Widget.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../../cornerstone3D/packages/tools/src/utilities/getVOIMultipliers.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/annotations/annotationSelectionListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventListeners/annotations/annotationModifiedListener.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/customCallbackHandler.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseClick.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseDoubleClick.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/filterToolsWithMoveableHandles.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/filterToolsWithAnnotationsForElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/filterMoveableAnnotationTools.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getMouseModifier.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getActiveToolForMouseEvent.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getToolsWithModesForMouseEvent.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getToolsWithActionsForMouseEvent.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseDown.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseDownActivate.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseDrag.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseMove.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseUp.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseEventHandlers/mouseWheel.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/mouseToolEventDispatcher.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getActiveToolForKeyboardEvent.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/keyboardEventHandlers/keyDown.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/keyboardEventHandlers/keyUp.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getActiveToolForTouchEvent.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/shared/getToolsWithModesForTouchEvent.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchEventHandlers/touchStart.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchEventHandlers/touchStartActivate.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchEventHandlers/touchDrag.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchEventHandlers/touchEnd.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchEventHandlers/touchTap.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchEventHandlers/touchPress.ts","webpack:///../../../../cornerstone3D/packages/tools/src/eventDispatchers/touchToolEventDispatcher.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/addEnabledElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/removeEnabledElement.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/cancelActiveManipulations.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/Synchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/createSynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/destroy.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/getSynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/getAllSynchronizers.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/SynchronizerManager/destroySynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/ToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/createToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/destroyToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/destroy.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/getToolGroup.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/getAllToolGroups.ts","webpack:///../../../../cornerstone3D/packages/tools/src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/annotationState.ts","webpack:///../../../../cornerstone3D/packages/tools/src/stateManagement/annotation/helpers/state.ts","webpack:///../../../../cornerstone3D/packages/tools/src/init.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/callbacks/cameraSyncCallback.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/callbacks/voiSyncCallback.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/callbacks/imageSliceSyncCallback.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/synchronizers/createImageSliceSynchronizer.ts","webpack:///../../../../cornerstone3D/packages/tools/src/synchronizers/index.ts","webpack:///../../../../cornerstone3D/packages/tools/src/tools/annotation/VideoRedactionTool.ts"],"sourcesContent":["/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n}\n\nexport default AnnotationStyleStates;\n","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Tools\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new tools is activated.\n   *\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\n   */\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\n\n  /**\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\n   *\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\n   */\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\n\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  Surface = 'SURFACE',\n}\n\nexport default SegmentationRepresentations;\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation.metadata.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): void => {\n    const annotations = this.annotations;\n    if (annotations[groupKey]) {\n      if (toolName) {\n        delete annotations[groupKey][toolName];\n      } else {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   */\n  removeAllAnnotations = (): void => {\n    this.annotations = {};\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import _cloneDeep from 'lodash.clonedeep';\n\nimport { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = _cloneDeep(defaultState);\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { IPoints } from '../../types';\n\n/**\n * Given a native mouse event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Mouse event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getMouseEventPoints(\n  evt: MouseEvent,\n  element?: HTMLDivElement\n): IPoints {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const { viewport } = getEnabledElement(elementToUse);\n  const clientPoint = _clientToPoint(evt);\n  const pagePoint = _pageToPoint(evt);\n  const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n  const worldPoint = viewport.canvasToWorld(canvasPoint);\n\n  return {\n    page: pagePoint,\n    client: clientPoint,\n    canvas: canvasPoint,\n    world: worldPoint,\n  };\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param evt - The Mouse `Event`\n */\nfunction _pageToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.pageX, evt.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Mouse `Event`\n */\nfunction _clientToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.clientX, evt.clientY];\n}\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { EventTypes, IPoints } from '../../types';\n\n/**\n * Captures and normalizes the double click event. Emits as a cornerstoneTools3D\n * double click event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseDoubleClickListener(evt: MouseEvent): void {\n  const element = <HTMLDivElement>evt.currentTarget;\n\n  const { viewportId, renderingEngineId } = getEnabledElement(element);\n\n  const startPoints = getMouseEventPoints(evt, element);\n  const deltaPoints: IPoints = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  };\n\n  const eventDetail: EventTypes.MouseDoubleClickEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_DOUBLE_CLICK,\n    viewportId,\n    renderingEngineId,\n    camera: {},\n    element,\n    startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(\n    element,\n    Events.MOUSE_DOUBLE_CLICK,\n    eventDetail\n  );\n\n  if (consumed) {\n    // The Events.MOUSE_DOUBLE_CLICK was consumed, thus no other listener should handle this 'dblclick' event.\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseDoubleClickListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { MouseMoveEventDetail } from '../../types/EventTypes';\n\nconst eventName = Events.MOUSE_MOVE;\n\n/**\n * Captures and normalizes the mouse move event. Emits as a cornerstoneTools3D\n * mouse move event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseMoveListener(evt: MouseEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const currentPoints = getMouseEventPoints(evt);\n  const eventDetail: MouseMoveEventDetail = {\n    renderingEngineId,\n    viewportId,\n    camera: {},\n    element,\n    currentPoints,\n    eventName,\n    event: evt,\n  };\n\n  const consumed = !triggerEvent(element, eventName, eventDetail);\n\n  // Events.MOUSE_MOVE was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseMoveListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport Events from '../../enums/Events';\nimport mouseMoveListener from './mouseMoveListener';\nimport { EventTypes, IPoints } from '../../types';\nimport getMouseEventPoints from './getMouseEventPoints';\n\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } =\n  Events;\n\n// The amount of time in milliseconds within which a browser 'dblclick' event has to occur.\n// Any mouse down, up, down and up sequence taking longer than this time is considered to\n// NOT be a double click and any browser 'dblclick' event that subsequently occurs as a result\n// of such a sequence will be ignored. It is best to set this to a value that is less\n// than the system value for detecting a double click. Setting something too large\n// might detect a double click that does not constitute a browser 'dblclick' and thus\n// no mouse events for the sequence will get fired at all.\n//\n// TODO This module should detect and fire 'dblclick' events at its discretion and\n// ignore all those generated by the browser.\n//\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\n\n// This tolerance is how long to accept a secondary button down\nconst MULTI_BUTTON_TOLERANCE_MS = 150;\n\n// A drag (projected distance) during the double click timeout that is greater than this\n// value will cancel the timeout and suppress any double click that might occur.\n// This tolerance is particularly important on touch devices where some movement\n// might occur between the two clicks.\n//\n// TODO revisit this value for touch devices\n//\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\n\ninterface IMouseDownListenerState {\n  mouseButton: number;\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  isClickEvent: boolean;\n  clickDelay: number;\n  preventClickTimeout: ReturnType<typeof setTimeout>;\n  startPoints: IPoints;\n  lastPoints: IPoints;\n}\n\ninterface IDoubleClickState {\n  doubleClickTimeout: ReturnType<typeof setTimeout>;\n  mouseDownEvent: MouseEvent;\n  mouseUpEvent: MouseEvent;\n  ignoreDoubleClick: boolean;\n}\n\n// STATE\nconst defaultState: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  element: null,\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nlet state: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  element: null,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nconst doubleClickState: IDoubleClickState = {\n  doubleClickTimeout: null,\n  mouseDownEvent: null,\n  mouseUpEvent: null,\n  ignoreDoubleClick: false,\n};\n\n/**\n * Listens to mouse down events from the DOM and depending on interaction and further\n * interaction can emit the following mouse events:\n *\n * - MOUSE_DOWN\n * - MOUSE_DOWN_ACTIVATE\n * - MOUSE_DRAG (move while down)\n * - MOUSE_UP\n * - MOUSE_CLICK\n *\n * The mouse down is NOT handled immediately. Instead, a timeout is started to\n * determine if this mouse down is the first in a sequence that constitutes a\n * double click.\n *\n * @param evt - The Mouse event.\n * @private\n */\nfunction mouseDownListener(evt: MouseEvent) {\n  if (doubleClickState.doubleClickTimeout) {\n    // A second identical click will be a double click event, so ignore it\n    if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {\n      return;\n    }\n\n    // Record the second button or the changed button event as the initial\n    // button down state so that the multi-button event can be detected\n    doubleClickState.mouseDownEvent = evt;\n\n    // If second button is added, then ensure double click timeout is terminated\n    // and do not handle three or more button gestures.\n    _doStateMouseDownAndUp();\n    return;\n  }\n\n  // Handle multi-button clicks by adding a delay before handling them.\n  // Double clicks (left button only) physically take the user longer, so\n  // use a longer timeout, and for multi-button at the same time, the clicks\n  // are done at the same time by the user, just the system perceives them\n  // separately, so have a short timeout to allow catching both buttons.\n  doubleClickState.doubleClickTimeout = setTimeout(\n    _doStateMouseDownAndUp,\n    evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS\n  );\n\n  // First mouse down of a potential double click. So save it and start\n  // a timeout to determine a double click.\n  doubleClickState.mouseDownEvent = evt;\n  doubleClickState.ignoreDoubleClick = false;\n\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  state.mouseButton = evt.buttons;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n\n  state.preventClickTimeout = setTimeout(\n    _preventClickHandler,\n    state.clickDelay\n  );\n\n  // Prevent CornerstoneToolsMouseMove while mouse is down\n  state.element.removeEventListener('mousemove', mouseMoveListener);\n\n  const startPoints = getMouseEventPoints(evt, state.element);\n  state.startPoints = _copyPoints(startPoints);\n  state.lastPoints = _copyPoints(startPoints);\n\n  document.addEventListener('mouseup', _onMouseUp);\n  document.addEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Does the actual mouse down logic if the double click timer has expired or\n * a mouse drag has started.\n * @param evt the mouse down event\n * @private\n */\nfunction _doMouseDown(evt: MouseEvent) {\n  const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n\n  const eventDetail: EventTypes.MouseDownEventDetail = {\n    event: evt,\n    eventName: MOUSE_DOWN,\n    element: state.element,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPoints: state.startPoints,\n    lastPoints: state.startPoints,\n    currentPoints: state.startPoints,\n    deltaPoints,\n  };\n\n  state.lastPoints = _copyPoints(eventDetail.lastPoints);\n\n  // by triggering MOUSE_DOWN it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const notConsumed = triggerEvent(\n    eventDetail.element,\n    MOUSE_DOWN,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default behavior,\n  // create a new tool\n  if (notConsumed) {\n    triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n  }\n}\n\n/**\n *_onMouseDrag - Handle emission of drag events whilst the mouse is depressed.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseDrag(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (doubleClickState.doubleClickTimeout) {\n    if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n      // Dragging past the tolerance means no double click should occur.\n      _doStateMouseDownAndUp();\n    } else {\n      return;\n    }\n  }\n\n  const eventDetail: EventTypes.MouseDragEventDetail = {\n    event: evt,\n    eventName: MOUSE_DRAG,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: _copyPoints(state.startPoints),\n    lastPoints: _copyPoints(lastPoints),\n    currentPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n\n  // Events.MOUSE_DRAG was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n\n  // Update the last points\n  state.lastPoints = _copyPoints(currentPoints);\n}\n\n/**\n *_onMouseUp - Handle emission of mouse up events, and re-enabling mouse move events.\n *\n * If the mouse up event occurs during a double click timeout, it is either the first or\n * second mouse up of a potential double click sequence. If the first, then it\n * is saved in case the double click timeout expires and a simple mouse down and\n * up have to get executed. If the second, then the latest mouse down, up, down and\n * up constitute a double click and the mouseDoubleClickListener needs to execute.\n *\n * If the mouse up event comes after the double click timeout, then it is simply\n * handled as the up of a mouse down and up sequence.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseUp(evt: MouseEvent): void {\n  // Cancel the timeout preventing the click event from triggering\n  clearTimeout(state.preventClickTimeout);\n\n  if (doubleClickState.doubleClickTimeout) {\n    // received a mouse up while waiting for a double click (via a timeout)\n\n    if (!doubleClickState.mouseUpEvent) {\n      // this is the first mouse up during the double click timeout; we'll need it later if the timeout expires\n      doubleClickState.mouseUpEvent = evt;\n\n      state.element.addEventListener('mousemove', _onMouseMove);\n    } else {\n      // this is the second mouse up of a double click!\n      _cleanUp();\n    }\n  } else {\n    // Handle the actual mouse up. Note that it may have occurred during the double click timeout or\n    // after it expired. In either case this block is being executed after the time out has expired\n    // or after a drag started.\n\n    const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n    const eventDetail:\n      | EventTypes.MouseUpEventDetail\n      | EventTypes.MouseClickEventType = {\n      event: evt,\n      eventName,\n      mouseButton: state.mouseButton,\n      element: state.element,\n      renderingEngineId: state.renderingEngineId,\n      viewportId: state.viewportId,\n      camera: {},\n      startPoints: _copyPoints(state.startPoints),\n      lastPoints: _copyPoints(state.lastPoints),\n      currentPoints,\n      deltaPoints,\n    };\n\n    triggerEvent(eventDetail.element, eventName, eventDetail);\n\n    _cleanUp();\n  }\n\n  // Remove the drag as soon as we get the mouse up because either we have executed\n  // the mouse up logic, or we have not even handled the mouse down logic yet\n  // - either way no drag should/can occur.\n  document.removeEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Handles a mouse move on the state element after a mouse down AND up AND\n * while the double click timeout is still running.\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseMove(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n    return;\n  }\n\n  _doStateMouseDownAndUp();\n\n  // Do the move again because during the timeout the global mouse move listener was removed.\n  // Now it is back.\n  mouseMoveListener(evt);\n}\n\n/**\n * Determines if the given delta is past the double click, (projected) drag distance\n * tolerance.\n * @param delta the delta\n * @returns true iff the delta is past the tolerance\n */\nfunction _isDragPastDoubleClickTolerance(delta: Types.Point2): boolean {\n  return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\n\nfunction _preventClickHandler() {\n  state.isClickEvent = false;\n}\n\n/**\n * Do a mouse down and potential mouse up using each of the events in the double click state.\n * The events were stored in the state during the timeout to determine a double click.\n *\n * This function should be invoked whenever it is determined that the latest\n * sequence of mouse down(s) and up(s) is NOT a double click. Examples of this include\n * - the expiration of the double click timeout\n * - a mouse drag/move beyond the DOUBLE_CLICK_DRAG_TOLERANCE\n *\n * This function sets the doubleClickState.ignoreDoubleClick flag in case our timeout value\n * or mouse move/drag tolerance is inaccurate and we do indeed get a double click event from\n * the browser later. The flag will be cleared in the mouseDoubleClickIgnoreListener should a\n * double click event get fired. If there is no eventual double click for the latest sequence,\n * the flag spills into the next sequence where it will get cleared at the beginning of that next\n * sequence in mouseDownListener. It is perfectly safe for the flag to be\n * left true when no double click actually occurs because any future double click must start with\n * a mouse down that is handled in this module.\n *\n * @private\n */\nfunction _doStateMouseDownAndUp() {\n  doubleClickState.ignoreDoubleClick = true;\n\n  const mouseDownEvent = doubleClickState.mouseDownEvent;\n  const mouseUpEvent = doubleClickState.mouseUpEvent;\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  _doMouseDown(mouseDownEvent);\n\n  if (mouseUpEvent) {\n    _onMouseUp(mouseUpEvent);\n  }\n}\n\n/**\n * Clears the mouse events and double click timeout id in the double click state object.\n * The timeout itself is also cleared so that no callback is invoked.\n */\nfunction _clearDoubleClickTimeoutAndEvents() {\n  if (doubleClickState.doubleClickTimeout) {\n    clearTimeout(doubleClickState.doubleClickTimeout);\n    doubleClickState.doubleClickTimeout = null;\n  }\n\n  doubleClickState.mouseDownEvent = null;\n  doubleClickState.mouseUpEvent = null;\n}\n\nfunction _cleanUp() {\n  document.removeEventListener('mouseup', _onMouseUp);\n  state.element?.removeEventListener('mousemove', _onMouseMove);\n\n  // Restore our global mousemove listener\n  state.element?.addEventListener('mousemove', mouseMoveListener);\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  state = JSON.parse(JSON.stringify(defaultState));\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction _copyPoints(points: IPoints): IPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateMouseEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: IPoints\n): IPoints {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  const world = viewport.canvasToWorld(lastPoints.canvas);\n\n  return {\n    page: lastPoints.page,\n    client: lastPoints.client,\n    canvas: lastPoints.canvas,\n    world,\n  };\n}\n\n/**\n * Returns the difference between two `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction _getDeltaPoints(currentPoints: IPoints, lastPoints: IPoints): IPoints {\n  return {\n    page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n    client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n    canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n    world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n  };\n}\n\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nexport function getMouseButton(): number {\n  return state.mouseButton;\n}\n\n/**\n * Handles a dblclick event to determine if it should be ignored based on the\n * double click state's ignoreDoubleClick flag. stopImmediatePropagation and\n * preventDefault are used to ignore the event.\n * @param evt browser dblclick event\n */\nexport function mouseDoubleClickIgnoreListener(evt: MouseEvent) {\n  if (doubleClickState.ignoreDoubleClick) {\n    doubleClickState.ignoreDoubleClick = false;\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  } else {\n    // If the embedding application blocked the first mouse down and up\n    // of a double click sequence from reaching this module, then this module\n    // has handled the second mouse down and up and thus needs to clean them up.\n    // Doing a clean up here for the typical double click case is harmless.\n    _cleanUp();\n  }\n}\n\nexport default mouseDownListener;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","// Functions to prevent ghost clicks following a touch\n// Since the event lifecycle is touchstart, mousedown, touchend, mouseup\n// we want to prevent mousedown and mouseup events after touch events\n// All credit to @kosich\n// https://gist.github.com/kosich/23188dd86633b6c2efb7\n\nconst antiGhostDelay = 2000,\n  pointerType = {\n    mouse: 0,\n    touch: 1,\n  };\n\nlet lastInteractionType, lastInteractionTime;\n\nfunction handleTap(type, e) {\n  const now = Date.now();\n\n  if (type !== lastInteractionType) {\n    if (now - lastInteractionTime <= antiGhostDelay) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n\n      return false;\n    }\n\n    lastInteractionType = type;\n  }\n\n  lastInteractionTime = now;\n}\n\n// Cacheing the function references\n// Necessary because a new function reference is created after .bind() is called\n// http://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\n\nfunction attachEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.addEventListener(eventName, tapHandler, { passive: false });\n  });\n}\n\nfunction removeEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.removeEventListener(eventName, tapHandler);\n  });\n}\n\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\n\nfunction disable(element) {\n  removeEvents(element, mouseEvents, pointerType.mouse);\n  removeEvents(element, touchEvents, pointerType.touch);\n}\n\nfunction enable(element) {\n  disable(element);\n  attachEvents(element, mouseEvents, pointerType.mouse);\n  attachEvents(element, touchEvents, pointerType.touch);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { ITouchPoints } from '../../types';\n\n/**\n * Given a native touch event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Touch event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getTouchEventPoints(\n  evt: TouchEvent,\n  element?: HTMLDivElement\n): ITouchPoints[] {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n  return Object.keys(touches).map((i) => {\n    const clientPoint = _clientToPoint(touches[i]);\n    const pagePoint = _pageToPoint(touches[i]);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const { viewport } = getEnabledElement(elementToUse);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n      page: pagePoint,\n      client: clientPoint,\n      canvas: canvasPoint,\n      world: worldPoint,\n      touch: {\n        identifier: i,\n        radiusX: touches[i].radiusX,\n        radiusY: touches[i].radiusY,\n        force: touches[i].force,\n        rotationAngle: touches[i].rotationAngle,\n      },\n    };\n  });\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param touch - The Touch\n */\nfunction _pageToPoint(touch: Touch): Types.Point2 {\n  return [touch.pageX, touch.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Touch `Event`\n */\nfunction _clientToPoint(touch: Touch): Types.Point2 {\n  return [touch.clientX, touch.clientY];\n}\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\n\nimport { EventTypes, ITouchPoints, IPoints, IDistance } from '../../types';\n\nimport getTouchEventPoints from './getTouchEventPoints';\nimport {\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaDistance,\n  getDeltaPoints,\n  getMeanTouchPoints,\n  // getRotation\n} from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\n\nconst runtimeSettings = Settings.getRuntimeSettings();\n\nconst {\n  TOUCH_START,\n  TOUCH_START_ACTIVATE,\n  TOUCH_PRESS,\n  TOUCH_DRAG,\n  TOUCH_END,\n  TOUCH_TAP,\n  TOUCH_SWIPE,\n} = Events;\n\ninterface ITouchTapListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  tapMaxDistance: number;\n  tapTimeout: ReturnType<typeof setTimeout>;\n  taps: number;\n  tapToleranceMs: number;\n}\n\ninterface ITouchStartListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  lastPointsList: ITouchPoints[];\n\n  // only trigger one touch event in the case the user puts down multiple fingers\n  isTouchStart: boolean;\n  startTime: Date;\n\n  // handle long press\n  pressTimeout: ReturnType<typeof setTimeout>;\n  pressDelay: number;\n  pressMaxDistance: number;\n  accumulatedDistance: IDistance;\n\n  // handle swipes\n  swipeDistanceThreshold: number;\n  swiped: boolean;\n  swipeToleranceMs: number;\n}\n\nconst zeroIPoint: IPoints = {\n  page: [0, 0],\n  client: [0, 0],\n  canvas: [0, 0],\n  world: [0, 0, 0],\n};\n\nconst zeroIDistance: IDistance = {\n  page: 0,\n  client: 0,\n  canvas: 0,\n  world: 0,\n};\n\n// STATE\nconst defaultState: ITouchStartListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  lastPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  isTouchStart: false,\n  startTime: null,\n\n  pressTimeout: null,\n  pressDelay: 700,\n  pressMaxDistance: 5,\n  accumulatedDistance: zeroIDistance,\n\n  swipeDistanceThreshold: 48,\n  swiped: false,\n  swipeToleranceMs: 300, // user has 300ms to swipe after touch start or no swipe will trigger\n};\n\n// TODO: these values should be configurable to handle different use cases such\n// as pen, left/right handed, index finger vs thumb, etc. These current values\n// assume thumb usage for single finger and index/middle finger for two finger\n// gestures in an attempt to cover the 90% use case.\nconst defaultTapState: ITouchTapListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  taps: 0,\n  tapTimeout: null,\n  tapMaxDistance: 24,\n  tapToleranceMs: 300,\n};\n\nlet state: ITouchStartListenerState = JSON.parse(JSON.stringify(defaultState));\nlet tapState: ITouchTapListenerState = JSON.parse(\n  JSON.stringify(defaultTapState)\n);\n\nfunction triggerEventCallback(ele, name, eventDetail) {\n  return triggerEvent(ele, name, eventDetail);\n}\n\n/**\n * Listens to touch events from the DOM (touchstart, touchmove, touchend)\n * and depending on interaction and further interaction can emit the\n * following touch events:\n *\n * - TOUCH_START\n * - TOUCH_START_ACTIVATE\n * - TOUCH_PRESS\n * - TOUCH_DRAG (move while down)\n * - TOUCH_SWIPE\n * - TOUCH_END (also an end for multi touch)\n *\n * - TOUCH_TAP\n *\n * @param evt - The Touch event (touchstart).\n * @private\n */\nfunction touchStartListener(evt: TouchEvent) {\n  // if a user adds an extra finger when a touch/multi touch has already started\n  // don't trigger another touch.\n  state.element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  // this prevents multiple start firing\n  if (state.isTouchStart) {\n    return;\n  }\n  // this will clear on touchstart and touchend\n  clearTimeout(state.pressTimeout);\n  state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n\n  _onTouchStart(evt);\n  document.addEventListener('touchmove', _onTouchDrag); // also checks for swipe\n  document.addEventListener('touchend', _onTouchEnd); // also checks for tap\n}\n\n/**\n * _onTouchPress - Handle emission of touchstart events which are held down for a longer\n * period of time\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchPress(evt: TouchEvent) {\n  const totalDistance = state.accumulatedDistance.canvas;\n  if (totalDistance > state.pressMaxDistance) {\n    return;\n  }\n  const eventDetail: EventTypes.TouchPressEventDetail = {\n    event: evt, // touchstart native event\n    eventName: TOUCH_PRESS,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(state.lastPointsList),\n    startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n    lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n  };\n  triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\n\n/**\n * _onTouchStart - Handle emission of touchstart events.\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchStart(evt: TouchEvent) {\n  state.isTouchStart = true;\n  state.startTime = new Date();\n  const startPointsList = getTouchEventPoints(evt, state.element);\n  const startPoints = getMeanTouchPoints(startPointsList);\n  const deltaPoints = zeroIPoint;\n  const deltaDistance = zeroIDistance;\n  // deltaRotation same as deltaDistance but values are theta\n  const eventDetail: EventTypes.TouchStartEventDetail = {\n    event: evt,\n    eventName: TOUCH_START,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: startPointsList,\n    lastPointsList: startPointsList,\n    currentPointsList: startPointsList,\n    startPoints: startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n    deltaDistance,\n    // deltaRotation\n  };\n\n  state.startPointsList = copyPointsList(eventDetail.startPointsList);\n  state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n  // by triggering TOUCH_START it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const eventDidPropagate = triggerEventCallback(\n    eventDetail.element,\n    TOUCH_START,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default propagation behavior,\n  // create a new tool\n  if (eventDidPropagate) {\n    triggerEventCallback(\n      eventDetail.element,\n      TOUCH_START_ACTIVATE,\n      eventDetail\n    );\n  }\n}\n\n/**\n * _onTouchDrag - Handle emission of drag events whilst the touch is depressed.\n *\n * @private\n * @param evt - The touch event (touchmove)\n */\nfunction _onTouchDrag(evt: TouchEvent) {\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : zeroIPoint;\n\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : zeroIDistance;\n\n  const totalDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistance(currentPointsList, state.lastPointsList)\n      : zeroIDistance;\n\n  state.accumulatedDistance = {\n    page: state.accumulatedDistance.page + totalDistance.page,\n    client: state.accumulatedDistance.client + totalDistance.client,\n    canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n    world: state.accumulatedDistance.world + totalDistance.world,\n  };\n\n  /**\n   * this is can be uncommented to make dragging smoother. In the future, these values\n   * should be in a configuration file. There may also need to be different\n   * profiles for left handed and right handed thumb use. These values\n   * are currently optimized for left handed use.\n   *\n   * const clamp = (num) => Math.min(Math.max(num, -15), 10);\n   * const deltaDistanceClamped = \\{\n   *     page: clamp(deltaDistance.page),\n   *     client: clamp(deltaDistance.client),\n   *     canvas: clamp(deltaDistance.canvas),\n   *     world: clamp(deltaDistance.world),\n   * \\};\n   */\n\n  const eventDetail: EventTypes.TouchDragEventDetail = {\n    event: evt,\n    eventName: TOUCH_DRAG,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    deltaPoints: deltaPoints,\n    deltaDistance: deltaDistance,\n  };\n\n  triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n\n  // check for swipe events\n  _checkTouchSwipe(evt, deltaPoints);\n\n  // Update the last points\n  state.lastPointsList = copyPointsList(currentPointsList);\n}\n\n/**\n * _onTouchEnd - Handle emission of touch end events\n *\n * @private\n * @param evt - The touch event.\n */\nfunction _onTouchEnd(evt: TouchEvent): void {\n  // in case it was a tap event we don't want to fire the cornerstone normalized\n  // touch end event if the touch start never happend\n  clearTimeout(state.pressTimeout);\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : getDeltaPoints(currentPointsList, currentPointsList);\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n  const eventDetail: EventTypes.TouchEndEventDetail = {\n    event: evt,\n    eventName: TOUCH_END,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    deltaPoints,\n    deltaDistance,\n  };\n\n  triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n  _checkTouchTap(evt);\n\n  // reset to default state\n  state = JSON.parse(JSON.stringify(defaultState));\n  document.removeEventListener('touchmove', _onTouchDrag);\n  document.removeEventListener('touchend', _onTouchEnd);\n}\n\nfunction _checkTouchTap(evt: TouchEvent): void {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (currentTime - startTime > tapState.tapToleranceMs) {\n    return;\n  }\n\n  // first tap, initialize the state\n  if (tapState.taps === 0) {\n    tapState.element = state.element;\n    tapState.renderingEngineId = state.renderingEngineId;\n    tapState.viewportId = state.viewportId;\n    tapState.startPointsList = state.startPointsList;\n  }\n\n  // subsequent tap is on a different element\n  if (\n    tapState.taps > 0 &&\n    !(\n      tapState.element == state.element &&\n      tapState.renderingEngineId == state.renderingEngineId &&\n      tapState.viewportId == state.viewportId\n    )\n  ) {\n    return;\n  }\n\n  const currentPointsList = getTouchEventPoints(evt, tapState.element);\n  const distanceFromStart = getDeltaDistance(\n    currentPointsList,\n    tapState.startPointsList\n  ).canvas;\n\n  // if the tap is too far from starting tap, we can ignore it.\n  // TODO: in the case the user means to tap in two separate areas within the\n  // tapTolerance (300ms), the second tap will not trigger. This is because it\n  // is ignored below for simplicity to track multiple taps (double, triple etc)\n  // in order to support two separate single taps that occur < 300ms on the\n  // screen. One can create the concept of \"TapChains\". Our current implementation\n  // only supports a single tap chain on the screen. You can think of it as a\n  // region where the user has the option to perform unlimited multitaps as long\n  // as they are < the tapToleranceMs value. So a tap somewhere else on the screen\n  // that is > the tapMaxDistance will start a separate and new \"TapChain\".\n  if (distanceFromStart > tapState.tapMaxDistance) {\n    return;\n  }\n\n  clearTimeout(tapState.tapTimeout);\n  tapState.taps += 1;\n\n  tapState.tapTimeout = setTimeout(() => {\n    const eventDetail: EventTypes.TouchTapEventDetail = {\n      event: evt,\n      eventName: TOUCH_TAP,\n      element: tapState.element,\n      renderingEngineId: tapState.renderingEngineId,\n      viewportId: tapState.viewportId,\n      camera: {},\n      currentPointsList,\n      currentPoints: getMeanTouchPoints(currentPointsList),\n      taps: tapState.taps,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n    tapState = JSON.parse(JSON.stringify(defaultTapState));\n  }, tapState.tapToleranceMs);\n}\n\nfunction _checkTouchSwipe(evt: TouchEvent, deltaPoints: IPoints) {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (state.swiped || currentTime - startTime > state.swipeToleranceMs) {\n    return;\n  }\n  const [x, y] = deltaPoints.canvas;\n  const eventDetail: EventTypes.TouchSwipeEventDetail = {\n    event: evt,\n    eventName: TOUCH_SWIPE,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    swipe: null,\n  };\n  if (Math.abs(x) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n\n  if (Math.abs(y) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateTouchEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: ITouchPoints[]\n): ITouchPoints[] {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  return lastPoints.map((lp) => {\n    const world = viewport.canvasToWorld(lp.canvas);\n    return {\n      page: lp.page,\n      client: lp.client,\n      canvas: lp.canvas,\n      world,\n      touch: lp.touch,\n    };\n  });\n}\n\nexport default touchStartListener;\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Normalizes wheel events and provides properties that are more\n * consistent and helpful across different browsers\n *\n * @param event - the original mouse event\n * @returns a normalized eventDetail\n */\nexport default function normalizeWheel(event) {\n  let spinX = 0,\n    spinY = 0,\n    pixelX = 0,\n    pixelY = 0;\n\n  // Legacy\n  if ('detail' in event) {\n    spinY = event.detail;\n  }\n  if ('wheelDelta' in event) {\n    spinY = -event.wheelDelta / 120;\n  }\n  if ('wheelDeltaY' in event) {\n    spinY = -event.wheelDeltaY / 120;\n  }\n  if ('wheelDeltaX' in event) {\n    spinX = -event.wheelDeltaX / 120;\n  }\n\n  pixelX = spinX * PIXEL_STEP;\n  pixelY = spinY * PIXEL_STEP;\n\n  if ('deltaY' in event) {\n    pixelY = event.deltaY;\n  }\n  if ('deltaX' in event) {\n    pixelX = event.deltaX;\n  }\n\n  if ((pixelX || pixelY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // Delta in LINE units\n      pixelX *= LINE_HEIGHT;\n      pixelY *= LINE_HEIGHT;\n    } else {\n      // Delta in PAGE units\n      pixelX *= PAGE_HEIGHT;\n      pixelY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pixelX && !spinX) {\n    spinX = pixelX < 1 ? -1 : 1;\n  }\n  if (pixelY && !spinY) {\n    spinY = pixelY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX,\n    spinY,\n    pixelX,\n    pixelY,\n  };\n}\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\n// ~~ VIEWPORT LIBRARY\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nimport { MouseWheelEventDetail } from '../../types/EventTypes';\n\n/**\n * wheelListener - Captures and normalizes mouse wheel events. Emits as a\n * cornerstoneTools3D mouse wheel event.\n * @param evt - The mouse wheel event.\n */\nfunction wheelListener(evt: WheelEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  // Prevent triggering MouseWheel events that are not real scroll events:\n  // E.g. when clicking the MiddleMouseWheelButton, a deltaY of 0 is emitted.\n  // See https://github.com/cornerstonejs/cornerstoneTools/issues/935\n  if (evt.deltaY > -1 && evt.deltaY < 1) {\n    return;\n  }\n\n  evt.preventDefault();\n\n  const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n  const direction = spinY < 0 ? -1 : 1;\n\n  const eventDetail: MouseWheelEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_WHEEL,\n    renderingEngineId,\n    viewportId,\n    element,\n    camera: {},\n    detail: evt,\n    wheel: {\n      spinX,\n      spinY,\n      pixelX,\n      pixelY,\n      direction,\n    },\n    points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\n\nexport default wheelListener;\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import _cloneDeep from 'lodash.clonedeep';\nimport { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { KeyDownEventDetail, KeyUpEventDetail } from '../../types/EventTypes';\n\ninterface IKeyDownListenerState {\n  renderingEngineId: string;\n  viewportId: string;\n  key: string | null;\n  keyCode: number | null;\n  element: HTMLDivElement;\n}\n\nconst defaultState: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\nlet state: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\n/**\n * Normalizes the keyboard event and triggers KEY_DOWN event from CornerstoneTools3D events\n * @param evt - DOM Keyboard event\n */\nfunction keyListener(evt: KeyboardEvent): void {\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  state.key = evt.key;\n  state.keyCode = evt.keyCode;\n\n  evt.preventDefault();\n  const eventDetail: KeyDownEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n\n    // detail: evt,\n    // Todo: mouse event points can be used later for placing tools with a key\n    // e.g., putting an arrow/probe/etc. on the mouse position. Another use case\n    // hovering and deleting the tool\n    // points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n\n  document.addEventListener('keyup', _onKeyUp);\n  document.addEventListener('visibilitychange', _onVisibilityChange);\n\n  // Todo: handle combination of keys\n  state.element.removeEventListener('keydown', keyListener);\n}\n\n/**\n * Whenever the visibility (i.e. tab focus) changes such that the tab is NOT the\n * active tab, reset the modifier key.\n */\nfunction _onVisibilityChange(): void {\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  if (document.visibilityState === 'hidden') {\n    resetModifierKey();\n  }\n}\n\nfunction _onKeyUp(evt: KeyboardEvent): void {\n  const eventDetail: KeyUpEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n    // detail: evt,\n  };\n\n  // Remove our temporary handlers\n  document.removeEventListener('keyup', _onKeyUp);\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  state.element.addEventListener('keydown', keyListener);\n\n  // Restore `state` to `defaultState`\n  state = _cloneDeep(defaultState);\n  triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\n\nexport function getModifierKey(): number | undefined {\n  return state.keyCode;\n}\n\nexport function resetModifierKey(): void {\n  state.keyCode = undefined;\n}\n\nexport default keyListener;\n","import keyDownListener, { getModifierKey } from './keyDownListener';\n\nfunction enable(element: HTMLDivElement): void {\n  disable(element);\n  element.addEventListener('keydown', keyDownListener);\n}\n\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('keydown', keyDownListener);\n}\n\nexport default {\n  enable,\n  disable,\n  getModifierKey,\n};\n","import { ContourConfig } from '../../../types/ContourTypes';\n\nconst defaultContourConfig: ContourConfig = {\n  renderOutline: true,\n  outlineWidthActive: 2,\n  outlineWidthInactive: 2,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n  renderFill: true,\n  fillAlpha: 1,\n  fillAlphaInactive: 0,\n};\n\nfunction getDefaultContourConfig(): ContourConfig {\n  return defaultContourConfig;\n}\n\nexport default getDefaultContourConfig;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import cloneDeep from 'lodash.clonedeep';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): Types.ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  getNextColorLUTIndex(): number {\n    return this.state.colorLUT.length;\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Returns an array of all segmentation representations for all tool groups.\n   * @returns An array of ToolGroupSpecificRepresentations.\n   */\n  getAllSegmentationRepresentations(): Record<\n    string,\n    ToolGroupSpecificRepresentation[]\n  > {\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\n      {};\n    Object.entries(this.state.toolGroups).forEach(\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\n        toolGroupSegReps[toolGroupId] =\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n      }\n    );\n    return toolGroupSegReps;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentSpecificConfig = config;\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: Types.ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.warn('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = structuredClone(colorLUT);\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...representation.data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import type { Types } from '@cornerstonejs/core';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get all segmentation representations in the state\n * @returns An array of segmentation representation objects.\n */\nfunction getAllSegmentationRepresentations(): Record<\n  string,\n  ToolGroupSpecificRepresentation[]\n> {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getAllSegmentationRepresentations();\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  if (!segmentationId) {\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\n  }\n\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): Types.ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\nfunction getNextColorLUTIndex(): number {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getNextColorLUTIndex();\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getAllSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n  // color\n  addColorLUT,\n  getColorLUT,\n  getNextColorLUTIndex,\n  removeColorLUT,\n};\n","import {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  LabelmapToolOperationData,\n  LabelmapToolOperationDataStack,\n  LabelmapToolOperationDataVolume,\n} from '../../../../types';\n\nfunction isStackSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData\n): operationData is\n  | LabelmapToolOperationDataStack\n  | LabelmapSegmentationDataStack {\n  return (\n    (operationData as LabelmapToolOperationDataStack).imageIdReferenceMap !==\n    undefined\n  );\n}\n\nfunction isVolumeSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData\n): operationData is\n  | LabelmapToolOperationDataVolume\n  | LabelmapSegmentationDataVolume {\n  return (\n    (operationData as LabelmapToolOperationDataVolume).volumeId !== undefined\n  );\n}\n\nexport { isStackSegmentation, isVolumeSegmentation };\n","import {\n  getEnabledElement,\n  addVolumesToViewports,\n  addImageSlicesToViewports,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n} from '../../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\n/**\n * It adds a labelmap segmentation representation of the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that will be rendered.\n * @param volumeId - The volume id of the labelmap.\n * @param segmentationRepresentationUID - The segmentation representation UID.\n *\n * @internal\n */\nasync function addLabelmapToElement(\n  element: HTMLDivElement,\n  labelMapData: LabelmapSegmentationData,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n  const { id: viewportId } = viewport;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const visibility = true;\n  const immediateRender = false;\n  const suppressEvents = true;\n\n  if (isVolumeSegmentation(labelMapData)) {\n    // Todo: Right now we use MIP blend mode for the labelmap, since the\n    // composite blend mode has a non linear behavior regarding fill and line\n    // opacity. This should be changed to a custom labelmap blendMode which does\n    // what composite does, but with a linear behavior.\n    const volumeInputs: Types.IVolumeInput[] = [\n      {\n        volumeId: labelMapData.volumeId,\n        actorUID: segmentationRepresentationUID,\n        visibility,\n        blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n      },\n    ];\n\n    // Add labelmap volumes to the viewports to be be rendered, but not force the render\n    await addVolumesToViewports(\n      renderingEngine,\n      volumeInputs,\n      [viewportId],\n      immediateRender,\n      suppressEvents\n    );\n  } else {\n    // We can use the current imageId in the viewport to get the segmentation imageId\n    // which later is used to create the actor and mapper.\n    const segmentationImageId = (\n      labelMapData as LabelmapSegmentationDataStack\n    ).imageIdReferenceMap.get(viewport.getCurrentImageId());\n\n    const stackInputs: Types.IStackInput[] = [\n      {\n        imageId: segmentationImageId,\n        actorUID: segmentationRepresentationUID,\n      },\n    ];\n\n    // Add labelmap volumes to the viewports to be be rendered, but not force the render\n    await addImageSlicesToViewports(\n      renderingEngine,\n      stackInputs,\n      [viewportId],\n      immediateRender,\n      suppressEvents\n    );\n  }\n}\n\nexport default addLabelmapToElement;\n","import { StackViewport, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the labelmap segmentation representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the labelmap representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeLabelmapFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (viewport instanceof StackViewport) {\n    // Todo: we don't have stack segmentation yet\n    return;\n  }\n\n  (viewport as Types.IVolumeViewport).removeVolumeActors([\n    segmentationRepresentationUID,\n  ]);\n}\n\nexport default removeLabelmapFromElement;\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n  LabelmapSegmentationData,\n} from '../../../types/LabelmapTypes';\nimport {\n  RepresentationPublicInput,\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\n\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\nfunction getRepresentationRenderingConfig() {\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n  ofun.addPoint(0, 0);\n  return {\n    ofun,\n    cfun,\n  };\n}\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * Checks if a segmentation data have the same frameOfReference as the series\n * displayed in a given viewport\n * @param viewport\n * @param referencedVolumeId volume id of the segmentation reference series\n * @returns\n */\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n  // if the referencedVolumeId is not defined, we acted as before to not break\n  // applications as referencedVolumeId is inserted in this change\n  // Can modify that in the future commits\n  if (!referencedVolumeId) {\n    return true;\n  }\n  const defaultActor = viewport.getDefaultActor();\n  if (!defaultActor) {\n    return false;\n  }\n  const { uid: defaultActorUID } = defaultActor;\n  const volume = cache.getVolume(defaultActorUID);\n\n  if (volume) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (\n      referencedVolume &&\n      volume.metadata.FrameOfReferenceUID ===\n        referencedVolume.metadata.FrameOfReferenceUID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const labelmapData =\n    segmentation.representationData[Representations.Labelmap];\n\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId: labelmapUID } = labelmapData;\n\n    const labelmap = cache.getVolume(labelmapUID);\n\n    if (!labelmap) {\n      throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n    }\n\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  } else {\n    // stack segmentation\n    const imageId = viewport.getCurrentImageId();\n    const { imageIdReferenceMap } = labelmapData;\n\n    // if the stack labelmap is not built for the current imageId that is\n    // rendered at the viewport then return\n    if (!imageIdReferenceMap.has(imageId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  if (!actorEntry) {\n    return;\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  // Todo: the below loop probably can be optimized so that we don't hit it\n  // unless a config has changed. Right now we get into the following loop\n  // even for brush drawing which does not makes sense\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  const actor = actorEntry.actor as Types.Actor;\n\n  // @ts-ignore\n  actor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n\n  // @ts-ignore\n  actor.getProperty().setScalarOpacity(0, ofun);\n  // @ts-ignore\n  actor.getProperty().setInterpolationTypeToNearest();\n\n  if (utilities.actorIsA(actorEntry, 'vtkVolume')) {\n    // @ts-ignore\n    actor.getProperty().setUseLabelOutline(renderOutline);\n    // @ts-ignore\n    actor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n    // @ts-ignore\n    actor.getProperty().setLabelOutlineThickness(outlineWidth);\n  }\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  actor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor: segmentColor.slice(), // Create a copy\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  labelmapData: LabelmapSegmentationData,\n  segmentationRepresentationUID\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    labelmapData,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n\nexport {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { ToolGroupSpecificContourRepresentation } from '../../../types';\n\n/**\n * If the segment specific config exists for the given segment id, it returns\n * the segment specific config. Otherwise, it looks for the segment specific\n * config for the given index. If it doesn't exist, it returns null.\n *\n * @param contourRepresentation -  The representation object that is passed\n * to the tool.\n * @param segmentId -  The id of the segment.\n * @param index -  The index of the segment in the list of segments.\n * @returns the segment specific config for the given segment id.\n *\n */\nexport function getSegmentSpecificConfig(\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  segmentId: string,\n  index: number\n) {\n  let segmentSpecificConfig =\n    contourRepresentation.segmentSpecificConfig?.[segmentId];\n\n  if (!segmentSpecificConfig) {\n    // try the index\n    segmentSpecificConfig =\n      contourRepresentation.segmentSpecificConfig?.[index];\n  }\n\n  if (!segmentSpecificConfig) {\n    return null;\n  }\n\n  return segmentSpecificConfig.CONTOUR;\n}\n\n/**\n * takes a geometry object as an argument\n * and throws an error if the geometry object is not a contour\n * @param geometry -  The geometry object to be rendered.\n */\nexport function validateGeometry(geometry: Types.IGeometry): void {\n  if (!geometry) {\n    throw new Error(`No contours found for geometryId ${geometry.id}`);\n  }\n\n  const geometryId = geometry.id;\n\n  if (geometry.type !== Enums.GeometryType.CONTOUR) {\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No contours found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n}\n\n/**\n * It takes a contourSet and returns a vtkPolyData for that contourSet. A contour set\n * is a collection of contours. Each contour is a collection of points. Each point\n * is x,y,z in the world coordinate system.\n *\n * @param contourSet -  the contour set that you want to convert to polyData\n * @returns A vtkPolyData object\n */\nexport function getPolyData(contourSet: Types.IContourSet) {\n  const pointArray = [];\n\n  const points = vtkPoints.newInstance();\n  const lines = vtkCellArray.newInstance();\n\n  // this variable will indicate the index of the first point in the current line\n  // so we can correctly generate the point index list to add in the cellArray\n  let pointIndex = 0;\n  contourSet.getContours().forEach((contour: Types.IContour) => {\n    const pointList = contour.getPoints();\n    const flatPoints = contour.getFlatPointsArray();\n    const type = contour.getType();\n\n    // creating a point index list that defines a line\n    const pointIndexes = pointList.map(\n      (_, pointListIndex) => pointListIndex + pointIndex\n    );\n\n    // if close planar, add the first point index to the list\n    if (type === Enums.ContourType.CLOSED_PLANAR) {\n      pointIndexes.push(pointIndexes[0]);\n    }\n\n    const linePoints = Float32Array.from(flatPoints);\n    // add the current points into the point list\n    pointArray.push(...linePoints);\n    // add the point indexes into the cell array\n    lines.insertNextCell([...pointIndexes]);\n    // update the first point index\n    pointIndex = pointIndex + pointList.length;\n  });\n\n  // converts the pointArray into vtkPoints\n  points.setData(pointArray, 3);\n\n  // creates the polyData\n  const polygon = vtkPolyData.newInstance();\n  polygon.setPoints(points);\n  polygon.setLines(lines);\n\n  return polygon;\n}\n","type ConfigCache = {\n  segmentsHidden: Set<number>;\n  outlineWidthActive: number;\n  visibility: boolean;\n};\n\n/**\n * Config cache is used to store the config for a given segmentation\n * representation. This is used to avoid having to recompute the config\n * every time the user changes the active segment, and also for performance\n * reasons.\n */\nconst configCachePerSegmentationRepresentationUID = new Map();\n\nexport function getConfigCache(\n  segmentationRepresentationUID: string\n): ConfigCache {\n  return configCachePerSegmentationRepresentationUID.get(\n    segmentationRepresentationUID\n  );\n}\n\nexport function setConfigCache(\n  segmentationRepresentationUID: string,\n  config: ConfigCache\n) {\n  configCachePerSegmentationRepresentationUID.set(\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport function deleteConfigCache(segmentationRepresentationUID: string) {\n  configCachePerSegmentationRepresentationUID.delete(\n    segmentationRepresentationUID\n  );\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\n\nimport {\n  getPolyData,\n  getSegmentSpecificConfig,\n  validateGeometry,\n} from './utils';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\n\nexport function addContourSetsToElement(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const appendPolyData = vtkAppendPolyData.newInstance();\n\n  const scalarToColorMap = new Map();\n  const segmentSpecificMap = new Map();\n\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      console.warn(\n        `No geometry found for geometryId ${geometryId}. Skipping render.`\n      );\n      return;\n    }\n\n    const segmentIndex = (geometry.data as Types.IContourSet).getSegmentIndex();\n\n    validateGeometry(geometry);\n\n    const segmentSpecificConfig = getSegmentSpecificConfig(\n      contourRepresentation,\n      geometryId,\n      segmentIndex\n    );\n\n    const contourSet = geometry.data;\n    const polyData = getPolyData(contourSet as Types.IContourSet);\n    const color = contourSet.getColor();\n\n    const size = polyData.getPoints().getNumberOfPoints();\n\n    const scalars = vtkDataArray.newInstance({\n      size: size * 4,\n      numberOfComponents: 4,\n      dataType: 'Uint8Array',\n    });\n    for (let i = 0; i < size; ++i) {\n      scalars.setTuple(i, [...color, 255]);\n    }\n    polyData.getPointData().setScalars(scalars);\n\n    if (segmentSpecificConfig) {\n      segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n    }\n\n    scalarToColorMap.set(segmentIndex, [\n      ...color,\n      segmentsHidden.has(segmentIndex) ? 0 : 255,\n    ]);\n\n    segmentIndex === 0\n      ? appendPolyData.setInputData(polyData)\n      : appendPolyData.addInputData(polyData);\n  });\n\n  const polyDataOutput = appendPolyData.getOutputData();\n\n  const outlineWidthActive =\n    contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;\n\n  const mapper = vtkMapper.newInstance();\n  mapper.setInputData(polyDataOutput);\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n  actor.getProperty().setLineWidth(outlineWidthActive);\n\n  // set the config cache for later update of the contour\n  setConfigCache(\n    segmentationRepresentationUID,\n    Object.assign({}, getConfigCache(segmentationRepresentationUID), {\n      segmentsHidden: new Set(segmentsHidden),\n      segmentSpecificMap,\n      outlineWidthActive,\n    })\n  );\n\n  actor.setForceOpaque(true);\n\n  viewport.addActor({\n    uid: contourActorUID,\n    actor: actor as unknown as Types.Actor,\n  });\n  viewport.resetCamera();\n  viewport.render();\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nimport { getSegmentSpecificConfig } from './utils';\n\nexport function updateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const newContourConfig = contourRepresentationConfig.representations.CONTOUR;\n  const cachedConfig = getConfigCache(segmentationRepresentationUID);\n\n  const contourSetsActor = viewport.getActor(contourActorUID);\n\n  if (!contourSetsActor) {\n    console.warn(\n      `No contour actor found for actorUID ${contourActorUID}. Skipping render.`\n    );\n    return;\n  }\n\n  const { actor } = contourSetsActor;\n\n  const newOutlineWithActive = newContourConfig.outlineWidthActive;\n\n  if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {\n    (actor as unknown as vtkActor)\n      .getProperty()\n      .setLineWidth(newOutlineWithActive);\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        outlineWidthActive: newOutlineWithActive,\n      })\n    );\n  }\n\n  const mapper = (actor as unknown as vtkActor).getMapper();\n  const lut = mapper.getLookupTable();\n\n  const segmentsToSetToInvisible = [];\n  const segmentsToSetToVisible = [];\n\n  for (const segmentIndex of segmentsHidden) {\n    if (!cachedConfig.segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToInvisible.push(segmentIndex);\n    }\n  }\n\n  // the other way around\n  for (const segmentIndex of cachedConfig.segmentsHidden) {\n    if (!segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToVisible.push(segmentIndex);\n    }\n  }\n\n  const mergedInvisibleSegments = Array.from(cachedConfig.segmentsHidden)\n    .filter((segmentIndex) => !segmentsToSetToVisible.includes(segmentIndex))\n    .concat(segmentsToSetToInvisible);\n\n  const { contourSets, segmentSpecificConfigs } = geometryIds.reduce(\n    (acc, geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const { data: contourSet } = geometry;\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const segmentSpecificConfig = getSegmentSpecificConfig(\n        contourRepresentation,\n        geometryId,\n        segmentIndex\n      );\n\n      acc.contourSets.push(contourSet);\n      acc.segmentSpecificConfigs[segmentIndex] = segmentSpecificConfig ?? {};\n\n      return acc;\n    },\n    { contourSets: [], segmentSpecificConfigs: {} }\n  );\n\n  const affectedSegments = [\n    ...mergedInvisibleSegments,\n    ...segmentsToSetToVisible,\n  ];\n\n  const hasCustomSegmentSpecificConfig = Object.values(\n    segmentSpecificConfigs\n  ).some((config) => Object.keys(config).length > 0);\n\n  let polyDataModified = false;\n\n  if (affectedSegments.length || hasCustomSegmentSpecificConfig) {\n    const appendPolyData = mapper.getInputData();\n    const appendScalars = appendPolyData.getPointData().getScalars();\n    const appendScalarsData = appendScalars.getData();\n    // below we will only manipulate the polyData of the contourSets that are affected\n    // by picking the correct offset in the scalarData array\n    let offset = 0;\n    contourSets.forEach((contourSet) => {\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const size = contourSet.getTotalNumberOfPoints();\n\n      if (\n        affectedSegments.includes(segmentIndex) ||\n        segmentSpecificConfigs[segmentIndex]?.fillAlpha // Todo: add others\n      ) {\n        const color = contourSet.getColor();\n        let visibility = mergedInvisibleSegments.includes(segmentIndex)\n          ? 0\n          : 255;\n\n        const segmentConfig = segmentSpecificConfigs[segmentIndex];\n        if (segmentConfig.fillAlpha !== undefined) {\n          visibility = segmentConfig.fillAlpha * 255;\n        }\n\n        for (let i = 0; i < size; ++i) {\n          appendScalarsData[offset + i * 4] = color[0];\n          appendScalarsData[offset + i * 4 + 1] = color[1];\n          appendScalarsData[offset + i * 4 + 2] = color[2];\n          appendScalarsData[offset + i * 4 + 3] = visibility;\n        }\n\n        polyDataModified = true;\n      }\n\n      offset = offset + size * 4;\n    });\n\n    if (polyDataModified) {\n      appendPolyData.modified();\n    }\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        segmentsHidden: new Set(segmentsHidden),\n      })\n    );\n\n    mapper.setLookupTable(lut);\n  }\n\n  viewport.render();\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the contour representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the contour representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.includes(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","import {\n  getEnabledElementByIds,\n  Types,\n  StackViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\nimport { addOrUpdateContourSets } from './addOrUpdateContourSets';\nimport removeContourFromElement from './removeContourFromElement';\nimport { deleteConfigCache } from './contourConfigCache';\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeContourFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  deleteConfigCache(segmentationRepresentationUID);\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the contour sets for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representationConfig: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const { segmentationId } = representationConfig;\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const contourData = segmentation.representationData[Representations.Contour];\n  const { geometryIds } = contourData;\n\n  // We don't have a good way to handle stack viewports for contours at the moment.\n  // Plus, if we add a segmentation to one viewport, it gets added to all the viewports in the toolGroup too.\n  if (viewport instanceof StackViewport) {\n    return;\n  }\n\n  if (!geometryIds?.length) {\n    console.warn(\n      `No contours found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  // add the contour sets to the viewport\n  addOrUpdateContourSets(\n    viewport,\n    geometryIds,\n    representationConfig,\n    toolGroupConfig\n  );\n}\n\nfunction _removeContourFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeContourFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  removeSegmentationRepresentation,\n};\n","import { Types } from '@cornerstonejs/core';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { addContourSetsToElement } from './addContourSetsToElement';\nimport { updateContourSets } from './updateContourSets';\n\nexport function addOrUpdateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig\n) {\n  const { segmentationRepresentationUID } = contourRepresentation;\n  const actorUID = `CONTOUR_${segmentationRepresentationUID}`;\n  const actor = viewport.getActor(actorUID);\n\n  const addOrUpdateFn = actor ? updateContourSets : addContourSetsToElement;\n  addOrUpdateFn(\n    viewport,\n    geometryIds,\n    contourRepresentation,\n    contourRepresentationConfig,\n    actorUID\n  );\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    contourDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { cache } from '@cornerstonejs/core';\nimport type {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n} from '../../../types/LabelmapTypes';\n\nfunction validate(segmentationInput: SegmentationPublicInput): void {\n  if (!segmentationInput.representation.data) {\n    throw new Error(\n      'The segmentationInput.representationData.data is undefined, please provide a valid representationData.data'\n    );\n  }\n\n  const representationData = segmentationInput.representation\n    .data as LabelmapSegmentationData;\n\n  if ('volumeId' in representationData) {\n    // volumetric labelmap\n    const cachedVolume = cache.getVolume(\n      (representationData as LabelmapSegmentationDataVolume).volumeId\n    );\n\n    if (!cachedVolume) {\n      throw new Error(\n        `volumeId of ${\n          (representationData as LabelmapSegmentationDataVolume).volumeId\n        } not found in cache, you should load and cache volume before adding segmentation`\n      );\n    }\n  } else {\n    // I don't think we need this check since there is no guarantee that the stack is cached.\n  }\n}\n\nexport default validate;\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport validateLabelmap from '../../../tools/displayTools/Labelmap/validateRepresentationData';\n\n/**\n * Checks if the segmentationInputArray is valid meaning it contains\n * correct representationProps for the representation type that is being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || !segmentationInputArray.length) {\n    throw new Error('The segmentationInputArray is undefined or empty array');\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'The segmentationInput.segmentationId is undefined, please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'The segmentationInput.representation is undefined, please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validateLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import _cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = _cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { RepresentationPublicInput } from '../../../types';\nimport { getRepresentationRenderingConfig as getLabelmapRenderingConfig } from '../../../tools/displayTools/Labelmap/labelmapDisplay';\n\nexport function getRepresentationSpecificConfig(\n  representationInput: RepresentationPublicInput\n) {\n  const { type } = representationInput;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    return getLabelmapRenderingConfig();\n  } else {\n    return {};\n  }\n}\n","/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","import {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { addSegmentationRepresentation } from './addSegmentationRepresentation';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nexport default addSegmentationRepresentations;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from './config/segmentationConfig';\nimport {\n  addSegmentationRepresentation as addSegmentationRepresentationToState,\n  getNextColorLUTIndex,\n  addColorLUT,\n} from './segmentationState';\nimport { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\n\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId, options = {} } = representationInput;\n  const segmentationRepresentationUID = utilities.uuidv4();\n\n  // Todo: make segmentsHidden also an option that can get passed by\n  // the user\n  const segmentsHidden = new Set() as Set<number>;\n\n  const colorLUTOrIndexInput = options.colorLUTOrIndex;\n  let colorLUTIndexToUse;\n\n  if (typeof colorLUTOrIndexInput === 'number') {\n    colorLUTIndexToUse = colorLUTOrIndexInput;\n  } else {\n    const nextIndex = getNextColorLUTIndex();\n    const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)\n      ? colorLUTOrIndexInput\n      : CORNERSTONE_COLOR_LUT;\n    addColorLUT(colorLUTToAdd as Types.ColorLUT, nextIndex);\n    colorLUTIndexToUse = nextIndex;\n  }\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: Representations.Labelmap,\n    segmentsHidden,\n    colorLUTIndex: colorLUTIndexToUse,\n    active: true,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: getRepresentationSpecificConfig(representationInput),\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  addSegmentationRepresentationToState(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  return segmentationRepresentationUID;\n}\n\nexport { addSegmentationRepresentation };\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport { getDefaultSegmentationStateManager } from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Types.Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  return colorLUT[segmentIndex];\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Types.Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import { cache, Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\n\nfunction getSegmentationIndices(segmentationId) {\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (segmentation.type === SegmentationRepresentations.Labelmap) {\n    const volume = cache.getVolume(segmentationId);\n    const scalarData = volume.getScalarData();\n\n    const keySet = {};\n    for (let i = 0; i < scalarData.length; i++) {\n      const segmentIndex = scalarData[i];\n      if (segmentIndex !== 0 && !keySet[segmentIndex]) {\n        keySet[segmentIndex] = true;\n      }\n    }\n    return Object.keys(keySet).map((it) => parseInt(it, 10));\n  } else if (segmentation.type === SegmentationRepresentations.Contour) {\n    const geometryIds = segmentation.representationData.CONTOUR?.geometryIds;\n\n    if (!geometryIds) {\n      throw new Error(\n        `No geometryIds found for segmentationId ${segmentationId}`\n      );\n    }\n\n    return geometryIds.map((geometryId) => {\n      const geometry = cache.getGeometry(geometryId) as Types.IGeometry;\n      return (geometry.data as Types.IContourSet).getSegmentIndex();\n    });\n  }\n}\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getSegmentationIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden } = representation;\n\n  return segmentsHidden.size === 0;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n};\n","import { getSegmentation } from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import {\n  StackViewport,\n  utilities,\n  BaseVolumeViewport,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * It applies the active strategy to the enabled element.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy].call(this, enabledElement, operationData);\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be\n   * * imageId:<imageId>\n   * * volumeId:<volumeId>\n   * * videoId:<basePathForVideo>/frames/<frameSpecifier>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('videoId:')) {\n      // Video id can be multi-valued for the frame information\n      const imageURI = utilities.imageIdToURI(targetId);\n      const viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    if (viewport instanceof StackViewport) {\n      return `imageId:${viewport.getCurrentImageId()}`;\n    } else if (viewport instanceof BaseVolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    } else if (viewport instanceof VideoViewport) {\n      return `videoId:${viewport.getCurrentImageId()}`;\n    } else {\n      throw new Error(\n        'getTargetId: viewport must be a StackViewport or VolumeViewport'\n      );\n    }\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    fill,\n    width,\n    lineWidth,\n    lineDash,\n    fillOpacity,\n    strokeOpacity,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      fill: 'transparent',\n      width: '2',\n      lineDash: undefined,\n      lineWidth: undefined,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n    'fill-opacity': fillOpacity, // setting fill opacity\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\n  };\n\n  if (existingCircleElement) {\n    setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","2\nimport type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawEllipseByCoordinates(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  canvasCoordinates: [Types.Point2, Types.Point2, Types.Point2, Types.Point2],\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const [bottom, top, left, right] = canvasCoordinates;\n\n  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n  const angle = Math.atan2(left[1] - right[1], left[0] - right[0]) * 180 / Math.PI;\n\n  const center = [(left[0] + right[0]) / 2 , ( top[1] + bottom[1] ) / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    'transform': `rotate(${angle} ${center[0]} ${center[1]})`,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipseByCoordinates;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n){\n  const top: Types.Point2 = [ (corner1[0] + corner2[0]) / 2, corner1[1] ];\n  const bottom: Types.Point2 = [ (corner1[0] + corner2[0]) / 2, corner2[1] ];\n  const left: Types.Point2 = [ corner1[0], (corner1[1] + corner2[1]) / 2];\n  const right: Types.Point2 = [ corner2[0], (corner1[1] + corner2[1]) / 2];\n\n  drawEllipseByCoordinates(\n    svgDrawingHelper,\n    annotationUID,\n    ellipseUID,\n    [bottom, top, left, right],\n    options = {},\n    dataId = ''\n  )\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  for (let i = 0; i < handlePoints.length; i++) {\n    const handle = handlePoints[i];\n\n    // variable for the namespace\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(\n      annotationUID,\n      'handle',\n      `hg-${handleGroupUID}-index-${i}`\n    );\n\n    let attributes;\n    if (type === 'circle') {\n      attributes = {\n        cx: `${handle[0]}`,\n        cy: `${handle[1]}`,\n        r: handleRadius,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        opacity: opacity,\n      };\n    } else if (type === 'rect') {\n      const handleRadiusFloat = parseFloat(handleRadius);\n      const side = handleRadiusFloat * 1.5;\n      const x = handle[0] - side * 0.5;\n      const y = handle[1] - side * 0.5;\n\n      attributes = {\n        x: `${x}`,\n        y: `${y}`,\n        width: `${side}`,\n        height: `${side}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        rx: `${side * 0.1}`,\n        opacity: opacity,\n      };\n    } else {\n      throw new Error(`Unsupported handle type: ${type}`);\n    }\n\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n    if (existingHandleElement) {\n      setAttributesIfNecessary(attributes, existingHandleElement);\n\n      svgDrawingHelper.setNodeTouched(svgNodeHash);\n    } else {\n      const newHandleElement = document.createElementNS(svgns, type);\n\n      setNewAttributesIfValid(attributes, newHandleElement);\n\n      svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n  }\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `connectLastToFirst` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    connectLastToFirst?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const { fillColor, fillOpacity, color, width, lineWidth, lineDash } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        width: '2',\n        fillColor: 'none',\n        fillOpacity: 0,\n        lineWidth: undefined,\n        lineDash: undefined,\n        connectLastToFirst: false,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0]}, ${point[1]} `;\n  }\n\n  if (options.connectLastToFirst) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    setAttributesIfNecessary(textAttributes, textElement);\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRedactionRect(\n  svgDrawingHelper: any,\n  annotationUID: string,\n  rectangleUID: string,\n  start: any,\n  end: any,\n  options = {}\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'black',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import { ToolGroupManager } from '../store';\nimport { ToolModes } from '../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Finds the enabled element, and iterates over the tools inside its\n * toolGroup. Returns the list of tool instances that are valid based\n * on the provided tool mode.\n *\n * @param element Canvas element\n * @param modesFilter tool modes: active, passive, enabled, disabled\n * @returns enabled tool instances\n */\nexport default function getToolsWithModesForElement(\n  element: HTMLDivElement,\n  modesFilter: ModesFilter\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    /* filter out tools that don't have options */\n    if (!toolOptions) {\n      continue;\n    }\n\n    if (modesFilter.includes(toolOptions.mode)) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          this._animationFrameSet = false;\n          this._animationFrameHandle = null;\n          return;\n        }\n      }\n    }\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Annotations, Annotation } from '../../types';\nimport { debug } from 'console';\n\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * given some `Annotations`, and the slice defined by the camera's normal\n * direction and the spacing in the normal, filter the `Annotations` which\n * is within the slice.\n *\n * @param annotations - Annotations\n * @param camera - The camera\n * @param spacingInNormalDirection - The spacing in the normal direction\n * @returns The filtered `Annotations`.\n */\nexport default function filterAnnotationsWithinSlice(\n  annotations: Annotations,\n  camera: Types.ICamera,\n  spacingInNormalDirection: number\n): Annotations {\n  const { viewPlaneNormal } = camera;\n\n  // The reason we use parallel normals instead of actual orientation is that\n  // flipped action is done through camera API, so we can't rely on the\n  // orientation (viewplaneNormal and viewUp) since even the same image and\n  // same slice if flipped will have different orientation, but still rendering\n  // the same slice. Instead, we choose to use the parallel normals to filter\n  // the annotations and later we fine tune it with the annotation within slice\n  // logic down below.\n  const annotationsWithParallelNormals = annotations.filter(\n    (td: Annotation) => {\n      let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n      if (!annotationViewPlaneNormal) {\n        // This code is run to set the annotation view plane normal\n        // for historical data which was saved without the normal.\n        const { referencedImageId } = td.metadata;\n        const { imageOrientationPatient } = metaData.get(\n          'imagePlaneModule',\n          referencedImageId\n        );\n        const rowCosineVec = vec3.fromValues(\n          imageOrientationPatient[0],\n          imageOrientationPatient[1],\n          imageOrientationPatient[2]\n        );\n\n        const colCosineVec = vec3.fromValues(\n          imageOrientationPatient[3],\n          imageOrientationPatient[4],\n          imageOrientationPatient[5]\n        );\n\n        annotationViewPlaneNormal = vec3.create() as Types.Point3;\n\n        vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n        td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n      }\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      return annotationViewPlaneNormal && isParallel;\n    }\n  );\n\n  // No in plane annotations.\n  if (!annotationsWithParallelNormals.length) {\n    return [];\n  }\n\n  // Annotation should be within the slice, which means that it should be between\n  // camera's focalPoint +/- spacingInNormalDirection.\n\n  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n  const { focalPoint } = camera;\n\n  const annotationsWithinSlice = [];\n\n  for (const annotation of annotationsWithParallelNormals) {\n    const data = annotation.data;\n    const point = data.handles.points[0];\n\n    if (!annotation.isVisible) {\n      continue;\n    }\n    // A = point\n    // B = focal point\n    // P = normal\n\n    // B-A dot P  => Distance in the view direction.\n    // this should be less than half the slice distance.\n\n    const dir = vec3.create();\n\n    vec3.sub(dir, focalPoint, point);\n\n    const dot = vec3.dot(dir, viewPlaneNormal);\n\n    if (Math.abs(dot) < halfSpacingInNormalDirection) {\n      annotationsWithinSlice.push(annotation);\n    }\n  }\n\n  return annotationsWithinSlice;\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import {\n  StackViewport,\n  VolumeViewport,\n  VideoViewport,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport type { Annotations } from '../../types';\nimport annotationFrameRange from '../annotationFrameRange';\n\nconst baseUrlExtractor = /(videoId:|imageId:|volumeId:)([a-zA-Z]*:)/;\n\n/**\n * Given the viewport and the annotations, it filters the annotations array and only\n * return those annotation that should be displayed on the viewport\n * @param annotations - Annotations\n * @returns A filtered version of the annotations.\n */\nexport default function filterAnnotationsForDisplay(\n  viewport: Types.IViewport,\n  annotations: Annotations\n): Annotations {\n  if (viewport instanceof StackViewport) {\n    // 1. Get the currently displayed imageId from the StackViewport\n    const imageId = viewport.getCurrentImageId();\n\n    // 2. remove the dataLoader scheme since it might be an annotation that was\n    // created on the volumeViewport initially and has the volumeLoader scheme\n    // but shares the same imageId\n    const colonIndex = imageId.indexOf(':');\n    const imageURI = imageId.substring(colonIndex + 1);\n\n    // 3. Filter annotation in the frame of reference by the referenced image ID property\n    // Note: With the current implementation drawing on the stack (PT stack) will not\n    // show the annotation on a volume that does not share the same imageURIs (CT Volume),\n    // and we don't have a proper way to check distance either since a stack can be\n    // composed of multiple unrelated images\n    return annotations.filter((annotation) => {\n      if (!annotation.isVisible) {\n        return false;\n      }\n\n      const imageId = annotation.metadata.referencedImageId;\n\n      if (imageId === undefined) {\n        // This annotation was not drawn on a non-coplanar reformat, and such does\n        // not have a referenced imageId.\n        return false;\n      }\n\n      const colonIndex = imageId.indexOf(':');\n      const referenceImageURI = imageId.substring(colonIndex + 1);\n      return referenceImageURI === imageURI;\n    });\n  } else if (viewport instanceof VideoViewport) {\n    const frameOfReferenceUID: string = viewport.getFrameOfReferenceUID();\n\n    return annotations.filter((annotation) => {\n      if (!annotation.isVisible) {\n        return false;\n      }\n      if (annotation.metadata.FrameOfReferenceUID !== frameOfReferenceUID) {\n        return false;\n      }\n      const testURI = annotation.metadata.referencedImageId.replace(\n        baseUrlExtractor,\n        ''\n      );\n\n      if (!viewport.hasImageURI(testURI)) {\n        return false;\n      }\n      const range = annotationFrameRange.getFrameRange(annotation);\n      const frameNumber = viewport.getFrameNumber();\n      if (Array.isArray(range)) {\n        return frameNumber >= range[0] && frameNumber <= range[1];\n      }\n      // Arbitrary 5 frames of slop on the video for matching single frame\n      // number to position - this allows the annotation to display  when\n      // the video element is not exactly the same timing as expected or when\n      // playing video back.\n      return Math.abs(frameNumber - range) <= 5;\n    });\n  } else if (viewport instanceof VolumeViewport) {\n    const camera = viewport.getCamera();\n\n    const { spacingInNormalDirection } =\n      csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n    // Get data with same normal and within the same slice\n    return filterAnnotationsWithinSlice(\n      annotations,\n      camera,\n      spacingInNormalDirection\n    );\n  } else {\n    throw new Error(`Viewport Type ${viewport.type} not supported`);\n  }\n}\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxVisibility: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n\n      if (annotationToolStyles) {\n        // check first in the toolSpecific styles\n        if (annotationToolStyles[property] !== undefined) {\n          return annotationToolStyles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const viewportToolStyles = this.getViewportToolStyles(viewportId);\n\n      if (viewportToolStyles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (\n          viewportToolStyles[toolName] &&\n          viewportToolStyles[toolName][property] !== undefined\n        ) {\n          return viewportToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (\n          viewportToolStyles.global &&\n          viewportToolStyles.global[property] !== undefined\n        ) {\n          return viewportToolStyles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (toolGroupToolStyles) {\n        // check first in the toolSpecific styles\n        if (\n          toolGroupToolStyles[toolName] &&\n          toolGroupToolStyles[toolName][property] !== undefined\n        ) {\n          return toolGroupToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (\n          toolGroupToolStyles.global &&\n          toolGroupToolStyles.global[property] !== undefined\n        ) {\n          return toolGroupToolStyles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (\n      globalStyles[toolName] &&\n      globalStyles[toolName][property] !== undefined\n    ) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property] !== undefined) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) {\n    list.push(`${list[0]}${state}`);\n  }\n  if (mode) {\n    list.push(`${list[list.length - 1]}${mode}`);\n  }\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, or Selected.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted) {\n      return AnnotationStyleStates.Highlighted;\n    }\n    if (isAnnotationSelected(annotation.annotationUID)) {\n      return AnnotationStyleStates.Selected;\n    }\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) {\n      return AnnotationStyleStates.Locked;\n    }\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import {\n  utilities,\n  getEnabledElement,\n  StackViewport,\n  cache,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const { element, imageId } = evt.detail;\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const annotationManager = getAnnotationManager();\n    const framesOfReference = annotationManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        annotationManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        if (!annotation.metadata?.referencedImageId) {\n          return;\n        }\n\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n        }\n      });\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else if (viewport instanceof VideoViewport) {\n      referencedImageId = targetId.split('videoId:')[1];\n    } else {\n      const volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import {\n  BaseVolumeViewport,\n  StackViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**-q\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the surface representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the surface representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.startsWith(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import {\n  getEnabledElement,\n  Enums,\n  VolumeViewport3D,\n} from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkClipClosedSurface from '@kitware/vtk.js/Filters/General/ClipClosedSurface';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { pointToString } from '../../../utilities/pointToString';\n\nconst polyDataCache = new Map();\n\nfunction addSurfaceToElement(\n  element: HTMLDivElement,\n  surface: any,\n  actorUID: string\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const points = surface.getPoints();\n  const polys = surface.getPolys();\n  const color = surface.getColor();\n\n  const polyData = vtkPolyData.newInstance();\n  polyData.getPoints().setData(points, 3);\n\n  const triangles = vtkCellArray.newInstance({\n    values: Float32Array.from(polys),\n  });\n  polyData.setPolys(triangles);\n\n  const mapper = vtkMapper.newInstance({});\n  let clippingFilter;\n  if (!(viewport instanceof VolumeViewport3D)) {\n    clippingFilter = vtkClipClosedSurface.newInstance({\n      clippingPlanes: [],\n      activePlaneId: 2,\n      passPointData: false,\n    });\n    clippingFilter.setInputData(polyData);\n    clippingFilter.setGenerateOutline(true);\n    clippingFilter.setGenerateFaces(false);\n    clippingFilter.update();\n    const filteredData = clippingFilter.getOutputData();\n    mapper.setInputData(filteredData);\n  } else {\n    mapper.setInputData(polyData);\n  }\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n\n  // sets the color of the surface actor\n  actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n  viewport.addActor({\n    actor,\n    uid: actorUID,\n    clippingFilter,\n  });\n\n  element.addEventListener(\n    Enums.Events.CLIPPING_PLANES_UPDATED,\n    updateSurfacePlanes\n  );\n}\n\n/**\n * Updates the clipping planes of a surface and caches the resulting poly data\n * @param evt\n */\nfunction updateSurfacePlanes(evt) {\n  const { actorEntry, vtkPlanes, viewport } = evt.detail;\n  if (!actorEntry?.clippingFilter) {\n    return;\n  }\n\n  const mapper = actorEntry.actor.getMapper();\n\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = `${viewport.id}-${pointToString(\n    viewPlaneNormal\n  )}-${imageIndex}`;\n\n  let actorCache = polyDataCache.get(actorEntry.uid);\n  if (!actorCache) {\n    actorCache = new Map();\n    polyDataCache.set(actorEntry.uid, actorCache);\n  }\n\n  let polyData = actorCache.get(cacheId);\n  if (!polyData) {\n    const clippingFilter = actorEntry.clippingFilter;\n    clippingFilter.setClippingPlanes(vtkPlanes);\n    try {\n      clippingFilter.update();\n      polyData = clippingFilter.getOutputData();\n      actorCache.set(cacheId, polyData);\n    } catch (e) {\n      console.error('Error clipping surface', e);\n    }\n  }\n  mapper.setInputData(polyData);\n}\n\nexport default addSurfaceToElement;\n","import {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addSurfaceToElement from './addSurfaceToElement';\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeSurfaceFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the Surface  for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const SurfaceData = segmentation.representationData[Representations.Surface];\n  const { geometryId } = SurfaceData;\n\n  if (!geometryId) {\n    console.warn(\n      `No Surfaces found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  const geometry = cache.getGeometry(geometryId);\n  if (!geometry) {\n    throw new Error(`No Surfaces found for geometryId ${geometryId}`);\n  }\n\n  if (geometry.type !== Enums.GeometryType.SURFACE) {\n    // Todo: later we can support converting other geometries to Surfaces\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No Surfaces found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n\n  const surface = geometry.data;\n\n  const surfaceUID = `${segmentationRepresentationUID}_${surface.id}}`;\n  _renderSurface(viewport, surface, surfaceUID);\n\n  viewport.resetCamera();\n  viewport.render();\n}\n\nfunction _renderSurface(\n  viewport: Types.IVolumeViewport,\n  surface: any,\n  surfaceUID: string\n): void {\n  const actorUID = surfaceUID;\n  const actorEntry = viewport.getActor(actorUID);\n\n  if (!actorEntry) {\n    addSurfaceToElement(viewport.element, surface, actorUID);\n  } else {\n    throw new Error('Not implemented yet. (Update surface)');\n  }\n}\n\nfunction _removeSurfaceFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeSurfaceFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\n\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport SegmentationDisplayTool from '../../tools/displayTools/SegmentationDisplayTool';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n    const viewports = [];\n\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n\n      if (!renderingEngine) {\n        console.warn('rendering Engine has been destroyed');\n        return;\n      }\n\n      viewports.push(renderingEngine.getViewport(viewportId));\n    });\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import {\n  cache,\n  getEnabledElementByIds,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  if (type !== SegmentationRepresentations.Labelmap) {\n    throw new Error(\n      `onSegmentationDataModified: representationType ${type} not supported yet`\n    );\n  }\n\n  if (isVolumeSegmentation(representationData[type])) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    const segmentationVolume = cache.getVolume(\n      (representationData[type] as LabelmapSegmentationDataVolume).volumeId\n    );\n\n    if (!segmentationVolume) {\n      console.warn('segmentation not found in cache');\n      return;\n    }\n\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n    // Update the texture for the volume in the GPU\n    let slicesToUpdate;\n    if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n      slicesToUpdate = modifiedSlicesToUse;\n    } else {\n      const numSlices = imageData.getDimensions()[2];\n      slicesToUpdate = [...Array(numSlices).keys()];\n    }\n\n    slicesToUpdate.forEach((i) => {\n      vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n\n    // Trigger modified on the imageData to update the image\n    imageData.modified();\n  } else {\n    toolGroupIds.forEach((toolGroupId) => {\n      const toolGroupSegmentationRepresentations =\n        SegmentationState.getSegmentationRepresentations(toolGroupId);\n\n      const toolGroup = getToolGroup(toolGroupId);\n      const viewportsInfo = toolGroup.getViewportsInfo();\n\n      toolGroupSegmentationRepresentations.forEach((representation) => {\n        if (representation.segmentationId !== segmentationId) {\n          return;\n        }\n\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n          const viewport = getEnabledElementByIds(\n            viewportId,\n            renderingEngineId\n          ).viewport;\n\n          const actorEntry = viewport.getActor(\n            representation.segmentationRepresentationUID\n          );\n\n          if (!actorEntry) {\n            return;\n          }\n\n          const currentImageId = viewport.getCurrentImageId();\n\n          const segImageData = actorEntry.actor.getMapper().getInputData();\n\n          const { imageIdReferenceMap } = representationData[\n            type\n          ] as LabelmapSegmentationDataStack;\n\n          const currentSegmentationImageId =\n            imageIdReferenceMap.get(currentImageId);\n\n          const segmentationImage = cache.getImage(currentSegmentationImageId);\n          segImageData.modified();\n\n          // update the cache with the new image data\n          csUtils.updateVTKImageDataWithCornerstoneImage(\n            segImageData,\n            segmentationImage\n          );\n        });\n      });\n    });\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import {\n  StackViewport,\n  getEnabledElement,\n  Enums,\n  getEnabledElementByIds,\n  cache,\n  utilities,\n  Types,\n  metaData,\n} from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\n\nconst enable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (!(viewport instanceof StackViewport)) {\n    return;\n  }\n\n  element.addEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  // this listener handles the segmentation modifications\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (!(viewport instanceof StackViewport)) {\n    return;\n  }\n\n  element.removeEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nfunction _imageChangeEventListener(evt) {\n  const eventData = evt.detail;\n  const { viewportId, renderingEngineId } = eventData;\n  const { viewport } = getEnabledElementByIds(\n    viewportId,\n    renderingEngineId\n  ) as { viewport: Types.IStackViewport };\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (!toolGroup) {\n    return;\n  }\n\n  let toolGroupSegmentationRepresentations =\n    SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];\n\n  toolGroupSegmentationRepresentations =\n    toolGroupSegmentationRepresentations.filter(\n      (representation) => representation.type === Representations.Labelmap\n    );\n\n  if (!toolGroupSegmentationRepresentations?.length) {\n    return;\n  }\n\n  const segmentationRepresentations = {};\n  toolGroupSegmentationRepresentations.forEach((representation) => {\n    const segmentation = SegmentationState.getSegmentation(\n      representation.segmentationId\n    );\n\n    if (!segmentation) {\n      return;\n    }\n\n    const labelmapData =\n      segmentation.representationData[Representations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData)) {\n      return;\n    }\n\n    const { imageIdReferenceMap } =\n      labelmapData as LabelmapSegmentationDataStack;\n\n    segmentationRepresentations[representation.segmentationRepresentationUID] =\n      {\n        imageIdReferenceMap,\n      };\n  });\n\n  const representationList = Object.keys(segmentationRepresentations);\n  const currentImageId = viewport.getCurrentImageId();\n  const actors = viewport.getActors();\n\n  actors.forEach((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return;\n    }\n    const segmentationActor = actor.actor;\n\n    const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];\n\n    const derivedImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImageData = segmentationActor.getMapper().getInputData();\n\n    if (!derivedImageId) {\n      // this means that this slice doesn't have a segmentation for this representation\n      // this can be a case where the segmentation was added to certain slices only\n      // so we can keep the actor but empty out the imageData\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: new Uint8Array(segmentationImageData.getNumberOfPoints()),\n      });\n\n      const imageData = vtkImageData.newInstance();\n      imageData.getPointData().setScalars(scalarArray);\n      segmentationActor.getMapper().setInputData(imageData);\n      return;\n    }\n\n    const derivedImage = cache.getImage(derivedImageId);\n\n    const { origin, dimensions, spacing, direction } =\n      viewport.getImageDataMetadata(derivedImage);\n\n    segmentationImageData.setOrigin(origin);\n    segmentationImageData.modified();\n\n    if (\n      segmentationImageData.getDimensions()[0] !== dimensions[0] ||\n      segmentationImageData.getDimensions()[1] !== dimensions[1]\n    ) {\n      // IMPORTANT: Not sure why we can't just update the dimensions\n      // and the orientation of the image data and then call modified\n      // I tried calling modified on everything, but seems like we should remove\n      // and add the actor again below\n      viewport.removeActors([actor.uid]);\n      viewport.addImages(\n        [\n          {\n            imageId: derivedImageId,\n            actorUID: actor.uid,\n            callback: ({ imageActor }) => {\n              const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: [...derivedImage.getPixelData()],\n              });\n\n              const imageData = vtkImageData.newInstance();\n\n              imageData.setDimensions(dimensions[0], dimensions[1], 1);\n              imageData.setSpacing(spacing);\n              imageData.setDirection(direction);\n              imageData.setOrigin(origin);\n              imageData.getPointData().setScalars(scalarArray);\n\n              imageActor.getMapper().setInputData(imageData);\n            },\n          },\n        ],\n        true,\n        false\n      );\n\n      triggerSegmentationRender(toolGroup.id);\n      return;\n    }\n\n    utilities.updateVTKImageDataWithCornerstoneImage(\n      segmentationImageData,\n      derivedImage\n    );\n    viewport.render();\n\n    // This is put here to make sure that the segmentation is rendered\n    // for the initial image as well after that we don't need it since\n    // stack new image is called when changing slices\n    if (evt.type === Enums.Events.IMAGE_RENDERED) {\n      // unsubscribe after the initial render\n      viewport.element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        _imageChangeEventListener as EventListener\n      );\n    }\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","import { Enums } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\n/**\n * Extracts the length units and the type of calibration for those units\n * into the response.  The length units will typically be either mm or px\n * while the calibration type can be any of a number of different calibraiton types.\n *\n * Volumetric images have no calibration type, so are just the raw mm.\n *\n * TODO: Handle region calibration\n *\n * @param handles - used to detect if the spacing information is different\n *   between various points (eg angled ERMF or US Region).\n *   Currently unused, but needed for correct US Region handling\n * @param image - to extract the calibration from\n *        image.calibration - calibration value to extract units form\n * @returns String containing the units and type of calibration\n */\nconst getCalibratedLengthUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  // Anachronistic - moving to using calibration consistently, but not completed yet\n  const units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  if (!calibration || !calibration.type) {\n    return units;\n  }\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return PIXEL_UNITS;\n  }\n  // TODO - handle US regions properly\n  if (calibration.SequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\nconst SQUARE = '\\xb2';\n/**\n *  Extracts the area units, including the squared sign plus calibration type.\n */\nconst getCalibratedAreaUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  const units = (hasPixelSpacing ? 'mm' : PIXEL_UNITS) + SQUARE;\n  if (!calibration || !calibration.type) {\n    return units;\n  }\n  if (calibration.SequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\n/**\n * Gets the scale divisor for converting from internal spacing to\n * image spacing for calibrated images.\n */\nconst getCalibratedScale = (image) => image.calibration?.scale || 1;\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport default getCalibratedLengthUnits;\n\nexport {\n  getCalibratedAreaUnits,\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n  getCalibratedAspect,\n};\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const { element } = renderingEngine.getViewport(viewportId);\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    const VolumeScrollEventDetail = {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail as EventTypes.VolumeScrollOutOfBoundsEventDetail\n    );\n  }\n}\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointIJK: vec3, pointLPS: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, currentPos)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({ value, index, pointIJK, pointLPS: currentPos });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * With a given vertices (points) coordinates in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If dimensions are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates (IJK)\n * @param dimensions - dimensions of the image\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nfunction getBoundingBoxAroundShape(\n  points: Types.Point3[],\n  dimensions?: Types.Point3\n): [Types.Point2, Types.Point2, Types.Point2] {\n  let xMin = Infinity;\n  let xMax = 0;\n  let yMin = Infinity;\n  let yMax = 0;\n  let zMin = Infinity;\n  let zMax = 0;\n\n  points.forEach((p) => {\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n    zMin = Math.min(p[2], zMin);\n    zMax = Math.max(p[2], zMax);\n  });\n\n  xMin = Math.floor(xMin);\n  xMax = Math.floor(xMax);\n  yMin = Math.floor(yMin);\n  yMax = Math.floor(yMax);\n  zMin = Math.floor(zMin);\n  zMax = Math.floor(zMax);\n\n  if (dimensions) {\n    // clip the min, max to the provided width, height and depth\n    const [width, height, depth] = dimensions;\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(width - 1, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(height - 1, yMax);\n    zMin = Math.max(0, zMin);\n    zMax = Math.min(depth - 1, zMax);\n  }\n\n  return [\n    [xMin, xMax],\n    [yMin, yMax],\n    [zMin, zMax],\n  ];\n}\n\nexport default getBoundingBoxAroundShape;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * @param sphere - Sphere object with center and radius\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius ** 2\n  );\n}\n","/**\n * Truncates decimal points to that there is at least 1+precision significant\n * digits.\n *\n * For example, with the default precision 2 (3 significant digits)\n * * Values larger than 100 show no information after the decimal point\n * * Values between 10 and 99 show 1 decimal point\n * * Values between 1 and 9 show 2 decimal points\n *\n * @param value - to return a fixed measurement value from\n * @param precision - defining how many digits after 1..9 are desired\n */\nfunction roundNumber(\n  value: string | number | (string | number)[],\n  precision = 2\n): string {\n  if (Array.isArray(value)) {\n    return value.map((v) => roundNumber(v, precision)).join(', ');\n  }\n  if (value === undefined || value === null || value === '') {\n    return 'NaN';\n  }\n  value = Number(value);\n  if (value < 0.0001) {\n    return `${value}`;\n  }\n  const fixedPrecision =\n    value >= 100\n      ? precision - 2\n      : value >= 10\n      ? precision - 1\n      : value >= 1\n      ? precision\n      : value >= 0.1\n      ? precision + 1\n      : value >= 0.01\n      ? precision + 2\n      : value >= 0.001\n      ? precision + 3\n      : precision + 4;\n  return value.toFixed(fixedPrecision);\n}\n\nexport default roundNumber;\n","import { Types } from '@cornerstonejs/core';\nimport { TypedArray } from '@kitware/vtk.js/types';\n\nfunction isWithinThreshold(\n  index: number,\n  imageScalarData: TypedArray,\n  strategySpecificConfiguration: any\n) {\n  const { THRESHOLD_INSIDE_CIRCLE } = strategySpecificConfiguration;\n\n  const voxelValue = imageScalarData[index];\n  const { threshold } = THRESHOLD_INSIDE_CIRCLE;\n\n  return threshold[0] <= voxelValue && voxelValue <= threshold[1];\n}\n\nexport default isWithinThreshold;\n","import { cache } from '@cornerstonejs/core';\nimport { isVolumeSegmentation } from './stackVolumeCheck';\nimport { LabelmapToolOperationDataStack } from '../../../../types';\n\nfunction getStrategyData({ operationData, viewport }) {\n  let segmentationImageData, segmentationScalarData, imageScalarData;\n  if (isVolumeSegmentation(operationData)) {\n    const { volumeId, referencedVolumeId } = operationData;\n\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = cache.getVolume(referencedVolumeId);\n\n    if (!segmentationVolume || !imageVolume) {\n      return;\n    }\n\n    ({ imageData: segmentationImageData } = segmentationVolume);\n    segmentationScalarData = segmentationVolume.getScalarData();\n    imageScalarData = imageVolume.getScalarData();\n  } else {\n    const { imageIdReferenceMap, segmentationRepresentationUID } =\n      operationData as LabelmapToolOperationDataStack;\n\n    if (!imageIdReferenceMap) {\n      return;\n    }\n\n    const currentImageId = viewport.getCurrentImageId();\n    if (!currentImageId) {\n      return;\n    }\n\n    // we know that the segmentationRepresentationUID is the name of the actor always\n    // and always circle modifies the current imageId which in fact is the imageData\n    // of that actor at that moment so we have the imageData already\n    const actor = viewport.getActor(segmentationRepresentationUID);\n    segmentationImageData = actor.actor.getMapper().getInputData();\n    const currentSegmentationImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImage = cache.getImage(currentSegmentationImageId);\n    segmentationScalarData = segmentationImage.getPixelData();\n\n    const image = cache.getImage(currentImageId);\n\n    // VERY IMPORTANT\n    // This is the pixel data of the image that is being segmented in the cache\n    // and we need to use this to for the modification\n    imageScalarData = image.getPixelData();\n  }\n\n  return {\n    segmentationImageData,\n    segmentationScalarData,\n    imageScalarData,\n  };\n}\n\nexport { getStrategyData };\n","import type { Types } from '@cornerstonejs/core';\nimport { cache, utilities as csUtils } from '@cornerstonejs/core';\n\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInSurroundingSphereCallback } from '../../../utilities';\nimport isWithinThreshold from './utils/isWithinThreshold';\nimport { LabelmapToolOperationData } from '../../../types';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isVolumeSegmentation } from './utils/stackVolumeCheck';\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\nfunction fillSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  _inside = true,\n  threshold = false\n): void {\n  const { viewport } = enabledElement;\n  const {\n    segmentsLocked,\n    segmentIndex,\n    strategySpecificConfiguration,\n    points,\n  } = operationData;\n\n  const strategyData = getStrategyData({ operationData, viewport });\n\n  if (!strategyData) {\n    console.warn('No data found for fillSphere');\n    return;\n  }\n\n  const { imageScalarData, segmentationImageData, segmentationScalarData } =\n    strategyData;\n\n  const scalarIndex = [];\n\n  let callback;\n\n  if (threshold) {\n    callback = ({ value, index }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n\n      if (\n        isWithinThreshold(index, imageScalarData, strategySpecificConfiguration)\n      ) {\n        segmentationScalarData[index] = segmentIndex;\n        scalarIndex.push(index);\n      }\n    };\n  } else {\n    callback = ({ index, value }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n      segmentationScalarData[index] = segmentIndex;\n      scalarIndex.push(index);\n    };\n  }\n\n  pointInSurroundingSphereCallback(\n    segmentationImageData,\n    [points[0], points[1]],\n    callback,\n    viewport as Types.IVolumeViewport\n  );\n\n  const dimensions = segmentationImageData.getDimensions();\n\n  let sliceArray;\n  if (isVolumeSegmentation(operationData)) {\n    // Since the scalar indexes start from the top left corner of the cube, the first\n    // slice that needs to be rendered can be calculated from the first mask coordinate\n    // divided by the zMultiple, as well as the last slice for the last coordinate\n    const zMultiple = dimensions[0] * dimensions[1];\n    const minSlice = Math.floor(scalarIndex[0] / zMultiple);\n    const maxSlice = Math.floor(\n      scalarIndex[scalarIndex.length - 1] / zMultiple\n    );\n    sliceArray = Array.from(\n      { length: maxSlice - minSlice + 1 },\n      (v, k) => k + minSlice\n    );\n    triggerSegmentationDataModified(operationData.volumeId, sliceArray);\n  }\n}\n\n/**\n * Fill inside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillSphere(enabledElement, operationData, true);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being filled.\n * @param operationData - EraseOperationData\n */\nexport function thresholdInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  if (isVolumeSegmentation(operationData)) {\n    const { referencedVolumeId, volumeId } = operationData;\n\n    const imageVolume = cache.getVolume(referencedVolumeId);\n    const segmentation = cache.getVolume(volumeId);\n\n    if (\n      !csUtils.isEqual(segmentation.dimensions, imageVolume.dimensions) ||\n      !csUtils.isEqual(segmentation.direction, imageVolume.direction)\n    ) {\n      throw new Error(\n        'Only source data the same dimensions/size/orientation as the segmentation currently supported.'\n      );\n    }\n  }\n\n  fillSphere(enabledElement, operationData, true, true);\n}\n\n/**\n * Fill outside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillOutsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillSphere(enabledElement, operationData, false);\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { fillInsideSphere } from './fillSphere';\nimport { LabelmapToolOperationData } from '../../../types';\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\nexport function eraseInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillInsideCircle functionality.\n  const eraseOperationData = Object.assign({}, operationData, {\n    segmentIndex: 0,\n  });\n\n  fillInsideSphere(enabledElement, eraseOperationData);\n}\n","interface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  const { center, xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  let inside = 0;\n\n  // Calculate the sum of normalized squared distances\n  const dx = pointLPS[0] - center[0];\n  inside += dx * dx * inverts.invXRadiusSq;\n  if (inside > 1) {\n    return false;\n  }\n\n  const dy = pointLPS[1] - center[1];\n  inside += dy * dy * inverts.invYRadiusSq;\n  if (inside > 1) {\n    return false;\n  }\n\n  const dz = pointLPS[2] - center[2];\n  inside += dz * dz * inverts.invZRadiusSq;\n\n  // Check if the point is inside the ellipse\n  return inside <= 1;\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype canvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport {\n  getCanvasEllipseCorners,\n  pointInEllipse,\n} from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\nimport isWithinThreshold from './utils/isWithinThreshold';\nimport { LabelmapToolOperationData } from '../../../types';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isVolumeSegmentation } from './utils/stackVolumeCheck';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\nfunction fillCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  threshold = false\n): void {\n  const {\n    points,\n    segmentsLocked,\n    segmentIndex,\n    segmentationId,\n    strategySpecificConfiguration,\n  } = operationData;\n\n  const { viewport } = enabledElement;\n  const data = getStrategyData({ operationData, viewport });\n\n  if (!data) {\n    console.warn('No data found for fillCircle');\n    return;\n  }\n\n  const { imageScalarData, segmentationImageData, segmentationScalarData } =\n    data;\n\n  const { ellipseObj, boundsIJK } = getEllipse(\n    viewport,\n    segmentationImageData,\n    points\n  );\n\n  const modifiedSlicesToUse = new Set() as Set<number>;\n\n  let callback;\n\n  if (threshold) {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n\n      if (\n        isWithinThreshold(index, imageScalarData, strategySpecificConfiguration)\n      ) {\n        segmentationScalarData[index] = segmentIndex;\n        //Todo: I don't think this will always be index 2 in streamingImageVolume?\n        modifiedSlicesToUse.add(pointIJK[2]);\n      }\n    };\n  } else {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n      segmentationScalarData[index] = segmentIndex;\n      modifiedSlicesToUse.add(pointIJK[2]);\n    };\n  }\n\n  pointInShapeCallback(\n    segmentationImageData,\n    (pointLPS) =>\n      pointInEllipse(ellipseObj, pointLPS, {\n        fast: true,\n      }),\n    callback,\n    boundsIJK\n  );\n\n  const arrayOfSlices: number[] = Array.from(modifiedSlicesToUse);\n\n  triggerSegmentationDataModified(segmentationId, arrayOfSlices);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillCircle(enabledElement, operationData, false);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function thresholdInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  if (isVolumeSegmentation(operationData)) {\n    const { referencedVolumeId, volumeId } = operationData;\n\n    const imageVolume = cache.getVolume(referencedVolumeId);\n    const segmentation = cache.getVolume(volumeId);\n\n    if (\n      !csUtils.isEqual(segmentation.dimensions, imageVolume.dimensions) ||\n      !csUtils.isEqual(segmentation.direction, imageVolume.direction)\n    ) {\n      throw new Error(\n        'Only source data the same dimensions/size/orientation as the segmentation currently supported.'\n      );\n    }\n  }\n\n  fillCircle(enabledElement, operationData, true);\n}\n\n/**\n * Fill outside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels outside the  defined circle.\nj * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillOutsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  throw new Error('Not yet implemented');\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nfunction getCenter(points) {\n  // Average the points to get the center of the ellipse\n  const center = vec3.fromValues(0, 0, 0);\n  points.forEach((point) => {\n    vec3.add(center, center, point);\n  });\n  vec3.scale(center, center, 1 / points.length);\n  return center;\n}\n\nfunction getEllipse(viewport, imageData, points) {\n  const center = getCenter(points);\n  const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n  const dimensions = imageData.getDimensions();\n\n  // 1. From the drawn tool: Get the ellipse (circle) topLeft and bottomRight\n  // corners in canvas coordinates\n  const [topLeftCanvas, bottomRightCanvas] =\n    getCanvasEllipseCorners(canvasCoordinates);\n\n  // 2. Find the extent of the ellipse (circle) in IJK index space of the image\n  const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n  const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n  const ellipsoidCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, topLeftWorld),\n    <Types.Point3>transformWorldToIndex(imageData, bottomRightWorld),\n  ];\n\n  const boundsIJK = getBoundingBoxAroundShape(ellipsoidCornersIJK, dimensions);\n\n  if (boundsIJK.every(([min, max]) => min !== max)) {\n    throw new Error('Oblique segmentation tools are not supported yet');\n  }\n\n  // using circle as a form of ellipse\n  const ellipseObj = {\n    center: center as Types.Point3,\n    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n  };\n  return { ellipseObj, boundsIJK };\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { fillInsideCircle } from './fillCircle';\nimport { LabelmapToolOperationData } from '../../../types';\n\ntype OperationData = LabelmapToolOperationData & {\n  points: any; // todo fix\n};\n\nexport function eraseInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillInsideCircle functionality.\n  const eraseOperationData = {\n    ...operationData,\n    segmentIndex: 0,\n  };\n\n  fillInsideCircle(enabledElement, eraseOperationData);\n}\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","import { utilities as csUtils, getEnabledElement } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport {\n  fillInsideSphere,\n  thresholdInsideSphere,\n} from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events, ToolModes, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport {\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentsLocked: number[]; //\n    segmentationRepresentationUID?: string;\n    imageIdReferenceMap?: Map<string, string>;\n    volumeId?: string;\n    referencedVolumeId?: string;\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD_INSIDE_CIRCLE: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        brushSize: 25,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = () => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = () => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type, segmentationRepresentationUID } =\n      activeSegmentationRepresentation;\n\n    if (type === SegmentationRepresentations.Contour) {\n      throw new Error('Not implemented yet');\n    }\n\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    const viewportIdsToRender = [viewport.id];\n\n    if (isVolumeSegmentation(labelmapData)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n      const actors = viewport.getActors();\n\n      // Note: For tools that need the source data. Assumed to use\n      // First volume actor for now.\n      const firstVolumeActorUID = actors[0].uid;\n\n      this._editData = {\n        volumeId,\n        referencedVolumeId: firstVolumeActorUID,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = viewport.getCurrentImageId();\n\n      if (!imageIdReferenceMap.get(currentImageId)) {\n        // if there is no stack segmentation slice for the current image\n        // we should not allow the user to perform any operation\n        return;\n      }\n\n      // here we should identify if we can perform sphere manipulation\n      // for these stack of images, if the metadata is not present\n      // to create a volume or if there are inconsistencies between\n      // the image metadata we should not allow the sphere manipulation\n      // and should throw an error or maybe simply just allow circle manipulation\n      // and not sphere manipulation\n      if (this.configuration.activeStrategy.includes('SPHERE')) {\n        console.warn(\n          'Sphere manipulation is not supported for this stack of images yet'\n        );\n        return;\n\n        // Todo: add sphere manipulation support for stacks of images\n        // we should basically check if the stack constructs a valid volume\n        // meaning all the metadata is present and consistent\n        // then we should create a volume and use it as a reference\n        // ideally a tiny volume that does not exceeds the boundary of the\n        // sphere brush size\n        // csUtils.isValidVolume(referencedImageIds\n      }\n\n      this._editData = {\n        imageIdReferenceMap,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    return true;\n  };\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n    }\n  };\n\n  private updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const viewportIdsToRender = [viewport.id];\n\n    // Center of circle in canvas Coordinates\n\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    this._hoverData = {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n\n    this._calculateCursor(element, centerCanvas);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.updateCursor(evt);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n      viewportIdsToRender,\n    } = this._hoverData;\n\n    const { data } = brushCursor;\n    const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const operationData = {\n      ...this._editData,\n      points: data.handles.points,\n      segmentIndex,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const camera = viewport.getCamera();\n    const { brushSize } = this.configuration;\n\n    const viewUp = vec3.fromValues(\n      camera.viewUp[0],\n      camera.viewUp[1],\n      camera.viewUp[2]\n    );\n    const viewPlaneNormal = vec3.fromValues(\n      camera.viewPlaneNormal[0],\n      camera.viewPlaneNormal[1],\n      camera.viewPlaneNormal[2]\n    );\n    const viewRight = vec3.create();\n\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n    // in the world coordinate system, the brushSize is the radius of the circle\n    // in mm\n    const centerCursorInWorld: Types.Point3 = canvasToWorld([\n      centerCanvas[0],\n      centerCanvas[1],\n    ]);\n\n    const bottomCursorInWorld = vec3.create();\n    const topCursorInWorld = vec3.create();\n    const leftCursorInWorld = vec3.create();\n    const rightCursorInWorld = vec3.create();\n\n    // Calculate the bottom and top points of the circle in world coordinates\n    for (let i = 0; i <= 2; i++) {\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n    }\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      bottomCursorInWorld,\n      topCursorInWorld,\n      leftCursorInWorld,\n      rightCursorInWorld,\n    ];\n\n    data.invalidated = false;\n  }\n\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData;\n\n    const { data } = brushCursor;\n    const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.updateCursor(evt);\n\n    const operationData = {\n      points: data.handles.points,\n      ...this._editData,\n      segmentIndex,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n    };\n\n    this._editData = null;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData !== undefined) {\n      const { data } = this._hoverData.brushCursor;\n\n      data.invalidated = true;\n    }\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport default function getBrushToolInstances(\n  toolGroupId: string,\n  toolName?: string\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShape(voxelCornersIJK, dimensions);\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    // Todo: make the segmentIndex a parameter\n    if (insert) {\n      scalarData[index] = 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\n\nexport type BaseEventDetail = {\n  viewportId: string;\n  renderingEngineId: string;\n};\n\n/**\n * An annotation group\n */\n\nexport default class AnnotationGroup {\n  private annotationUIDs = new Set<string>();\n  private _isVisible = true;\n\n  public visibleFilter: (uid: string) => boolean;\n\n  constructor() {\n    this.visibleFilter = this.unboundVisibleFilter.bind(this);\n  }\n\n  /**\n   * Returns true if other groups are free to hide this annotation.\n   * That is, if the annotation is not a member or is hidden.\n   */\n  protected unboundVisibleFilter(uid: string): boolean {\n    return !this._isVisible || !this.annotationUIDs.has(uid);\n  }\n\n  public has(uid: string): boolean {\n    return this.annotationUIDs.has(uid);\n  }\n  /**\n   * Sets whether annotations belonging to this group are visible or not.\n   * If there are multiple groups, then the set visible false should be called\n   * before before re-enabling the other groups with setVisible true.\n   */\n  public setVisible(\n    isVisible = true,\n    baseEvent: BaseEventDetail,\n    filter?: (annotationUID: string) => boolean\n  ) {\n    if (this._isVisible === isVisible) {\n      return;\n    }\n    this._isVisible = isVisible;\n    this.annotationUIDs.forEach((uid) => {\n      const annotation = getAnnotation(uid);\n      if (!annotation) {\n        this.annotationUIDs.delete(uid);\n        return;\n      }\n      if (annotation.isVisible === isVisible) {\n        return;\n      }\n      if (!isVisible && filter?.(uid) === false) {\n        return;\n      }\n      annotation.isVisible = isVisible;\n      const eventDetail = {\n        ...baseEvent,\n        annotation,\n      };\n      triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n    });\n  }\n\n  public get isVisible() {\n    return this._isVisible;\n  }\n\n  /** Finds the nearby/next annotation in the given direction */\n  public findNearby(uid: string, direction: 1) {\n    const uids = [...this.annotationUIDs];\n    if (uids.length === 0) {\n      return null;\n    }\n    if (!uid) {\n      return uids[direction === 1 ? 0 : uids.length - 1];\n    }\n    const index = uids.indexOf(uid);\n    if (\n      index === -1 ||\n      index + direction < 0 ||\n      index + direction >= uids.length\n    ) {\n      return null;\n    }\n    return uids[index + direction];\n  }\n\n  /**\n   * Adds the annotation to the group\n   * Does NOT change the visibility status of the annotation.\n   */\n  public add(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.add(annotationUID)\n    );\n  }\n\n  /**\n   * Removes the annotation from the group.\n   * Does not affect the visibility status of the annotation.\n   */\n  public remove(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.delete(annotationUID)\n    );\n  }\n\n  /**\n   * Removes everything from the group.\n   */\n  public clear() {\n    this.annotationUIDs.clear();\n  }\n}\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\n\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\n\n/**\n * Tool that rotates the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  // pseudocode inspired from\n  // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  StackViewport,\n  utilities,\n  cache,\n  Types,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    const properties = viewport.getProperties();\n    if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n      volumeId = targetId.split('volumeId:')[1];\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      if (!volume) {\n        throw new Error('Volume not found ' + volumeId);\n      }\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (properties.voiRange) {\n      modality = (viewport as any).modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n      isPreScaled =\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT, treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT) {\n      newRange = this.getPTScaledNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n        isPreScaled,\n        viewport,\n        volumeId,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    viewport.setProperties({\n      voiRange: newRange,\n    });\n\n    viewport.render();\n\n    if (viewport instanceof VolumeViewport) {\n      viewportsContainingVolumeUID.forEach((vp) => {\n        if (viewport !== vp) {\n          vp.render();\n        }\n      });\n      return;\n    }\n  }\n\n  getPTScaledNewRange({\n    deltaPointsCanvas,\n    lower,\n    upper,\n    clientHeight,\n    viewport,\n    volumeId,\n    isPreScaled,\n  }) {\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (isPreScaled) {\n      multiplier = 5 / clientHeight;\n    } else {\n      multiplier =\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n        DEFAULT_MULTIPLIER;\n    }\n\n    const deltaY = deltaPointsCanvas[1];\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (ratio > 1) {\n      multiplier = Math.round(ratio);\n    }\n    return multiplier;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    if (imageData.getRange) {\n      return imageData.getRange();\n    }\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { getEnabledElementByIds, VolumeViewport } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n\n    const targetId = this.getTargetId(viewport);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n\n    const deltaPointY = deltaPoints.canvas[1];\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = targetId.split('volumeId:')[1];\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop,\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = viewport.getNumberOfSlices();\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\n\ntype Line2D = [Types.Point2, Types.Point2];\ntype Line3D = [Types.Point3, Types.Point3];\ntype Line = Line2D | Line3D;\n\n/**\n * Calculates the angle between two 3D lines.\n */\nfunction angleBetween3DLines(line1: Line3D, line2: Line3D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec3.sub(vec3.create(), p2, p1);\n  const v2 = vec3.sub(vec3.create(), p3, p4);\n\n  const dot = vec3.dot(v1, v2);\n\n  const v1Length = vec3.length(v1);\n  const v2Length = vec3.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n\n  const radian = Math.acos(cos);\n\n  return (radian * 180) / Math.PI;\n}\n\n/**\n * Calculates the angle between two 2D lines.\n */\nfunction angleBetween2DLines(line1: Line2D, line2: Line2D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec2.sub(vec2.create(), p2, p1);\n  const v2 = vec2.sub(vec2.create(), p3, p4);\n\n  const dot = vec2.dot(v1, v2);\n  const v1Length = vec2.length(v1);\n  const v2Length = vec2.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n  return Math.acos(cos) * (180 / Math.PI);\n}\n\n/**\n * Returns the angle between two lines in degrees.\n * The angle measured is that between the vectors\n * line1[1]->line1[0] AND line2[0]->line2[1].\n * @param line1 - Line = [p1, p2]\n * @param line2 - Line = [p3, p4]\n * @returns The angle between two lines in degrees.\n */\nexport default function angleBetweenLines(line1: Line, line2: Line): number {\n  const is3D = line1[0].length === 3;\n  return is3D\n    ? angleBetween3DLines(line1 as Line3D, line2 as Line3D)\n    : angleBetween2DLines(line1 as Line2D, line2 as Line2D);\n}\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) {\n      return;\n    }\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport scroll from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n        scrollSlabs: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    const targetId = this.getTargetId(viewport);\n    const volumeId = targetId.split('volumeId:')[1];\n\n    scroll(viewport, {\n      delta,\n      debounceLoading: this.configuration.debounceIfNotLoaded,\n      loop: this.configuration.loop,\n      volumeId,\n      scrollSlabs: this.configuration.scrollSlabs,\n    });\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n        invert: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 5 / size[1];\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = this.configuration.invert\n      ? deltaY / zoomScale\n      : deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    const angle = deltaY * rotateIncrementDegrees;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined\n * by a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates\n * of the rectangle defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param topLeftWorld - The first world position.\n * @param bottomRightWorld - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromCorners(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  topLeftWorld: Types.Point3,\n  bottomRightWorld: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...topLeftWorld);\n  const pos2 = vec3.fromValues(...bottomRightWorld);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n/**\n * Returns a point based on some criteria (e.g., minimum or maximum intensity) in\n * the line of sight (on the line between the passed worldPosition and camera position).\n * It iterated over the points with a step size on the line.\n *\n * @param viewport - Volume viewport\n * @param worldPos - World coordinates of the clicked location\n * @param targetVolumeId - target Volume ID in the viewport\n * @param criteriaFunction - A function that returns the point if it passes a certain\n * written logic, for instance, it can be a maxValue function that keeps the\n * records of all intensity values, and only return the point if its intensity\n * is greater than the maximum intensity of the points passed before.\n * @param stepsSize - Percentage of the spacing in the normal direction, default value\n * is 0.25 which means steps = 1/4 of the spacing in the normal direction.\n * @returns the World pos of the point that passes the criteriaFunction\n */\nexport default function getPointInLineOfSightWithCriteria(\n  viewport: Types.IVolumeViewport,\n  worldPos: Types.Point3,\n  targetVolumeId: string,\n  criteriaFunction: (intensity: number, point: Types.Point3) => Types.Point3,\n  stepSize = 0.25\n): Types.Point3 {\n  // 1. Getting the camera from the event details\n  const camera = viewport.getCamera();\n  const { position: cameraPosition } = camera;\n\n  // 2. Calculating the spacing in the normal direction, this will get\n  // used as the step size for iterating over the points in the line of sight\n  const { spacingInNormalDirection } =\n    csUtils.getTargetVolumeAndSpacingInNormalDir(\n      viewport,\n      camera,\n      targetVolumeId\n    );\n  // 2.1 Making sure, we are not missing any point\n  const step = spacingInNormalDirection * stepSize;\n\n  // 3. Getting the bounds of the viewports. Search for brightest point is\n  // limited to the visible bound\n  // Todo: this might be a problem since bounds will change to spatial bounds.\n  const bounds = viewport.getBounds();\n  const xMin = bounds[0];\n  const xMax = bounds[1];\n\n  // 5. Calculating the line, we use a parametric line definition\n  const vector = <Types.Point3>[0, 0, 0];\n\n  // 5.1 Point coordinate on the line\n  let point = <Types.Point3>[0, 0, 0];\n\n  // 5.2 Calculating the line direction, and storing in vector\n  vtkMath.subtract(worldPos, cameraPosition, vector);\n\n  let pickedPoint;\n\n  // 6. Iterating over the line from the lower bound to the upper bound, with the\n  // specified step size\n  for (let pointT = xMin; pointT <= xMax; pointT = pointT + step) {\n    // 6.1 Calculating the point x location\n    point = [pointT, 0, 0];\n    // 6.2 Calculating the point y,z location based on the line equation\n    const t = (pointT - cameraPosition[0]) / vector[0];\n    point[1] = t * vector[1] + cameraPosition[1];\n    point[2] = t * vector[2] + cameraPosition[2];\n\n    // 6.3 Checking if the points is inside the bounds\n    if (_inBounds(point, bounds)) {\n      // 6.4 Getting the intensity of the point\n      const intensity = viewport.getIntensityFromWorld(point);\n      // 6.5 Passing the intensity to the maximum value functions which decides\n      // whether the current point is of interest based on some criteria\n      const pointToPick = criteriaFunction(intensity, point);\n      if (pointToPick) {\n        pickedPoint = pointToPick;\n      }\n    }\n  }\n\n  return pickedPoint;\n}\n\n/**\n * Returns whether the point in the world is inside the bounds of the viewport\n * @param point - coordinates in the world\n * @returns boolean\n */\nconst _inBounds = function (\n  point: Types.Point3,\n  bounds: Array<number>\n): boolean {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  return (\n    point[0] > xMin &&\n    point[0] < xMax &&\n    point[1] > yMin &&\n    point[1] < yMax &&\n    point[2] > zMin &&\n    point[2] < zMax\n  );\n};\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n\n    if (!targetId.startsWith('volumeId')) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    const volumeId = targetId.split('volumeId:')[1];\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds, toolGroupId } = this.configuration;\n    // TODO - consider making this a utility\n    const viewports = renderingEngine.getViewports().filter((vp) => {\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\n        return true;\n      }\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n        return true;\n      }\n      return false;\n    });\n\n    // 6. Update all the targetedViewports to jump\n    viewports.forEach((viewport) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import { Statistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  static getStatistics: () => Statistics[];\n}\n\nexport default Calculator;\n","import { Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static sum = [0];\n  private static sumSquares = [0];\n  private static squaredDiffSum = [0];\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.squaredDiffSum.push(this.squaredDiffSum[0], this.squaredDiffSum[0]);\n    }\n\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    this.count += 1;\n\n    this.max.forEach(\n      (it, idx) => (this.max[idx] = Math.max(it, newArray[idx]))\n    );\n    this.sum.map((it, idx) => (this.sum[idx] += newArray[idx]));\n    this.sumSquares.map(\n      (it, idx) => (this.sumSquares[idx] += newArray[idx] ** 2)\n    );\n    this.squaredDiffSum.map(\n      (it, idx) =>\n        (this.squaredDiffSum[idx] += Math.pow(\n          newArray[idx] - this.sum[idx] / this.count,\n          2\n        ))\n    );\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @param points\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum²\n   */\n\n  static getStatistics = (): Statistics[] => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.squaredDiffSum.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n      Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    );\n    const currentMax = this.max;\n\n    this.max = [-Infinity];\n    this.sum = [0];\n    this.sumSquares = [0];\n    this.squaredDiffSum = [0];\n    this.count = 0;\n\n    return [\n      { name: 'max', value: singleArrayAsNumber(currentMax), unit: null },\n      { name: 'mean', value: singleArrayAsNumber(mean), unit: null },\n      { name: 'stdDev', value: singleArrayAsNumber(stdDev), unit: null },\n      {\n        name: 'stdDevWithSumSquare',\n        value: singleArrayAsNumber(stdDevWithSumSquare),\n        unit: null,\n      },\n    ];\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n\n  return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2) + Math.pow(z1 - z2, 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Orientation algoritm to determine if two lines cross.\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n */\n\nfunction getAllIntersectionsWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  let initialI;\n  let j;\n  const intersections: Types.Point2[] = [];\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  return intersections;\n}\n\n/**\n * Returns all intersections points\n * between a line and a polyline\n */\nfunction getIntersectionCoordinatesWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getAllIntersectionsWithPolyline(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n  return result;\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n */\nfunction getFirstIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n */\nfunction getClosestIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  const intersections = [];\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an orientation algorithm.\n */\nfunction doesIntersect(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the intersection between the line (`p1`,`q1`) and the line (`p2`,`q2`)\n * http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n */\nfunction getIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): Types.Point2 {\n  const denominator =\n    (q2[1] - p2[1]) * (q1[0] - p1[0]) - (q2[0] - p2[0]) * (q1[1] - p1[1]);\n  if (denominator == 0) {\n    return;\n  }\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = (q2[0] - p2[0]) * a - (q2[1] - p2[1]) * b;\n  const numerator2 = (q1[0] - p1[0]) * a - (q1[1] - p1[1]) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * (q1[0] - p1[0]);\n  const resultY = p1[1] + a * (q1[1] - p1[1]);\n\n  return [resultX, resultY];\n}\n\nexport {\n  getAllIntersectionsWithPolyline,\n  getFirstIntersectionWithPolyline,\n  getClosestIntersectionWithPolyline,\n  getIntersectionCoordinatesWithPolyline,\n};\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function calculateAreaOfPoints(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart is the same as lineEnd which means\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\n// TODO: nested config is weird\ninterface ToolConfiguration {\n  configuration?: {\n    getReferenceLineColor?: (viewportId: string) => string;\n    getReferenceLineControllable?: (viewportId: string) => boolean;\n    getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n    getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n    referenceLinesCenterGapRadius?: number;\n    shadow?: boolean;\n    autopan?: {\n      enabled: boolean;\n      panSize: number;\n    };\n    mobile?: {\n      enabled: boolean;\n      opacity: number;\n      handleRadius: number;\n    };\n  };\n}\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: true,\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // radius of the area around the intersection of the planes, in which\n        // the reference lines will not be rendered. This is only used when\n        // having 3 viewports in the toolGroup.\n        referenceLinesCenterGapRadius: 20,\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      throw new Error(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\n    const canvasBox = [0, 0, clientWidth, clientHeight];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        // to maximize the visibility of the controls, they need to be\n        // placed at most at half the length of the shortest side of the canvas.\n        // Chosen 0.4 to have some margin to the edge.\n        canvasMinDimensionLength * 0.4\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        // Chosen 0.2 because is half of 0.4.\n        canvasMinDimensionLength * 0.2\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? centerGap : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      // render a circle to pin point the viewport color\n      // TODO: This should not be part of the tool, and definitely not part of the renderAnnotation loop\n      const referenceColorCoordinates = [\n        clientWidth * 0.95,\n        clientHeight * 0.05,\n      ] as Types.Point2;\n      const circleRadius = canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    const annotations =\n      getAnnotations(this.getToolName(), viewport.element) || [];\n    const viewportIds = this._getViewportsInfo().map(\n      ({ viewportId }) => viewportId\n    );\n\n    // filter the annotations to only keep that are for this toolGroup\n    const toolGroupAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      return viewportIds.includes(data.viewportId);\n    });\n\n    return toolGroupAnnotations;\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Check if the toolCenter is outside the viewport\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    const pan = this.configuration.autoPan.panSize;\n\n    const visiblePointCanvas = <Types.Point2>[\n      toolCenterCanvas[0],\n      toolCenterCanvas[1],\n    ];\n\n    if (toolCenterCanvas[0] < 0) {\n      visiblePointCanvas[0] = pan;\n    } else if (toolCenterCanvas[0] > clientWidth) {\n      visiblePointCanvas[0] = clientWidth - pan;\n    }\n\n    if (toolCenterCanvas[1] < 0) {\n      visiblePointCanvas[1] = pan;\n    } else if (toolCenterCanvas[1] > clientHeight) {\n      visiblePointCanvas[1] = clientHeight - pan;\n    }\n\n    if (\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\n      visiblePointCanvas[1] === toolCenterCanvas[1]\n    ) {\n      return;\n    }\n\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n\n    const deltaPointsWorld = [\n      visiblePointWorld[0] - this.toolCenter[0],\n      visiblePointWorld[1] - this.toolCenter[1],\n      visiblePointWorld[2] - this.toolCenter[2],\n    ];\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.some(\n          (element) => element === annotation\n        )\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const viewportProperties = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      // match the original viewport voi range\n      magnifyViewport.setProperties(viewportProperties);\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleRadius(\n  circleCanvasPoints: canvasCoordinates\n): number {\n  const [center, end] = circleCanvasPoints;\n  return distanceToPoint(center, end);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners (wrapping square rectangle)\n * and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleCorners(\n  circleCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [center, end] = circleCanvasPoints;\n  const radius = distanceToPoint(center, end);\n\n  const topLeft = <Types.Point2>[center[0] - radius, center[1] - radius];\n  const bottomRight = <Types.Point2>[center[0] + radius, center[1] + radius];\n\n  return [topLeft, bottomRight];\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentations,\n  ToolModes,\n  Events as cstEvents,\n} from '../enums';\nimport { ToolGroupManager, state } from '../store';\nimport { debounce } from '../utilities';\nimport { ToolModeChangedEventType } from '../types/EventTypes';\nimport { segmentation } from '..';\nimport { EventTypes, IToolGroup } from '../types';\nimport {\n  AnnotationTool,\n  AdvancedMagnifyTool,\n  SegmentationDisplayTool,\n} from './';\nimport { distanceToPoint } from '../utilities/math/point';\n\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\n\n// TODO: find a better to identify segmentation actors\nconst isSegmentation = (actor) => actor.uid !== actor.referenceId;\n\nexport type AutoPanCallbackData = {\n  points: {\n    currentPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n    newPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n  };\n  delta: {\n    canvas: Types.Point2;\n    world: Types.Point3;\n  };\n};\n\nexport type AutoPanCallback = (data: AutoPanCallbackData) => void;\n\nclass AdvancedMagnifyViewport {\n  private _viewportId: string;\n  private _sourceEnabledElement: Types.IEnabledElement;\n  private _enabledElement: Types.IEnabledElement = null;\n  private _sourceToolGroup: IToolGroup = null;\n  private _magnifyToolGroup: IToolGroup = null;\n  private _isViewportReady = false;\n  private _radius = 0;\n  private _resized = false;\n  private _resizeViewportAsync: () => void;\n  private _canAutoPan = false;\n  private _autoPan: {\n    enabled: boolean;\n    padding: number;\n    callback: AutoPanCallback;\n  };\n  public position: Types.Point2;\n  public zoomFactor: number;\n  public visible: boolean;\n\n  constructor({\n    magnifyViewportId,\n    sourceEnabledElement,\n    radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS,\n    position = [0, 0],\n    zoomFactor,\n    autoPan,\n  }: {\n    magnifyViewportId?: string;\n    sourceEnabledElement: Types.IEnabledElement;\n    radius?: number;\n    position?: Types.Point2;\n    zoomFactor: number;\n    autoPan: {\n      enabled: boolean;\n      padding: number;\n      callback: AutoPanCallback;\n    };\n  }) {\n    // Private properties\n    this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n    this._sourceEnabledElement = sourceEnabledElement;\n    this._autoPan = autoPan;\n\n    // Pulic properties\n    this.radius = radius;\n    this.position = position;\n    this.zoomFactor = zoomFactor;\n    this.visible = true;\n\n    this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n    this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n    this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n    this._mouseDragCallback = this._mouseDragCallback.bind(this);\n    this._resizeViewportAsync = <() => void>(\n      debounce(this._resizeViewport.bind(this), 1)\n    );\n\n    this._initialize();\n  }\n\n  public get sourceEnabledElement() {\n    return this._sourceEnabledElement;\n  }\n\n  public get viewportId() {\n    return this._viewportId;\n  }\n\n  public get radius() {\n    return this._radius;\n  }\n\n  public set radius(radius: number) {\n    // Just moving the magnifying glass around may change its radius\n    // by very small amount due to floating number precision\n    if (Math.abs(this._radius - radius) > 0.00001) {\n      this._radius = radius;\n      this._resized = true;\n    }\n  }\n\n  public update() {\n    const { radius, position, visible } = this;\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const size = 2 * radius;\n    const [x, y] = position;\n\n    if (this._resized) {\n      this._resizeViewportAsync();\n      this._resized = false;\n    }\n\n    Object.assign(element.style, {\n      display: visible ? 'block' : 'hidden',\n      width: `${size}px`,\n      height: `${size}px`,\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(${x}px, ${y}px)`,\n    });\n\n    if (this._isViewportReady) {\n      this._syncViewports();\n      viewport.render();\n    }\n  }\n\n  public dispose() {\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    this._removeEventListeners(element);\n    renderingEngine.disableElement(viewport.id);\n\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  private _handleToolModeChanged(evt: ToolModeChangedEventType) {\n    const { _magnifyToolGroup: magnifyToolGroup } = this;\n    const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n\n    if (this._sourceToolGroup?.id !== toolGroupId) {\n      return;\n    }\n\n    switch (mode) {\n      case ToolModes.Active:\n        magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n        break;\n      case ToolModes.Passive:\n        magnifyToolGroup.setToolPassive(toolName);\n        break;\n      case ToolModes.Enabled:\n        magnifyToolGroup.setToolEnabled(toolName);\n        break;\n      case ToolModes.Disabled:\n        magnifyToolGroup.setToolDisabled(toolName);\n        break;\n      default:\n        throw new Error(`Unknow tool mode (${mode})`);\n    }\n  }\n\n  // Children elements need to inherit border-radius otherwise the canvas will\n  // trigger events when moving/dragging/clicking on the corners outside of the\n  // border (circle) region.\n  private _inheritBorderRadius(magnifyElement) {\n    const viewport = magnifyElement.querySelector('.viewport-element');\n    const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n\n    viewport.style.borderRadius = 'inherit';\n    canvas.style.borderRadius = 'inherit';\n  }\n\n  private _createViewportNode(): HTMLDivElement {\n    const magnifyElement = document.createElement('div');\n    const { radius } = this;\n    const size = radius * 2;\n\n    magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n\n    // Update the style and move the element out of the screen with \"transforms\"\n    // to make it \"invisible\" and preserving its size because when \"display\" is\n    // set to \"none\" both \"offsetWidth\" and \"offsetHeight\" returns zero. Another\n    // way would be setting \"visibility\" to \"hidden\" but \"transforms\" is used\n    // because it is already being updated when update() is called\n    Object.assign(magnifyElement.style, {\n      display: 'block',\n      width: `${size}px`,\n      height: `${size}px`,\n      position: 'absolute',\n      overflow: 'hidden',\n      borderRadius: '50%',\n      boxSizing: 'border-box',\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(-1000px, -1000px)`,\n    });\n\n    return magnifyElement;\n  }\n\n  private _convertZoomFactorToParalellScale(\n    viewport,\n    magnifyViewport,\n    zoomFactor\n  ) {\n    const { parallelScale } = viewport.getCamera();\n    const canvasRatio =\n      magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n\n    return parallelScale * (1 / zoomFactor) * canvasRatio;\n  }\n\n  private _isStackViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IStackViewport {\n    return 'setStack' in viewport;\n  }\n\n  private _isVolumeViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IVolumeViewport {\n    return 'addVolumes' in viewport;\n  }\n\n  private _cloneToolGroups(\n    sourceViewport: Types.IViewport,\n    magnifyViewport: Types.IViewport\n  ) {\n    const sourceActors = sourceViewport.getActors();\n    const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n    const sourceToolGroup = ToolGroupManager.getToolGroupForViewport(\n      sourceViewport.id,\n      sourceViewport.renderingEngineId\n    );\n\n    const magnifyToolGroup = sourceToolGroup.clone(\n      magnifyToolGroupId,\n      (toolName) => {\n        const toolInstance = sourceToolGroup.getToolInstance(toolName);\n        const isAnnotationTool =\n          toolInstance instanceof AnnotationTool &&\n          !(toolInstance instanceof AdvancedMagnifyTool);\n\n        return (\n          isAnnotationTool || toolName === SegmentationDisplayTool.toolName\n        );\n      }\n    );\n\n    magnifyToolGroup.addViewport(\n      magnifyViewport.id,\n      magnifyViewport.renderingEngineId\n    );\n\n    sourceActors.filter(isSegmentation).forEach((actor) => {\n      segmentation.addSegmentationRepresentations(magnifyToolGroupId, [\n        {\n          segmentationId: actor.referenceId,\n          type: SegmentationRepresentations.Labelmap,\n        },\n      ]);\n    });\n\n    return { sourceToolGroup, magnifyToolGroup };\n  }\n\n  private _cloneStack(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ): void {\n    const imageIds = sourceViewport.getImageIds();\n\n    magnifyViewport.setStack(imageIds).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n  }\n\n  private _cloneVolumes(\n    sourceViewport: Types.IVolumeViewport,\n    magnifyViewport: Types.IVolumeViewport\n  ): Types.IVolumeViewport {\n    const actors = sourceViewport.getActors();\n    const volumeInputArray: Types.IVolumeInput[] = actors\n      .filter((actor) => !isSegmentation(actor))\n      .map((actor) => ({ volumeId: actor.uid }));\n\n    magnifyViewport.setVolumes(volumeInputArray).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n\n    return magnifyViewport;\n  }\n\n  private _cloneViewport(sourceViewport, magnifyElement) {\n    const { viewportId: magnifyViewportId } = this;\n    const renderingEngine =\n      sourceViewport.getRenderingEngine() as Types.IRenderingEngine;\n\n    const { options: sourceViewportOptions } = sourceViewport;\n    const viewportInput = {\n      element: magnifyElement,\n      viewportId: magnifyViewportId,\n      type: sourceViewport.type,\n      defaultOptions: { ...sourceViewportOptions },\n    };\n\n    renderingEngine.enableElement(viewportInput);\n\n    const magnifyViewport = <Types.IViewport>(\n      renderingEngine.getViewport(magnifyViewportId)\n    );\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._cloneStack(sourceViewport, magnifyViewport as Types.IStackViewport);\n    } else if (this._isVolumeViewport(sourceViewport)) {\n      this._cloneVolumes(\n        sourceViewport,\n        magnifyViewport as Types.IVolumeViewport\n      );\n    }\n\n    // Prevent handling events outside of the magnifying glass because it has rounded border\n    this._inheritBorderRadius(magnifyElement);\n\n    const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n\n    this._sourceToolGroup = toolGroups.sourceToolGroup;\n    this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n  }\n\n  private _cancelMouseEventCallback(evt): void {\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  private _browserMouseUpCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Restrict the scope of magnifying glass events again\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _browserMouseDownCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    // Enable auto pan only when user clicks inside of the magnifying glass\n    // viewport otherwise it can move when interacting with annotations outside\n    // of the magnifying glass or when trying to move/resize it.\n    this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n\n    // Wait for the mouseup event to restrict the scope of magnifying glass events again\n    document.addEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Allow mouseup and mousemove events to make it possible to manipulate the\n    // tool when passing the mouse over the magnifying glass (dragging a handle).\n    // Just relying on state.isInteractingWithTool does not work because there\n    // is a 400ms delay to handle double click (see mouseDownListener) which\n    // makes the magnifying glass unresponsive for that amount of time.\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    if (!state.isInteractingWithTool) {\n      return;\n    }\n\n    const { _autoPan: autoPan } = this;\n\n    if (!autoPan.enabled || !this._canAutoPan) {\n      return;\n    }\n\n    const { currentPoints } = evt.detail;\n    const { viewport } = this._enabledElement;\n    const { canvasToWorld } = viewport;\n    const { canvas: canvasCurrent } = currentPoints;\n    const { radius: magnifyRadius } = this;\n    const canvasCenter: Types.Point2 = [magnifyRadius, magnifyRadius];\n    const dist = distanceToPoint(canvasCenter, canvasCurrent);\n    const maxDist = magnifyRadius - autoPan.padding;\n\n    // No need to pan if it is not close to the border\n    if (dist <= maxDist) {\n      return;\n    }\n\n    const panDist = dist - maxDist;\n    const canvasDeltaPos = vec2.sub(\n      vec2.create(),\n      canvasCurrent,\n      canvasCenter\n    ) as Types.Point2;\n\n    vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n    vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n\n    const newCanvasPosition = vec2.add(\n      vec2.create(),\n      this.position,\n      canvasDeltaPos\n    ) as Types.Point2;\n    const currentWorldPos = canvasToWorld(this.position);\n    const newWorldPos = canvasToWorld(newCanvasPosition);\n    const worldDeltaPos = vec3.sub(\n      vec3.create(),\n      newWorldPos,\n      currentWorldPos\n    ) as Types.Point3;\n\n    const autoPanCallbackData: AutoPanCallbackData = {\n      points: {\n        currentPosition: {\n          canvas: this.position,\n          world: currentWorldPos,\n        },\n        newPosition: {\n          canvas: newCanvasPosition,\n          world: newWorldPos,\n        },\n      },\n      delta: {\n        canvas: canvasDeltaPos,\n        world: worldDeltaPos,\n      },\n    };\n\n    autoPan.callback(autoPanCallbackData);\n  }\n\n  private _addBrowserEventListeners(element) {\n    // mousedown on document is handled in the capture phase because the other\n    // mousedown event listener added to the magnifying glass element does not\n    // allow the event to buble up and reach the document.\n    document.addEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n\n    // All mouse events should not buble up avoiding the source viewport from\n    // handling those events resulting in unexpected behaviors.\n    element.addEventListener('mousedown', this._cancelMouseEventCallback);\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    element.addEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _removeBrowserEventListeners(element) {\n    document.removeEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _addEventListeners(element) {\n    eventTarget.addEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._addBrowserEventListeners(element);\n  }\n\n  private _removeEventListeners(element) {\n    eventTarget.removeEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._removeBrowserEventListeners(element);\n  }\n\n  private _initialize() {\n    const { _sourceEnabledElement: sourceEnabledElement } = this;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { canvas: sourceCanvas } = sourceViewport;\n    const magnifyElement = this._createViewportNode();\n\n    sourceCanvas.parentNode.appendChild(magnifyElement);\n\n    this._addEventListeners(magnifyElement);\n    this._cloneViewport(sourceViewport, magnifyElement);\n    this._enabledElement = getEnabledElement(magnifyElement);\n  }\n\n  private _syncViewportsCameras(sourceViewport, magnifyViewport) {\n    const worldPos = sourceViewport.canvasToWorld(this.position);\n\n    // Use the original viewport for the base for parallelScale\n    const parallelScale = this._convertZoomFactorToParalellScale(\n      sourceViewport,\n      magnifyViewport,\n      this.zoomFactor\n    );\n\n    const { focalPoint, position, viewPlaneNormal } =\n      magnifyViewport.getCamera();\n\n    const distance = Math.sqrt(\n      Math.pow(focalPoint[0] - position[0], 2) +\n        Math.pow(focalPoint[1] - position[1], 2) +\n        Math.pow(focalPoint[2] - position[2], 2)\n    );\n\n    const updatedFocalPoint = <Types.Point3>[\n      worldPos[0],\n      worldPos[1],\n      worldPos[2],\n    ];\n\n    const updatedPosition = <Types.Point3>[\n      updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n      updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n      updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n    ];\n\n    magnifyViewport.setCamera({\n      parallelScale,\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n  }\n\n  private _syncStackViewports(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ) {\n    magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n  }\n\n  private _syncViewports() {\n    const { viewport: sourceViewport } = this._sourceEnabledElement;\n    const { viewport: magnifyViewport } = this._enabledElement;\n    const sourceProperties = sourceViewport.getProperties();\n\n    magnifyViewport.setProperties(sourceProperties);\n    this._syncViewportsCameras(sourceViewport, magnifyViewport);\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._syncStackViewports(\n        sourceViewport as Types.IStackViewport,\n        magnifyViewport as Types.IStackViewport\n      );\n    }\n  }\n\n  private _resizeViewport() {\n    const { viewport } = this._enabledElement;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    renderingEngine.resize();\n  }\n}\n\nexport { AdvancedMagnifyViewport as default, AdvancedMagnifyViewport };\n","import { vec3 } from 'gl-matrix';\nimport {\n  eventTarget,\n  Enums,\n  getRenderingEngine,\n  CONSTANTS,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationRemovedEventType } from '../types/EventTypes';\nimport { Events as cstEvents } from '../enums';\nimport {\n  AdvancedMagnifyViewport,\n  AutoPanCallback,\n} from './AdvancedMagnifyViewport';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\n// Defined the tool name internally instead of importing\n// AdvangedMagnifyTool due to cyclic dependency\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\n\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nconst { Events } = Enums;\n\nexport type MagnifyViewportInfo = {\n  // Viewport id to be used or new v4 compliant GUID is used instead\n  magnifyViewportId?: string;\n  // Enabled element where the magnifying glass shall be added to\n  sourceEnabledElement: Types.IEnabledElement;\n  // Magnifying glass position (center)\n  position: Types.Point2;\n  // Magnifying glass radius (pixels)\n  radius: number;\n  // Amount of magnification applied to the magnifying glass image compared to the source viewport.\n  zoomFactor: number;\n  // Allow panning the viewport when moving an annotation point close to the border of the magnifying glass\n  autoPan: {\n    // Enable or disable auto pan\n    enabled: boolean;\n    // Minimum distance to the border before start auto panning\n    padding: number;\n    // Callback function responsible for updating the annotation (circle)\n    // that contains the magnifying viewport\n    callback: AutoPanCallback;\n  };\n};\n\ntype MagnifyViewportsMapEntry = {\n  annotation: AdvancedMagnifyAnnotation;\n  magnifyViewport: AdvancedMagnifyViewport;\n};\n\n/**\n * Manager responsible for creating, storing and destroying magnifying glass\n * viewports. There are no restrictions to create a new instance of it but it\n * should be accessed through getInstance() method.\n */\nclass AdvancedMagnifyViewportManager {\n  private static _singleton: AdvancedMagnifyViewportManager;\n  private _magnifyViewportsMap: Map<string, MagnifyViewportsMapEntry>;\n\n  constructor() {\n    this._magnifyViewportsMap = new Map();\n    this._initialize();\n  }\n\n  /**\n   * Creates a new magnifying glass viewport manager instance when this method is\n   * called for the first time or return the instance previously created for\n   * any subsequent call (singleton pattern).\n   * @returns A magnifying viewport manager instance\n   */\n  public static getInstance(): AdvancedMagnifyViewportManager {\n    AdvancedMagnifyViewportManager._singleton =\n      AdvancedMagnifyViewportManager._singleton ??\n      new AdvancedMagnifyViewportManager();\n\n    return AdvancedMagnifyViewportManager._singleton;\n  }\n\n  /**\n   * Creates a new magnifying glass viewport instance\n   * @param viewportInfo - Viewport data used when creating a new magnifying glass viewport\n   * @returns A magnifying glass viewport instance\n   */\n  public createViewport = (\n    annotation: AdvancedMagnifyAnnotation,\n    viewportInfo: MagnifyViewportInfo\n  ): AdvancedMagnifyViewport => {\n    const {\n      magnifyViewportId,\n      sourceEnabledElement,\n      position,\n      radius,\n      zoomFactor,\n      autoPan,\n    } = viewportInfo;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { element: sourceElement } = sourceViewport;\n\n    const magnifyViewport = new AdvancedMagnifyViewport({\n      magnifyViewportId,\n      sourceEnabledElement,\n      radius,\n      position,\n      zoomFactor,\n      autoPan,\n    });\n\n    this._addSourceElementEventListener(sourceElement);\n    this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n      annotation,\n      magnifyViewport,\n    });\n\n    return magnifyViewport;\n  };\n\n  /**\n   * Find and return a magnifying glass viewport based on its id\n   * @param magnifyViewportId - Magnifying glass viewport id\n   * @returns A magnifying glass viewport instance\n   */\n  public getViewport(magnifyViewportId: string): AdvancedMagnifyViewport {\n    return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n  }\n\n  /**\n   * Release all magnifying glass viewport instances and remove all event\n   * listeners making all objects available to be garbage collected.\n   */\n  public dispose() {\n    this._removeEventListeners();\n    this._destroyViewports();\n  }\n\n  private _destroyViewport(magnifyViewportId: string) {\n    const magnifyViewportMapEntry =\n      this._magnifyViewportsMap.get(magnifyViewportId);\n\n    if (magnifyViewportMapEntry) {\n      const { magnifyViewport } = magnifyViewportMapEntry;\n      const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n      const { element: sourceElement } = sourceViewport;\n\n      this._removeSourceElementEventListener(sourceElement);\n\n      magnifyViewport.dispose();\n      this._magnifyViewportsMap.delete(magnifyViewportId);\n    }\n  }\n\n  private _destroyViewports() {\n    const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n\n    magnifyViewportIds.forEach((magnifyViewportId) =>\n      this._destroyViewport(magnifyViewportId)\n    );\n  }\n\n  private _annotationRemovedCallback = (evt: AnnotationRemovedEventType) => {\n    const { annotation } = evt.detail;\n\n    if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n      return;\n    }\n\n    this._destroyViewport(annotation.data.magnifyViewportId);\n  };\n\n  private _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n    const magnifyViewportsMapEntries = Array.from(\n      this._magnifyViewportsMap.values()\n    );\n\n    return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n      const { viewport } = magnifyViewport.sourceEnabledElement;\n      return viewport.id === sourceViewportId;\n    });\n  }\n\n  private _newStackImageCallback = (\n    evt: Types.EventTypes.StackNewImageEvent\n  ) => {\n    const { viewportId: sourceViewportId, imageId } = evt.detail;\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      annotation.metadata.referencedImageId = imageId;\n      annotation.invalidated = true;\n    });\n  };\n\n  private _newVolumeImageCallback = (\n    evt: Types.EventTypes.VolumeNewImageEvent\n  ) => {\n    const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n    const { viewPlaneNormal: currentViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      const { viewPlaneNormal } = annotation.metadata;\n\n      // Compare the normal to make sure the volume is not rotate in 3D space\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      if (!isParallel) {\n        return;\n      }\n\n      const { handles } = annotation.data;\n      const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n      const vecHandleToImagePlane = vec3.sub(\n        vec3.create(),\n        worldImagePlanePoint,\n        handles.points[0]\n      );\n      const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n      const worldDelta = vec3.scale(\n        vec3.create(),\n        currentViewPlaneNormal,\n        worldDist\n      );\n\n      // Move all handle points to the image plane to make the annotation visible\n      for (let i = 0, len = handles.points.length; i < len; i++) {\n        const point = handles.points[i];\n\n        point[0] += worldDelta[0];\n        point[1] += worldDelta[1];\n        point[2] += worldDelta[2];\n      }\n\n      annotation.invalidated = true;\n    });\n  };\n\n  private _addEventListeners() {\n    eventTarget.addEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _removeEventListeners() {\n    eventTarget.removeEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _addSourceElementEventListener(element) {\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n  }\n\n  private _removeSourceElementEventListener(element) {\n    element.removeEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.removeEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n  }\n\n  private _initialize() {\n    this._addEventListeners();\n  }\n}\n\nexport {\n  AdvancedMagnifyViewportManager as default,\n  AdvancedMagnifyViewportManager,\n};\n","import { AnnotationTool } from './base';\n\nimport {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\nimport { AnnotationCompletedEventDetail } from '../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\n\nenum AdvancedMagnifyToolActions {\n  ShowZoomFactorsList = 'showZoomFactorsList',\n}\n\nclass AdvancedMagnifyTool extends AnnotationTool {\n  static toolName;\n  static Actions = AdvancedMagnifyToolActions;\n\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        magnifyingGlass: {\n          radius: 125, // px\n          zoomFactor: 2.5,\n          zoomFactorList: [2.5, 3, 3.5, 4, 4.5, 5],\n          autoPan: {\n            enabled: true,\n            padding: 10, // px\n          },\n        },\n        actions: {\n          showZoomFactorsList: {\n            method: 'showZoomFactorsList',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Secondary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AdvancedMagnifyAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const { magnifyingGlass: config } = this.configuration;\n    const { radius, zoomFactor, autoPan } = config;\n\n    const worldHandlesPoints = this._getWorldHandlesPoints(\n      viewport,\n      canvasPos,\n      radius\n    );\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotationUID = csUtils.uuidv4();\n    const magnifyViewportId = csUtils.uuidv4();\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: AdvancedMagnifyAnnotation = {\n      annotationUID,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        sourceViewportId: viewport.id,\n        magnifyViewportId,\n        zoomFactor,\n        handles: {\n          points: worldHandlesPoints,\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    this.magnifyViewportManager.createViewport(annotation, {\n      magnifyViewportId,\n      sourceEnabledElement: enabledElement,\n      position: canvasPos,\n      radius,\n      zoomFactor,\n      autoPan: {\n        enabled: autoPan.enabled,\n        padding: autoPan.padding,\n        callback: (data: AutoPanCallbackData) => {\n          const annotationPoints = annotation.data.handles.points;\n          const { world: worldDelta } = data.delta;\n\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\n            annotationPoints[i][0] += worldDelta[0];\n            annotationPoints[i][1] += worldDelta[1];\n            annotationPoints[i][2] += worldDelta[2];\n          }\n        },\n      },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  public isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AdvancedMagnifyAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const center = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ] as Types.Point2;\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n\n    if (Math.abs(radiusPoint - radius) < proximity * 1.5) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element, deltaPoints } = eventDetail;\n    const worldPosDelta = deltaPoints?.world ?? [0, 0, 0];\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { points } = annotation.data.handles;\n\n    points.forEach((point) => {\n      point[0] += worldPosDelta[0];\n      point[1] += worldPosDelta[1];\n      point[2] += worldPosDelta[2];\n    });\n\n    annotation.invalidated = true;\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const canvasCenter: Types.Point2 = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ];\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    const newRadius = getCanvasCircleRadius([\n      canvasCenter,\n      currentCanvasPoints,\n    ]);\n    const newWorldHandlesPoints = this._getWorldHandlesPoints(\n      viewport,\n      canvasCenter,\n      newRadius\n    );\n\n    points[0] = newWorldHandlesPoints[0];\n    points[1] = newWorldHandlesPoints[1];\n    points[2] = newWorldHandlesPoints[2];\n    points[3] = newWorldHandlesPoints[3];\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    annotations = annotations?.filter(\n      (annotation) =>\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\n        viewport.id\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AdvancedMagnifyAnnotation;\n      const { annotationUID, data } = annotation;\n      const { magnifyViewportId, zoomFactor, handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as Types.Point2[];\n      const canvasTop = canvasCoordinates[0];\n      const canvasBottom = canvasCoordinates[2];\n      const canvasLeft = canvasCoordinates[3];\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n      const center = [\n        canvasLeft[0] + radius,\n        canvasTop[1] + radius,\n      ] as Types.Point2;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-advancedMagnify`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      const magnifyViewport =\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\n\n      magnifyViewport.position = center;\n      magnifyViewport.radius = radius;\n      magnifyViewport.zoomFactor = zoomFactor;\n      magnifyViewport.update();\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Basic dropdown component that allows the user to select a different zoom factor.\n  // configurations.actions may be changed to use a customized dropdown.\n  public showZoomFactorsList(\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ) {\n    const { element, currentPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvas: canvasPoint } = currentPoints;\n    const viewportElement = element.querySelector(':scope .viewport-element');\n    const currentZoomFactor = annotation.data.zoomFactor;\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\n\n    const dropdown = this._getZoomFactorsListDropdown(\n      currentZoomFactor,\n      (newZoomFactor) => {\n        if (newZoomFactor !== undefined) {\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n          annotation.invalidated = true;\n        }\n\n        remove();\n        viewport.render();\n      }\n    );\n\n    Object.assign(dropdown.style, {\n      left: `${canvasPoint[0]}px`,\n      top: `${canvasPoint[1]}px`,\n    });\n\n    viewportElement.appendChild(dropdown);\n    dropdown.focus();\n  }\n\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\n    const dropdown = document.createElement('select');\n\n    dropdown.size = 5;\n    Object.assign(dropdown.style, {\n      width: '50px',\n      position: 'absolute',\n    });\n\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n    });\n\n    dropdown.addEventListener('change', (evt) => {\n      evt.stopPropagation();\n      onChangeCallback(dropdown.value);\n    });\n\n    dropdown.addEventListener('keydown', (evt) => {\n      const shouldCancel =\n        (evt.keyCode ?? evt.which === 27) ||\n        evt.key?.toLowerCase() === 'escape';\n\n      if (shouldCancel) {\n        evt.stopPropagation();\n        onChangeCallback();\n      }\n    });\n\n    zoomFactorList.forEach((zoomFactor) => {\n      const option = document.createElement('option');\n\n      option.label = zoomFactor;\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n      option.value = zoomFactor;\n      option.defaultSelected = zoomFactor === currentZoomFactor;\n\n      dropdown.add(option);\n    });\n\n    return dropdown;\n  }\n\n  private _getWorldHandlesPoints = (\n    viewport,\n    canvasCenterPos,\n    canvasRadius\n  ): Types.Point3[] => {\n    const canvasHandlesPoints = [\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius], // top\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1]], // right\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius], // bottom\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1]], // left\n    ];\n\n    const worldHandlesPoints = canvasHandlesPoints.map((p) =>\n      viewport.canvasToWorld(p)\n    ) as Types.Point3[];\n\n    return worldHandlesPoints;\n  };\n}\n\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\n\nexport { AdvancedMagnifyTool as default };\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\n\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewport: any;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n        showFullDimension: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport || !sourceViewport.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewport,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewport } = this.editData;\n\n    let renderStatus = false;\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    if (this.configuration.showFullDimension) {\n      canvasCoordinates = this.handleFullDimension(\n        targetViewport,\n        lineStartWorld,\n        viewPlaneNormal,\n        viewUp,\n        lineEndWorld,\n        canvasCoordinates\n      );\n    }\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private handleFullDimension(\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\n    lineStartWorld: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3,\n    lineEndWorld: Types.Point3,\n    canvasCoordinates: Types.Point2[]\n  ) {\n    const renderingEngine = targetViewport.getRenderingEngine();\n    const targetId = this.getTargetId(targetViewport);\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\n\n    const referencedImageId = this.getReferencedImageId(\n      targetViewport,\n      lineStartWorld,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    if (referencedImageId && targetImage) {\n      try {\n        const { imageData, dimensions } = targetImage;\n\n        // Calculate bound image coordinates\n        const [\n          topLeftImageCoord,\n          topRightImageCoord,\n          bottomRightImageCoord,\n          bottomLeftImageCoord,\n        ] = [\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n          ]) as Types.Point3,\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate line start and end image coordinates\n        const [lineStartImageCoord, lineEndImageCoord] = [\n          lineStartWorld,\n          lineEndWorld,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate intersection points between line and image bounds\n        canvasCoordinates = [\n          [topLeftImageCoord, topRightImageCoord],\n          [topRightImageCoord, bottomRightImageCoord],\n          [bottomLeftImageCoord, bottomRightImageCoord],\n          [topLeftImageCoord, bottomLeftImageCoord],\n        ]\n          .map(([start, end]) =>\n            this.intersectInfiniteLines(\n              start,\n              end,\n              lineStartImageCoord,\n              lineEndImageCoord\n            )\n          )\n          .filter((point) => point && this.isInBound(point, dimensions))\n          .map((point) => {\n            const world = csUtils.imageToWorldCoords(\n              referencedImageId,\n              point as Types.Point2\n            );\n            return targetViewport.worldToCanvas(world);\n          });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n    return canvasCoordinates;\n  }\n\n  // get the intersection point between two infinite lines, not line segments\n  intersectInfiniteLines(\n    line1Start: Types.Point2,\n    line1End: Types.Point2,\n    line2Start: Types.Point2,\n    line2End: Types.Point2\n  ) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n\n    // Compute a2, b2, c2\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n      return;\n    }\n\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n\n    return [x, y];\n  }\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\n    return (\n      point[0] >= 0 &&\n      point[0] <= dimensions[0] &&\n      point[1] >= 0 &&\n      point[1] <= dimensions[1]\n    );\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport {\n  metaData,\n  CONSTANTS,\n  getRenderingEngine,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\n\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\nexport interface OverlayGridAnnotation extends Annotation {\n  data: {\n    viewportData: Map<string, object>;\n    pointSets: Array<object>;\n  };\n}\n\n/**\n * @public\n */\nclass OverlayGridTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceImageIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolActive = (): void => {\n    this._init();\n  };\n\n  _init = (): void => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n    if (!sourceImageIds?.length) {\n      console.warn(\n        'OverlayGridTool: No sourceImageIds provided in configuration'\n      );\n      return;\n    }\n\n    const imagePlaneModule = metaData.get(\n      'imagePlaneModule',\n      sourceImageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n      console.warn(\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\n      );\n      return;\n    }\n\n    const { frameOfReferenceUID } = imagePlaneModule;\n\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn('OverlayGridTool: No viewports found');\n      return;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const pointSets = sourceImageIds.map((id) => {\n        // check if pointSets for the imageId was calculated. If not calculate and store\n        return this.calculateImageIdPointSets(id);\n      });\n\n      const newAnnotation: OverlayGridAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          viewportData: new Map(),\n          pointSets,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * Calculates the point sets based on the image corners relative to an imageId\n   * @param imageId - The imageId to calculate the point sets for\n   * @returns\n   */\n  calculateImageIdPointSets = (imageId: string) => {\n    const {\n      imagePositionPatient,\n      rows,\n      columns,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n    } = metaData.get('imagePlaneModule', imageId);\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = <Types.Point3>[...imagePositionPatient];\n    const topRight = <Types.Point3>[...imagePositionPatient];\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\n\n    vec3.scaleAndAdd(\n      topRight,\n      imagePositionPatient,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n    vec3.scaleAndAdd(\n      bottomLeft,\n      imagePositionPatient,\n      rowCosines,\n      rows * rowPixelSpacing\n    );\n\n    vec3.scaleAndAdd(\n      bottomRight,\n      bottomLeft,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    return { pointSet1, pointSet2 };\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n\n    let renderStatus = false;\n    if (!sourceImageIds?.length) {\n      return renderStatus;\n    }\n\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n    const targetImageIds = targetViewport.getImageIds();\n    if (targetImageIds.length < 2) {\n      return renderStatus;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const imageIdNormal = <Types.Point3>(\n      this.getImageIdNormal(sourceImageIds[0])\n    );\n\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    const pointSets = annotation.data.pointSets;\n    const viewportData = annotation.data.viewportData;\n    for (let i = 0; i < sourceImageIds.length; i++) {\n      // check if pointSets for the imageId was calculated. If not calculate and store\n      const { pointSet1, pointSet2 } = pointSets[i];\n\n      const targetData =\n        viewportData.get(targetViewport.id) ||\n        this.initializeViewportData(viewportData, targetViewport.id);\n\n      // check if pointSetToUse was calculated. If not calculate and store\n      if (!targetData.pointSetsToUse[i]) {\n        let pointSetToUse = pointSet1;\n\n        let topBottomVec = vec3.subtract(\n          vec3.create(),\n          pointSet1[0],\n          pointSet1[1]\n        );\n        topBottomVec = vec3.normalize(\n          vec3.create(),\n          topBottomVec\n        ) as Types.Point3;\n\n        // check if it is perpendicular to the viewPlaneNormal which means\n        // the line does not intersect the viewPlaneNormal\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n          // 'use pointSet2';\n          pointSetToUse = pointSet2;\n        }\n\n        targetData.pointSetsToUse[i] = pointSetToUse;\n\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[0],\n          pointSetToUse[1],\n          targetViewportPlane\n        );\n\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[2],\n          pointSetToUse[3],\n          targetViewportPlane\n        );\n      }\n\n      const lineStartWorld = targetData.lineStartsWorld[i];\n      const lineEndWorld = targetData.lineEndsWorld[i];\n\n      styleSpecifier.annotationUID = annotationUID;\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n        targetViewport.worldToCanvas(world)\n      );\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = `${i}`;\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n    }\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  private initializeViewportData = (viewportData, id) => {\n    viewportData.set(id, {\n      pointSetsToUse: [],\n      lineStartsWorld: [],\n      lineEndsWorld: [],\n    });\n\n    return viewportData.get(id);\n  };\n\n  private isPerpendicular = (\n    vec1: Types.Point3,\n    vec2: Types.Point3\n  ): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  private getImageIdNormal(imageId: string): vec3 {\n    const { imageOrientationPatient } = metaData.get(\n      'imagePlaneModule',\n      imageId\n    );\n    const rowCosineVec = vec3.fromValues(\n      imageOrientationPatient[0],\n      imageOrientationPatient[1],\n      imageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      imageOrientationPatient[3],\n      imageOrientationPatient[4],\n      imageOrientationPatient[5]\n    );\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n  }\n}\n\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { drawPolyline } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { Annotation } from '../types';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\n\nexport interface SegmentationIntersectionAnnotation extends Annotation {\n  data: {\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\n  };\n}\n\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        opacity: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Initialize the annotation data and calculates surface intersections\n   * @returns\n   */\n  _init = (): void => {\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn(this.getToolName() + 'Tool: No viewports found');\n      return;\n    }\n\n    const firstViewport = getRenderingEngine(\n      viewportsInfo[0].renderingEngineId\n    )?.getViewport(viewportsInfo[0].viewportId);\n\n    if (!firstViewport) {\n      return;\n    }\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const actorsWorldPointsMap = new Map();\n      calculateSurfaceSegmentationIntersections(\n        actorsWorldPointsMap,\n        viewportsInfo\n      );\n      const newAnnotation: SegmentationIntersectionAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          actorsWorldPointsMap,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    this._init();\n  };\n\n  /**\n   * Renders the surface intersections\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    let renderStatus = false;\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n\n    actorEntries.forEach((actorEntry) => {\n      if (!actorEntry?.clippingFilter) {\n        return;\n      }\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n      if (!actorWorldPointMap) {\n        return;\n      }\n      if (!actorWorldPointMap.get(cacheId)) {\n        return;\n      }\n      let polyLineIdx = 1;\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n      for (let i = 0; i < worldPointsSet.length; i++) {\n        const worldPoints = worldPointsSet[i];\n        const canvasPoints = worldPoints.map((point) =>\n          viewport.worldToCanvas(point)\n        );\n\n        const options = {\n          color: color,\n          fillColor: color,\n          fillOpacity: this.configuration.opacity,\n          connectLastToFirst: true,\n        };\n\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n        drawPolyline(\n          svgDrawingHelper,\n          annotationUID,\n          polyLineUID,\n          canvasPoints,\n          options\n        );\n        polyLineIdx++;\n      }\n    });\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a list of viewports\n * @param actorWorldPointsMap\n * @param viewportsInfo\n */\nfunction calculateSurfaceSegmentationIntersections(\n  actorsWorldPointsMap,\n  viewportsInfo\n) {\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n    const viewport =\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n  });\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a viewport\n * generating a set of polyline points for each actor\n * @param actorWorldPointsMap\n * @param viewport\n */\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\n  actorsWorldPointsMap,\n  viewport\n) {\n  const actorEntries = viewport.getActors();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = getCacheId(viewport);\n\n  actorEntries.forEach((actorEntry) => {\n    if (!actorEntry?.clippingFilter) {\n      return;\n    }\n\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n    if (!actorWorldPointsMap) {\n      actorWorldPointsMap = new Map();\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n    }\n    if (!actorWorldPointsMap.get(cacheId)) {\n      const polyData = actorEntry.clippingFilter.getOutputData();\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n      if (!worldPointsSet) {\n        return;\n      }\n\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\n      const colorArray = actorEntry.actor.getProperty().getColor();\n      const color = colorToString(colorArray);\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n    }\n  });\n}\n\nfunction getCacheId(viewport) {\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\n\n/**\n * Transform a color array into a string\n * @param colorArray\n * @returns\n */\nfunction colorToString(colorArray): string {\n  function colorComponentToString(component) {\n    let componentString = Math.floor(component * 255).toString(16);\n    if (componentString.length === 1) {\n      componentString = '0' + componentString;\n    }\n    return componentString;\n  }\n  return (\n    '#' +\n    colorComponentToString(colorArray[0]) +\n    colorComponentToString(colorArray[1]) +\n    colorComponentToString(colorArray[2])\n  );\n}\n\n/**\n * Remove duplicate and unnecessary points\n * @param worldPoints\n * @param canvasPoints\n * @returns\n */\nfunction removeExtraPoints(viewport, worldPointsSet) {\n  return worldPointsSet.map((worldPoints) => {\n    const canvasPoints = worldPoints.map((point) => {\n      const canvasPoint = viewport.worldToCanvas(point);\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n    });\n\n    let lastPoint;\n    const newWorldPoints = [];\n    let newCanvasPoints = [];\n    // removing duplicate points\n    for (let i = 0; i < worldPoints.length; i++) {\n      if (lastPoint) {\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n          newWorldPoints.push(worldPoints[i]);\n          newCanvasPoints.push(canvasPoints[i]);\n        }\n      }\n      lastPoint = canvasPoints[i];\n    }\n\n    // checking if a middle point is near the start\n    const firstPoint = newCanvasPoints[0];\n    for (\n      let j = Math.min(30, newCanvasPoints.length);\n      j < newCanvasPoints.length;\n      j++\n    ) {\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n        newCanvasPoints = newCanvasPoints.slice(0, j);\n        return newWorldPoints.slice(0, j);\n      }\n    }\n    return newWorldPoints;\n  });\n}\n\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) {\n        hideElementCursor(element.viewport.element);\n      }\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) {\n        resetElementCursor(element.viewport.element);\n      }\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      throw new Error('No enabled element found');\n    }\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) {\n      throw new Error('Camera not found');\n    }\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) {\n      return null;\n    }\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) {\n      return;\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) {\n      return;\n    }\n    if (!annotation.data?.handles?.points) {\n      return;\n    }\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      return;\n    }\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) {\n      return;\n    }\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n      return;\n    }\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) {\n      return;\n    }\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) {\n      return;\n    }\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) {\n      return [];\n    }\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) {\n      return [];\n    }\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) {\n      return [];\n    }\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) {\n      return [];\n    }\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) {\n        return renderStatus;\n      }\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) {\n        return renderStatus;\n      }\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) {\n        return;\n      }\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n        viewport.setImageIdIndex(closestIndex);\n      }\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) {\n        return;\n      }\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) {\n        return;\n      }\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) {\n          renderingEngine.renderViewport(viewport.id);\n        }\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) {\n      return;\n    }\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (this.editData.annotation.data.viewportId == viewport.id) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width,\n      height: canvas.height,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n  MouseDragEventType,\n  MouseMoveEventType,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const scale = getCalibratedScale(image);\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: getCalibratedLengthUnits(null, image),\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats } = data;\n  const { length, width, unit } = cachedStats[targetId];\n\n  if (length === undefined) {\n    return;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  const textLines = [\n    `L: ${roundNumber(length)} ${unit}`,\n    `W: ${roundNumber(width)} ${unit}`,\n  ];\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      // Todo: move these into annotationTool class\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const scale = getCalibratedScale(image);\n\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: getCalibratedLengthUnits(null, image),\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { length, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (length === undefined || length === null || isNaN(length)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(length)} ${unit}`];\n\n  return textLines;\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import { metaData } from '@cornerstonejs/core';\n\ntype ModalityUnitOptions = {\n  isPreScaled: boolean;\n  isSuvScaled: boolean;\n};\n\nfunction getModalityUnit(\n  modality: string,\n  imageId: string,\n  options: ModalityUnitOptions\n): string {\n  if (modality === 'CT') {\n    return 'HU';\n  } else if (modality === 'PT') {\n    return _handlePTModality(imageId, options);\n  } else {\n    return '';\n  }\n}\n\nfunction _handlePTModality(imageId: string, options: ModalityUnitOptions) {\n  if (!options.isPreScaled) {\n    return 'raw';\n  }\n\n  if (options.isSuvScaled) {\n    return 'SUV';\n  }\n\n  const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n\n  // it might be possible that the referenceImageId is not the one\n  // that is being displayed. So we need to get the modality from imageId again\n  if (generalSeriesModule?.modality === 'PT') {\n    const petSeriesModule = metaData.get('petSeriesModule', imageId);\n    return petSeriesModule?.units || 'unitless';\n  }\n}\n\nexport { getModalityUnit, ModalityUnitOptions };\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1 ? targetIdTokens[1] : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport roundNumber from '../../utilities/roundNumber';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\n\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { viewportId } = enabledElement;\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].value == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          options\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      const samplesPerPixel =\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0] * samplesPerPixel;\n        const zMultiple = dimensions[0] * dimensions[1] * samplesPerPixel;\n\n        const baseIndex =\n          index[2] * zMultiple +\n          index[1] * yMultiple +\n          index[0] * samplesPerPixel;\n        const value =\n          samplesPerPixel > 2\n            ? [\n                scalarData[baseIndex],\n                scalarData[baseIndex + 1],\n                scalarData[baseIndex + 2],\n              ]\n            : scalarData[baseIndex];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = csUtils.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        const modalityUnit = getModalityUnit(\n          modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        cachedStats[targetId] = {\n          index,\n          value,\n          Modality: modality,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${roundNumber(value)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const color = this.getStyle('color', styleSpecifier, annotation);\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].value == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const scale = getCalibratedScale(image);\n\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          stdDev: stats[2]?.value,\n          max: stats[0]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data, targetId: string): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined by\n * a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates of the rectangle\n * defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param worldPos1 - The first world position.\n * @param worldPos2 - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromTwoPoints(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  worldPos1: Types.Point3,\n  worldPos2: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...worldPos1);\n  const pos2 = vec3.fromValues(...worldPos2);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipseByCoordinates as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerWorld?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerWorld: worldPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let centerWorld;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const { viewport } = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n\n      centerWorld = canvasToWorld(centerCanvas);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerWorld,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { viewport } = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerWorld,\n      originalHandleCanvas,\n    } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      let canvasCorners;\n\n      canvasCorners = <Array<Types.Point2>>(\n        getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n      );\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCoordinates,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const area =\n          Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n          scale /\n          scale;\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          max: stats[0]?.value,\n          stdDev: stats[2]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n  getCalibratedAspect,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(\n          Math.PI *\n            (worldWidth / scale / 2) *\n            (worldHeight / aspect / scale / 2)\n        );\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) =>\n            pointInEllipse(ellipseObj, pointLPS, {\n              fast: true,\n            }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          max: stats[0]?.value,\n          stdDev: stats[2]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          radius: worldWidth / 2 / scale,\n          radiusUnit: getCalibratedLengthUnits(null, image),\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    radius,\n    radiusUnit,\n    area,\n    mean,\n    stdDev,\n    max,\n    isEmptyArea,\n    Modality,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (radius) {\n    const radiusLine = isEmptyArea\n      ? `Radius: Oblique not supported`\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\n    textLines.push(radiusLine);\n  }\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { Types } from '@cornerstonejs/core';\nimport * as math from '../../../utilities/math';\nimport type {\n  ISpline,\n  SplineProps,\n  SplineLineSegment,\n  ClosestControlPoint,\n  ClosestSplinePoint,\n  ClosestPoint,\n  ControlPointInfo,\n  SplineCurveSegment,\n} from '../../../types';\n\ntype CurveSegmentDistanceSquared = {\n  curveSegmentIndex: number;\n  curveSegment: SplineCurveSegment;\n  distanceSquared: number;\n};\n\n/**\n * Spline curve representation\n *\n * You can find more about splines in this video\n * https://www.youtube.com/watch?v=jvPPXbo87ds&t=11m20s\n */\nabstract class Spline implements ISpline {\n  private _controlPoints: Types.Point2[] = [];\n  private _resolution: number;\n  private _closed: boolean;\n  private _invalidated = false;\n  private _curveSegments: SplineCurveSegment[];\n  private _aabb: Types.AABB2;\n  private _length = 0;\n\n  constructor(props?: SplineProps) {\n    this._controlPoints = [];\n    this._resolution = props?.resolution ?? 20;\n    this._closed = props?.closed ?? false;\n    this._invalidated = true;\n  }\n\n  /**\n   * Return the control points array\n   *\n   * Any external access should be done through getControlPoints because it\n   * clones the points to make sure the data will not get changed by the caller\n   */\n  protected get controlPoints(): Types.Point2[] {\n    return this._controlPoints;\n  }\n\n  /** Number of control points */\n  public get numControlPoints(): number {\n    return this._controlPoints.length;\n  }\n\n  /** Resolution of the spline curve (greater than or equal to 0) */\n  public get resolution(): number {\n    return this._resolution;\n  }\n\n  /** Set the resolution of the spline curve */\n  public set resolution(resolution: number) {\n    if (this._resolution === resolution) {\n      return;\n    }\n\n    this._resolution = resolution;\n    this.invalidated = true;\n  }\n\n  /** Flag that is set to true when the curve is already closed */\n  public get closed(): boolean {\n    return this._closed;\n  }\n\n  /** Set the curve as closed which connects the last to the first point */\n  public set closed(closed: boolean) {\n    if (this._closed === closed) {\n      return;\n    }\n\n    this._closed = closed;\n    this.invalidated = true;\n  }\n\n  /** Axis-aligned bounding box (minX, minY, maxX, maxY) */\n  public get aabb(): Types.AABB2 {\n    this._update();\n    return this._aabb;\n  }\n\n  /** Length of the spline curve in pixels */\n  public get length(): number {\n    this._update();\n    return this._length;\n  }\n\n  /**\n   * Flag that is set to true when the spline needs to be updated. The update\n   * runs automaticaly when needed (eg: getPolylinePoints).\n   */\n  public get invalidated(): boolean {\n    return this._invalidated;\n  }\n\n  /**\n   * Sets the spline as invalid when curve segments need to be recalculated\n   * or as valid after recomputing the curves\n   */\n  protected set invalidated(invalidated: boolean) {\n    this._invalidated = invalidated;\n  }\n\n  /**\n   * Bézier curves have tangent points connected to control points\n   * @returns True if the spline has tangent point or false otherwise\n   */\n  public hasTangentPoints() {\n    return false;\n  }\n\n  /**\n   * Add a control point to the end of the array\n   * @param point - Control point (2D)\n   */\n  public addControlPoint(point: Types.Point2): void {\n    this._controlPoints.push([point[0], point[1]]);\n    this.invalidated = true;\n  }\n\n  /**\n   * Add a list of control poits to the end of the array\n   * @param points - Control points to be added\n   */\n  public addControlPoints(points: Types.Point2[]): void {\n    points.forEach((point) => this.addControlPoint(point));\n  }\n\n  /**\n   * Add a control point specifying its `u` value in Parameter Space which is a number from 0 to N\n   * where N is the number of curve segments. The integer part is the curve segment index and the\n   * decimal part is the `t` value on that curve segment.\n   * @param u - `u` value in Parameter Space\n   */\n  public addControlPointAtU(u: number): ControlPointInfo {\n    const lineSegment = this._getLineSegmentAt(u);\n    const { start: startPoint, end: endPoint } = lineSegment.points;\n    const curveSegmentIndex = Math.floor(u);\n    const curveSegment = this._curveSegments[curveSegmentIndex];\n    const t = u - Math.floor(curveSegmentIndex);\n    const controlPointPos: Types.Point2 = [\n      startPoint[0] + t * (endPoint[0] - startPoint[0]),\n      startPoint[1] + t * (endPoint[1] - startPoint[1]),\n    ];\n\n    const insertIndex =\n      this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n\n    this._controlPoints.splice(insertIndex, 0, controlPointPos);\n    this.invalidated = true;\n\n    return {\n      index: insertIndex,\n      point: controlPointPos,\n    };\n  }\n\n  /**\n   * Delete a control point given its index\n   * @param index - Control point index to be removed\n   * @returns True if the control point is removed or false otherwise\n   */\n  public deleteControlPointByIndex(index: number): boolean {\n    const minControlPoints = this._closed ? 3 : 1;\n    const canDelete =\n      index >= 0 &&\n      index < this._controlPoints.length &&\n      this._controlPoints.length > minControlPoints;\n\n    if (!canDelete) {\n      return false;\n    }\n\n    this._controlPoints.splice(index, 1);\n    this.invalidated = true;\n\n    return true;\n  }\n\n  /**\n   * Remove all control points\n   */\n  public clearControlPoints(): void {\n    this._controlPoints = [];\n    this.invalidated = true;\n  }\n\n  /**\n   * Replace all control points by some new ones\n   * @param points - Control points to be added to the array\n   */\n  public setControlPoints(points: Types.Point2[]): void {\n    this.clearControlPoints();\n    this.addControlPoints(points);\n  }\n\n  /**\n   * Update the coordinate of a control point given its index\n   * @param index - Control point index\n   * @param newControlPoint - New control point\n   */\n  public updateControlPoint(\n    index: number,\n    newControlPoint: Types.Point2\n  ): void {\n    if (index < 0 || index >= this._controlPoints.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    this._controlPoints[index] = [...newControlPoint];\n    this.invalidated = true;\n  }\n\n  /**\n   * Get a list with all control points. The control points are cloned to prevent\n   * any caller from changing them resulting in unexpected behaviors\n   * @returns - List of all control points\n   */\n  public getControlPoints(): Types.Point2[] {\n    return this._controlPoints.map((controlPoint) => [\n      controlPoint[0],\n      controlPoint[1],\n    ]);\n  }\n\n  /**\n   * Finds the closest control point given a 2D point\n   * @param point - Reference point\n   * @returns Closest control point\n   */\n  public getClosestControlPoint(point: Types.Point2): ClosestControlPoint {\n    const controlPoints = this._controlPoints;\n    let minSquaredDist = Infinity;\n    let closestPointIndex = -1;\n\n    for (let i = 0, len = controlPoints.length; i < len; i++) {\n      const controlPoint = controlPoints[i];\n      const dx = point[0] - controlPoint[0];\n      const dy = point[1] - controlPoint[1];\n      const squaredDist = dx * dx + dy * dy;\n\n      if (squaredDist < minSquaredDist) {\n        minSquaredDist = squaredDist;\n        closestPointIndex = i;\n      }\n    }\n\n    return {\n      index: closestPointIndex,\n      point:\n        closestPointIndex === -1\n          ? undefined\n          : [...controlPoints[closestPointIndex]],\n      distance: Math.sqrt(minSquaredDist),\n    };\n  }\n\n  /**\n   * Finds the closest control point given a 2D point and a maximum distance\n   * @param point - Reference 2D point\n   * @param maxDist - Maximum distance\n   * @returns Closest control point that is within the given range or undefined otherwise\n   */\n  public getClosestControlPointWithinDistance(\n    point: Types.Point2,\n    maxDist: number\n  ): ClosestControlPoint {\n    const closestControlPoint = this.getClosestControlPoint(point);\n\n    return closestControlPoint.distance <= maxDist\n      ? closestControlPoint\n      : undefined;\n  }\n\n  /**\n   * Finds the closest point on the spline curve given 2D point\n   * @param point - Reference 2D point\n   * @returns Closest point on the spline curve\n   */\n  public getClosestPoint(point: Types.Point2): ClosestSplinePoint {\n    this._update();\n\n    const curveSegmentsDistInfo =\n      this._getCurveSegmmentsDistanceSquaredInfo(point);\n\n    if (!curveSegmentsDistInfo.length) {\n      return;\n    }\n\n    // Sort the curves by distance because in most cases the closest point may be in the first\n    // curve segment and there is no need to check all next line segments if theirs curve segments'\n    // AABB is not closest compared to the minDist found saving a lot of cpu time.\n    curveSegmentsDistInfo.sort(\n      (csA, csB) => csA.distanceSquared - csB.distanceSquared\n    );\n\n    let closestPoint: Types.Point2;\n    let closestPointCurveSegmentIndex = -1;\n    let minDistSquared = Infinity;\n    let minDistCurveSegment: SplineCurveSegment;\n    let minDistLineSegment: SplineLineSegment;\n\n    for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n      const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n\n      // If the distance to curve segments' AABB is greater than the minDist\n      // it does not need to waste time verifying each line segment\n      if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n        continue;\n      }\n\n      const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n      const { lineSegments } = curveSegment;\n\n      for (let j = 0; j < lineSegments.length; j++) {\n        const lineSegment = lineSegments[j];\n        const { point: lineSegPoint, distanceSquared: lineSegDistSquared } =\n          math.lineSegment.distanceToPointSquaredInfo(\n            lineSegment.points.start,\n            lineSegment.points.end,\n            point\n          );\n\n        if (lineSegDistSquared < minDistSquared) {\n          minDistLineSegment = lineSegment;\n          closestPointCurveSegmentIndex = curveSegmentIndex;\n          minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n          closestPoint = lineSegPoint;\n          minDistSquared = lineSegDistSquared;\n        }\n      }\n    }\n\n    const curveSegmentLengthToPoint =\n      minDistLineSegment.previousLineSegmentsLength +\n      math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n\n    const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n    const u = closestPointCurveSegmentIndex + t;\n\n    return {\n      point: closestPoint,\n      uValue: u,\n      distance: Math.sqrt(minDistSquared),\n    };\n  }\n\n  /**\n   * Finds the closest point on the straight line that connects all control points given a 2D point\n   * @param point - Reference point\n   * @returns Closest point on the straight line that connects all control points\n   */\n  public getClosestPointOnControlPointLines(point: Types.Point2): ClosestPoint {\n    const linePoints = [...this._controlPoints];\n\n    if (this._closed) {\n      linePoints.push(this._controlPoints[0]);\n    }\n\n    if (!linePoints.length) {\n      return;\n    }\n\n    let closestPoint: Types.Point2;\n    let minDistSquared = Infinity;\n    let startPoint = linePoints[0];\n\n    for (let i = 1, len = linePoints.length; i < len; i++) {\n      const endPoint = linePoints[i];\n      const { point: lineSegPoint, distanceSquared: lineSegDistSquared } =\n        math.lineSegment.distanceToPointSquaredInfo(\n          startPoint,\n          endPoint,\n          point\n        );\n\n      if (lineSegDistSquared < minDistSquared) {\n        closestPoint = lineSegPoint;\n        minDistSquared = lineSegDistSquared;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return {\n      point: closestPoint,\n      distance: Math.sqrt(minDistSquared),\n    };\n  }\n\n  /**\n   * Get all points necessary to draw a spline curve\n   * @returns Array with all points necessary to draw a spline curve\n   */\n  public getPolylinePoints(): Types.Point2[] {\n    this._update();\n\n    return this._convertCurveSegmentsToPolyline(this._curveSegments);\n  }\n\n  /**\n   * Get all points necessary to draw the preview of the changes that shall be\n   * made to the spline if a new control point is added to it\n   * @param controlPointPreview - New control point preview\n   * @param closeDistance - Distance to the first control point to consider it a closed spline\n   * @returns Array with all points necessary to draw a spline curve preview\n   */\n  public getPreviewPolylinePoints(\n    controlPointPreview: Types.Point2,\n    closeDistance: number\n  ): Types.Point2[] {\n    if (this._closed) {\n      return [];\n    }\n\n    this._update();\n\n    // Check if the new control point would be close to the first one\n    // in order to create a preview of a closed spline\n    const closestControlPoint = this.getClosestControlPointWithinDistance(\n      controlPointPreview,\n      closeDistance\n    );\n\n    const closeSpline = closestControlPoint?.index === 0;\n    const previewCurveSegments = this.getPreviewCurveSegments(\n      controlPointPreview,\n      closeSpline\n    );\n\n    return previewCurveSegments?.length\n      ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n      : [];\n  }\n\n  /**\n   * Checks if a point is near to the spline curve\n   * @param point - Reference point\n   * @param maxDist - Maximum allowed distance\n   * @returns True if the point is close to the spline curve or false otherwise\n   */\n  public isPointNearCurve(point: Types.Point2, maxDist: number): boolean {\n    this._update();\n\n    const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n    const maxDistSquared = maxDist * maxDist;\n\n    // Check if the point is close to the spline and doest waste time checking each curve/line\n    for (let i = 0; i < curveSegments.length; i++) {\n      const { lineSegments } = curveSegments[i];\n\n      for (let j = 0; j < lineSegments.length; j++) {\n        const lineSegment = lineSegments[j];\n        const lineDistSquared = math.lineSegment.distanceToPointSquared(\n          lineSegment.points.start,\n          lineSegment.points.end,\n          point\n        );\n\n        if (lineDistSquared <= maxDistSquared) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if a 2D point is inside the spline curve.\n   *\n   * A point is inside a curve/polygon if the number of intersections between the horizontal\n   * ray emanating from the given point and to the right and the line segments is odd.\n   * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n   *\n   * @param point - 2D Point\n   * @returns True is the point is inside the spline curve or false otherwise\n   */\n  public containsPoint(point: Types.Point2): boolean {\n    this._update();\n\n    const controlPoints = this._controlPoints;\n\n    if (controlPoints.length < 3) {\n      return false;\n    }\n\n    const curveSegments = [...this._curveSegments];\n    const closingCurveSegment =\n      this._getClosingCurveSegmentWithStraightLineSegment();\n\n    if (closingCurveSegment) {\n      curveSegments.push(closingCurveSegment);\n    }\n\n    let numIntersections = 0;\n\n    for (let i = 0; i < curveSegments.length; i++) {\n      const curveSegment = curveSegments[i];\n      const { aabb: curveSegAABB } = curveSegment;\n      const mayIntersectCurveSegment =\n        point[0] <= curveSegAABB.maxX &&\n        point[1] >= curveSegAABB.minY &&\n        point[1] < curveSegAABB.maxY;\n\n      // Skip all line segments if it is not possible to intersect the curve segment\n      if (!mayIntersectCurveSegment) {\n        continue;\n      }\n\n      const { lineSegments } = curveSegment;\n\n      for (let i = 0; i < lineSegments.length; i++) {\n        const lineSegment = lineSegments[i];\n        const { aabb: lineSegmentAABB } = lineSegment;\n        const mayIntersectLineSegment =\n          point[0] <= lineSegmentAABB.maxX &&\n          point[1] >= lineSegmentAABB.minY &&\n          point[1] < lineSegmentAABB.maxY;\n\n        if (mayIntersectLineSegment) {\n          const { start: p1, end: p2 } = lineSegment.points;\n          const isVerticalLine = p1[0] === p2[0];\n          const xIntersection =\n            ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n          numIntersections +=\n            isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n        }\n      }\n    }\n\n    return numIntersections % 2 === 1;\n  }\n\n  protected abstract getTransformMatrix(): number[];\n\n  protected abstract getSplineCurves(): SplineCurveSegment[];\n\n  protected abstract getPreviewCurveSegments(\n    controlPointPreview: Types.Point2,\n    closeSpline: boolean\n  ): SplineCurveSegment[];\n\n  private _update() {\n    if (!this._invalidated) {\n      return;\n    }\n\n    const curveSegments = this.getSplineCurves();\n    let length = 0;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (let i = 0, len = curveSegments.length; i < len; i++) {\n      const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n\n      minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n      minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n      maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n      maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n      length += curveSegLength;\n    }\n\n    this._curveSegments = curveSegments;\n    this._aabb = { minX, minY, maxX, maxY };\n    this._length = length;\n    this._invalidated = false;\n  }\n\n  private _convertCurveSegmentsToPolyline(\n    curveSegments: SplineCurveSegment[]\n  ): Types.Point2[] {\n    this._update();\n\n    const polylinePoints: Types.Point2[] = [];\n\n    curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n      lineSegments.forEach((lineSegment, lineSegIndex) => {\n        // Add the start point before adding all end points\n        if (curveSegIndex === 0 && lineSegIndex === 0) {\n          polylinePoints.push([...lineSegment.points.start]);\n        }\n\n        // Always add 1 because the first segment stored its start point at the first position\n        polylinePoints.push([...lineSegment.points.end]);\n      });\n    });\n\n    return polylinePoints;\n  }\n\n  /**\n   * Returns all curve segments and theirs respective squared distance to a given point\n   * @param point - Reference point\n   * @returns Curve segments and theirs respective squared distance to a given point\n   */\n  private _getCurveSegmmentsDistanceSquaredInfo(\n    point: Types.Point2\n  ): CurveSegmentDistanceSquared[] {\n    this._update();\n\n    const curveSegmentsDistanceSquared: CurveSegmentDistanceSquared[] = [];\n    const { _curveSegments: curveSegments } = this;\n\n    for (let i = 0; i < curveSegments.length; i++) {\n      const curveSegment = curveSegments[i];\n      const distanceSquared = math.aabb.distanceToPointSquared(\n        curveSegment.aabb,\n        point\n      );\n\n      curveSegmentsDistanceSquared.push({\n        curveSegmentIndex: i,\n        curveSegment,\n        distanceSquared,\n      });\n    }\n\n    return curveSegmentsDistanceSquared;\n  }\n\n  private _getCurveSegmmentsWithinDistance(\n    point: Types.Point2,\n    maxDist: number\n  ): SplineCurveSegment[] {\n    this._update();\n\n    const maxDistSquared = maxDist * maxDist;\n\n    // Does not waste time checking each curve segment if the point is not event\n    // close to the spline's AABB\n    if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n      return [];\n    }\n\n    const curveSegmentsDistance =\n      this._getCurveSegmmentsDistanceSquaredInfo(point);\n    const curveSegmentsWithinRange: SplineCurveSegment[] = [];\n\n    for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n      const { curveSegment, distanceSquared: curveSegmentDistSquared } =\n        curveSegmentsDistance[i];\n\n      if (curveSegmentDistSquared <= maxDistSquared) {\n        curveSegmentsWithinRange.push(curveSegment);\n      }\n    }\n\n    return curveSegmentsWithinRange;\n  }\n\n  private _getLineSegmentAt(u: number): SplineLineSegment {\n    this._update();\n\n    const curveSegmentIndex = Math.floor(u);\n    const t = u - curveSegmentIndex;\n    const curveSegment = this._curveSegments[curveSegmentIndex];\n    const { lineSegments } = curveSegment;\n    const pointLength = curveSegment.length * t;\n\n    for (let i = 0; i < lineSegments.length; i++) {\n      const lineSegment = lineSegments[i];\n      const lengthEnd =\n        lineSegment.previousLineSegmentsLength + lineSegment.length;\n\n      if (\n        pointLength >= lineSegment.previousLineSegmentsLength &&\n        pointLength <= lengthEnd\n      ) {\n        return lineSegment;\n      }\n    }\n  }\n\n  /**\n   * Creates a curve segment with a single line segment connecting the start and end control points\n   * @returns A curve segment that closes the spline\n   */\n  private _getClosingCurveSegmentWithStraightLineSegment(): SplineCurveSegment {\n    if (this.closed) {\n      return;\n    }\n\n    const controlPoints = this._controlPoints;\n    const startControlPoint = controlPoints[0];\n    const endControlPoint = controlPoints[controlPoints.length - 1];\n\n    // The only properties needed are `points` and `aabb`. All the other ones may undefined\n    const closingLineSegment: SplineLineSegment = {\n      points: {\n        start: [...startControlPoint],\n        end: [...endControlPoint],\n      },\n      aabb: {\n        minX: Math.min(startControlPoint[0], endControlPoint[0]),\n        minY: Math.min(startControlPoint[1], endControlPoint[1]),\n        maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n        maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n      },\n    } as SplineLineSegment;\n\n    // The only properties needed are `lineSegments` and `aabb`. All the other ones may undefined\n    return {\n      aabb: {\n        minX: closingLineSegment.aabb.minX,\n        minY: closingLineSegment.aabb.minY,\n        maxX: closingLineSegment.aabb.maxX,\n        maxY: closingLineSegment.aabb.maxY,\n      },\n      lineSegments: [closingLineSegment],\n    } as SplineCurveSegment;\n  }\n}\n\nexport { Spline as default, Spline };\n","import { vec4, mat4 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nimport type { SplineCurveSegment, SplineLineSegment } from '../../../types';\n\n// The `u` in Parameter Space used when spliting a curve segment into line segments must\n// be greater than or equal to `curveSegmentIndex` and smaller than `curveSegmentIndex + 1`.\n// In this case we are using `curveSegmentIndex + 1 - MAX_U_ERROR`\nconst MAX_U_ERROR = 1e-8;\n\n/**\n * Base class for all cubic splines\n */\nabstract class CubicSpline extends Spline {\n  protected getPreviewCurveSegments(\n    controlPointPreview: Types.Point2,\n    closeSpline: boolean\n  ): SplineCurveSegment[] {\n    const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n    const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n    const endCurveSegIndex = closeSpline\n      ? previewNumCurveSegments\n      : previewNumCurveSegments - 1;\n    const transformMatrix = this.getTransformMatrix();\n    const controlPoints = [...this.controlPoints];\n    const curveSegments: SplineCurveSegment[] = [];\n\n    if (!closeSpline) {\n      controlPoints.push(controlPointPreview);\n    }\n\n    for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n      const curveSegment = this._getCurveSegment(\n        i,\n        transformMatrix,\n        controlPoints,\n        closeSpline\n      );\n\n      curveSegments.push(curveSegment);\n    }\n\n    return curveSegments;\n  }\n\n  protected getSplineCurves(): SplineCurveSegment[] {\n    const numCurveSegments = this._getNumCurveSegments();\n    const curveSegments: SplineCurveSegment[] = new Array(numCurveSegments);\n\n    if (numCurveSegments <= 0) {\n      return [];\n    }\n\n    const transformMatrix = this.getTransformMatrix();\n    let previousCurveSegmentsLength = 0;\n\n    for (let i = 0; i < numCurveSegments; i++) {\n      const curveSegment = this._getCurveSegment(i, transformMatrix);\n\n      curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n      curveSegments[i] = curveSegment;\n\n      previousCurveSegmentsLength += curveSegment.length;\n    }\n\n    return curveSegments;\n  }\n\n  private _getNumCurveSegments(\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): number {\n    return closed\n      ? controlPoints.length\n      : Math.max(0, controlPoints.length - 1);\n  }\n\n  /**\n   * Get a point on a spline curve given `u` value\n   *\n   * @param u - `u` value in Parameter Space that must be between 0 and N where N is the number of\n   *   curve segments for opened splines or any negative/positive number for closed splines\n   * @returns - Point (x, y) on the spline. It may return `undefined` when `u` is smaller than 0\n   *   or greater than N for opened splines\n   */\n  private _getPoint(\n    u: number,\n    transformMatrix: number[],\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): Types.Point2 {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const uInt = Math.floor(u);\n    let curveSegmentIndex = uInt % numCurveSegments;\n\n    // `t` must be between 0 and 1\n    const t = u - uInt;\n\n    const curveSegmentIndexOutOfBounds =\n      curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n\n    if (curveSegmentIndexOutOfBounds) {\n      if (this.closed) {\n        // Wraps around when the index is negative or greater than or equal to `numSegments`\n        curveSegmentIndex =\n          (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n      } else {\n        // Point is not on the spline curve\n        return;\n      }\n    }\n\n    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(\n      curveSegmentIndex,\n      controlPoints,\n      closed\n    );\n\n    // Formula to find any point on a cubic spline curve given a `t` value\n    //\n    // P(t) = [1  t  t2  t3] | m00 m01 m02 m03 |  | P0 |\n    //                       | m10 m11 m12 m13 |  | P1 |\n    //                       | m20 m21 m22 m23 |  | P2 |\n    //                       | m30 m31 m32 m33 |  | P3 |\n\n    const tt = t * t;\n    const ttt = tt * t;\n    const tValues = vec4.fromValues(1, t, tt, ttt);\n\n    // Influential field values which tell us how much P0, P1, P2 and P3 influence\n    // each point of the curve\n    const qValues = vec4.transformMat4(\n      vec4.create(),\n      tValues,\n      transformMatrix as mat4\n    );\n\n    return [\n      vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n      vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n    ] as Types.Point2;\n  }\n\n  private _getCurveSegmentPoints(\n    curveSegmentIndex: number,\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ) {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const p1Index = curveSegmentIndex;\n    const p0Index = p1Index - 1;\n    const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n    const p3Index = p2Index + 1;\n    const p1 = controlPoints[p1Index];\n    const p2 = controlPoints[p2Index];\n    let p0;\n    let p3;\n\n    // P0 shall be negative when P1/P2 are the start/end points of the first curve segment\n    if (p0Index >= 0) {\n      p0 = controlPoints[p0Index];\n    } else {\n      p0 = closed\n        ? controlPoints[controlPoints.length - 1]\n        : math.point.mirror(p2, p1);\n    }\n\n    // P3 shall be negative when P1/P2 are the start/end points of the last curve segment\n    if (p3Index < controlPoints.length) {\n      p3 = controlPoints[p3Index];\n    } else {\n      p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n    }\n\n    return { p0, p1, p2, p3 };\n  }\n\n  private _getLineSegments(\n    curveSegmentIndex: number,\n    transformMatrix: number[],\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): SplineLineSegment[] {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const numLineSegments = this.resolution + 1;\n    const inc = 1 / numLineSegments;\n    const minU = curveSegmentIndex;\n    let maxU = minU + 1;\n\n    // 'u' must be greater than or equal to 0 and smaller than N where N is the number of segments\n    // otherwise it does not find the spline segment when it is not a closed curve because it is\n    // 0-based indexed. In this case `u` needs to get very close to the end point but never touch it\n    if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n      maxU -= MAX_U_ERROR;\n    }\n\n    const lineSegments: SplineLineSegment[] = [];\n    let startPoint: Types.Point2;\n    let endPoint: Types.Point2;\n    let previousLineSegmentsLength = 0;\n\n    for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n      // `u` may be greater than maxU in the last FOR loop due to number precision issue\n      u = u > maxU ? maxU : u;\n\n      const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n\n      if (!i) {\n        startPoint = point;\n        continue;\n      }\n\n      endPoint = point;\n\n      const dx = endPoint[0] - startPoint[0];\n      const dy = endPoint[1] - startPoint[1];\n      const length = Math.sqrt(dx ** 2 + dy ** 2);\n      const aabb: Types.AABB2 = {\n        minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n        maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n        minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n        maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n      };\n\n      lineSegments.push({\n        points: {\n          start: startPoint,\n          end: endPoint,\n        },\n        aabb,\n        length,\n        previousLineSegmentsLength,\n      });\n\n      startPoint = endPoint;\n      previousLineSegmentsLength += length;\n    }\n\n    return lineSegments;\n  }\n\n  private _getCurveSegment(\n    curveSegmentIndex: number,\n    transformMatrix: number[] = this.getTransformMatrix(),\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): SplineCurveSegment {\n    // Cubic spline curves are mainly controlled by P1 and P2 points but\n    // they are also influenced by previous (P0) and next (P3) poins. For\n    // Cardinal, Linear and Catmull-Rom splines P1 and P2 are also known as\n    // knots because they are the connection between two curve segments.\n    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(\n      curveSegmentIndex,\n      controlPoints,\n      closed\n    );\n    const lineSegments = this._getLineSegments(\n      curveSegmentIndex,\n      transformMatrix,\n      controlPoints,\n      closed\n    );\n    let curveSegmentLength = 0;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n      minX = Math.min(minX, lineSegAABB.minX);\n      minY = Math.min(minY, lineSegAABB.minY);\n      maxX = Math.max(maxX, lineSegAABB.maxX);\n      maxY = Math.max(maxY, lineSegAABB.maxY);\n      curveSegmentLength += lineSegLength;\n    });\n\n    return {\n      controlPoints: { p0, p1, p2, p3 },\n      aabb: { minX, minY, maxX, maxY },\n      length: curveSegmentLength,\n      previousCurveSegmentsLength: 0,\n      lineSegments,\n    };\n  }\n}\n\nexport { CubicSpline as default, CubicSpline };\n","import { CubicSpline } from './CubicSpline';\nimport { CardinalSplineProps } from '../../../types';\n\nclass CardinalSpline extends CubicSpline {\n  private _scale: number;\n  private _fixedScale: boolean;\n\n  constructor(props?: CardinalSplineProps) {\n    super(props);\n    this._scale = props?.scale ?? 0.5;\n    this._fixedScale = props?.fixedScale ?? false;\n  }\n\n  public get scale() {\n    return this._scale;\n  }\n\n  public set scale(scale: number) {\n    if (this._fixedScale || this._scale === scale) {\n      return;\n    }\n\n    this._scale = scale;\n    this.invalidated = true;\n  }\n\n  public get fixedScale() {\n    return this._fixedScale;\n  }\n\n  protected getTransformMatrix(): number[] {\n    const { scale: s } = this;\n    const s2 = 2 * s;\n\n    // prettier-ignore\n    return [\n       0,      1,       0,   0,\n      -s,      0,       s,   0,\n      s2,  s - 3,  3 - s2,  -s,\n      -s,  2 - s,   s - 2,   s\n    ];\n  }\n}\n\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\n\n// TODO: LinearSpline should inherit from Spline\n\n/**\n * Linear spline matrix is the same one from Cardinal spline with scale equal\n * to 0. Then it can inherit from Spline using the matrix below or inherit from\n * CardinalSpline fixing the scale to 0\n *\n * Transformation Matrix:\n *      1,   0,\n *     -1,  -1,\n */\nclass LinearSpline extends CardinalSpline {\n  constructor() {\n    super({ scale: 0, fixedScale: true });\n  }\n}\n\nexport { LinearSpline as default, LinearSpline };\n","import { CardinalSpline } from './CardinalSpline';\n\n// Catmull-Rom spline matrix is a Cardinal spline with scale equal to 1/2. Then\n// it can inherit from CubicSpline using the matrix below or inherit from\n// CardinalSpline using a fixed scale equal to 0.5.\n//\n// Transformation Matrix:\n//      0,  2,  0,  0,\n//     -1,  0,  1,  0,\n//      2, -5,  4, -1,\n//     -1,  3, -3,  1\n\nclass CatmullRomSpline extends CardinalSpline {\n  constructor() {\n    super({ scale: 0.5, fixedScale: true });\n  }\n}\n\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\n\n// prettier-ignore\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(\n  mat4.create(),\n  mat4.fromValues(\n     1,  4,  1,  0,\n    -3,  0,  3,  0,\n     3, -6,  3,  0,\n    -1,  3, -3,  1,\n  ),\n  1 / 6\n) as number[];\n\nclass BSpline extends CubicSpline {\n  protected getTransformMatrix(): number[] {\n    return TRANSFORM_MATRIX;\n  }\n}\n\nexport { BSpline as default, BSpline };\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport {\n  math,\n  throttle,\n  roundNumber,\n  triggerAnnotationRenderForViewportIds,\n  getCalibratedScale,\n  getCalibratedAreaUnits,\n} from '../../utilities';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\n\nimport { SplineROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { ISpline } from '../../types/ISpline';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport * as viewportFilters from '../../utilities/viewportFilters';\nimport * as drawing from '../../utilities/drawing';\n\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\n\nconst DEFAULT_SPLINE_CONFIG = {\n  resolution: 20,\n  controlPointAdditionDistance: 6,\n  controlPointDeletionDistance: 6,\n  showControlPointsConnectors: false,\n  controlPointAdditionEnabled: true,\n  controlPointDeletionEnabled: true,\n};\n\nenum SplineTypesEnum {\n  Cardinal = 'CARDINAL',\n  Linear = 'LINEAR',\n  CatmullRom = 'CATMULLROM',\n  BSpline = 'BSPLINE',\n}\n\nenum SplineToolActions {\n  AddControlPoint = 'addControlPoint',\n  DeleteControlPoint = 'deleteControlPoint',\n}\n\nclass SplineROITool extends AnnotationTool {\n  static toolName;\n  static SplineTypes = SplineTypesEnum;\n  static Actions = SplineToolActions;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: SplineROIAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        spline: {\n          configuration: {\n            [SplineTypesEnum.Cardinal]: {\n              Class: CardinalSpline,\n              scale: 0.5,\n            },\n            [SplineTypesEnum.CatmullRom]: {\n              Class: CatmullRomSpline,\n            },\n            [SplineTypesEnum.Linear]: {\n              Class: LinearSpline,\n            },\n            [SplineTypesEnum.BSpline]: {\n              Class: BSpline,\n              controlPointAdditionEnabled: false,\n              controlPointDeletionEnabled: false,\n              showControlPointsConnectors: true,\n            },\n          },\n          type: SplineTypesEnum.CatmullRom,\n          drawPreviewEnabled: true,\n          lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n        },\n        actions: {\n          [SplineToolActions.AddControlPoint]: {\n            method: 'addControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n          [SplineToolActions.DeleteControlPoint]: {\n            method: 'deleteControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Ctrl,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): SplineROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const { type: splineType } = this.configuration.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = new splineConfig.Class();\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: SplineROIAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos]],\n          activeHandleIndex: null,\n        },\n        spline: {\n          type: splineConfig.type,\n          instance: spline,\n          resolution: splineConfig.resolution,\n          closed: false,\n          polyline: [],\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      lastCanvasPoint: canvasPos,\n    };\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { instance: spline } = annotation.data.spline;\n\n    return spline.isPointNearCurve(canvasCoords, proximity);\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  private _keyDownCallback = (evt: EventTypes.KeyDownEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const key = eventDetail.key ?? '';\n    const { lastControlPointDeletionKeys } = this.configuration.spline;\n    const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n\n    if (!deleteLastPoint) {\n      return;\n    }\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length === SPLINE_MIN_POINTS) {\n      this.cancel(element);\n      return;\n    } else {\n      const controlPointIndex = data.handles.points.length - 1;\n      this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { drawPreviewEnabled } = this.configuration.spline;\n\n    // Does not force a re-render if preview is not enabled\n    if (!drawPreviewEnabled) {\n      return;\n    }\n\n    const { element } = evt.detail;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    if (data.spline.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    let closeSpline = data.handles.points.length >= 2 && doubleClick;\n    let addNewPoint = true;\n\n    // Check if user clicked on the first point to close the curve\n    if (data.handles.points.length >= 3) {\n      const { instance: spline } = data.spline;\n      const closestControlPoint = spline.getClosestControlPointWithinDistance(\n        canvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      if (closestControlPoint?.index === 0) {\n        addNewPoint = false;\n        closeSpline = true;\n      }\n    }\n\n    if (addNewPoint) {\n      data.handles.points.push(worldPoint);\n    }\n\n    data.spline.closed = data.spline.closed || closeSpline;\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (data.spline.closed) {\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { element } = viewport;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const newAnnotation = this.editData?.newAnnotation;\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as SplineROIAnnotation;\n      const { annotationUID, data, highlighted } = annotation;\n      const { handles } = data;\n      const { points: controlPoints, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle(\n        'lineWidth',\n        styleSpecifier,\n        annotation\n      ) as number;\n      const lineDash = this.getStyle(\n        'lineDash',\n        styleSpecifier,\n        annotation\n      ) as string;\n      const color = this.getStyle(\n        'color',\n        styleSpecifier,\n        annotation\n      ) as string;\n\n      const canvasCoordinates = controlPoints.map((p) =>\n        worldToCanvas(p)\n      ) as Types.Point2[];\n\n      const { drawPreviewEnabled } = this.configuration.spline;\n      const splineType = annotation.data.spline.type;\n      const splineConfig = this._getSplineConfig(splineType);\n      const spline = this._updateSplineInstance(element, annotation);\n      const splinePolylineCanvas = spline.getPolylinePoints();\n      const splinePolylineWorld = [];\n\n      for (let i = 0, len = splinePolylineCanvas.length; i < len; i++) {\n        splinePolylineWorld.push(\n          viewport.canvasToWorld(splinePolylineCanvas[i])\n        );\n      }\n\n      data.spline.polyline = splinePolylineWorld;\n\n      // If cachedStats does not exist, or the areaUnit is missing (as part of\n      // import/hydration etc.), force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(annotation, element);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, element);\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n            handleRadius: '3',\n          }\n        );\n      }\n\n      if (\n        drawPreviewEnabled &&\n        spline.numControlPoints > 1 &&\n        this.editData?.lastCanvasPoint &&\n        !spline.closed\n      ) {\n        const { lastCanvasPoint } = this.editData;\n        const previewPolylinePoints = spline.getPreviewPolylinePoints(\n          lastCanvasPoint,\n          SPLINE_CLICK_CLOSE_CURVE_DIST\n        );\n\n        drawPolylineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          'previewSplineChange',\n          previewPolylinePoints,\n          {\n            color: '#9EA0CA',\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      if (splineConfig.showControlPointsConnectors) {\n        const controlPointsConnectors = [...canvasCoordinates];\n\n        // Connect the last point to the first one when the spline is closed\n        if (spline.closed) {\n          controlPointsConnectors.push(canvasCoordinates[0]);\n        }\n\n        drawPolylineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          'controlPointsConnectors',\n          controlPointsConnectors,\n          {\n            color: 'rgba(255, 255, 255, 0.5)',\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'lineSegments',\n        splinePolylineCanvas,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n\n      renderStatus = true;\n      annotation.invalidated = false;\n    }\n\n    return renderStatus;\n  };\n\n  _renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    if (!data.spline.closed) {\n      return;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = 'textBox';\n    const boundingBox = drawLinkedTextBoxSvg(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n\n  addControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const { data } = annotation;\n    const splineType = data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointAdditionDistance;\n\n    if (splineConfig.controlPointAdditionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    const { instance: spline } = data.spline;\n    const canvasPos = evt.detail.currentPoints.canvas;\n    const closestPointInfo = spline.getClosestPoint(canvasPos);\n\n    if (closestPointInfo.distance > maxDist) {\n      return;\n    }\n\n    // Add a point at the `u` position from Parameter Space\n    const { index, point: canvasPoint } = spline.addControlPointAtU(\n      closestPointInfo.uValue\n    );\n\n    data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  private _deleteControlPointByIndex(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    controlPointIndex: number\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { points: controlPoints } = annotation.data.handles;\n\n    // There is no curve with only 2 points\n    if (controlPoints.length === 3) {\n      removeAnnotation(annotation.annotationUID);\n    } else {\n      controlPoints.splice(controlPointIndex, 1);\n    }\n\n    const { renderingEngine } = enabledElement;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    annotation.invalidated = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  deleteControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointDeletionDistance;\n\n    if (splineConfig.controlPointDeletionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const { instance: spline } = annotation.data.spline;\n    const closestControlPoint = spline.getClosestControlPointWithinDistance(\n      canvasPos,\n      maxDist\n    );\n\n    if (!closestControlPoint) {\n      return;\n    }\n\n    this._deleteControlPointByIndex(\n      element,\n      annotation,\n      closestControlPoint.index\n    );\n  };\n\n  /**\n   * Get a spline config merged with the default settings.\n   * @param type - Spline type (CARDINAL, CATMULLROM, LINEAR or BSPLINE)\n   * @returns Spline configuration\n   */\n  private _getSplineConfig(type: string) {\n    const { configuration: config } = this;\n    const splineConfigs = config.spline.configuration;\n\n    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n  }\n\n  private _updateSplineScale(spline: ISpline, annotation: SplineROIAnnotation) {\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n\n    if (\n      !(spline instanceof CardinalSpline) ||\n      spline.fixedScale ||\n      splineConfig.scale === undefined ||\n      spline.scale === splineConfig.scale\n    ) {\n      return;\n    }\n\n    spline.scale = splineConfig.scale;\n    annotation.invalidated = true;\n  }\n\n  private _updateSplineInstance(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation\n  ): ISpline {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { data } = annotation;\n    const { type: splineType, instance: spline } = annotation.data.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const worldPoints = data.handles.points;\n    const canvasPoints = worldPoints.map(worldToCanvas);\n\n    spline.setControlPoints(canvasPoints);\n    spline.closed = !!data.spline?.closed;\n\n    // Update spline resolution in case it has changed\n    if (spline.resolution !== splineConfig.resolution) {\n      spline.resolution = parseInt(splineConfig.resolution);\n      annotation.invalidated = true;\n    }\n\n    // Update Cardinal spline scale in case it has changed\n    if (\n      spline instanceof CardinalSpline &&\n      !spline.fixedScale &&\n      splineConfig.scale !== undefined &&\n      spline.scale !== splineConfig.scale\n    ) {\n      spline.scale = splineConfig.scale;\n      annotation.invalidated = true;\n    }\n\n    return spline;\n  }\n\n  private _calculateCachedStats = (\n    annotation: SplineROIAnnotation,\n    element: HTMLDivElement\n  ) => {\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n    const data = annotation.data;\n\n    if (!data.spline.closed) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { cachedStats } = data;\n    const { polyline: points } = data.spline;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const scale = getCalibratedScale(image);\n      let area =\n        math.polyline.calculateAreaOfPoints(canvasCoordinates) / scale / scale;\n\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        areaUnit: getCalibratedAreaUnits(null, image),\n      };\n    }\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n\n    return cachedStats;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n\n    textLines.push(areaLine);\n  }\n\n  return textLines;\n}\n\nSplineROITool.toolName = 'SplineROI';\nexport default SplineROITool;\n","import { Types } from '@cornerstonejs/core';\nimport { interpolatePoints } from './algorithms/bspline';\n\n/**\n * Returns a list of uniform distributed values. This list contains the max amount of values which has at least a minimum distance between two consecutive values.\n * minDistributionDistance means the min distance between two consecutive distributed values.\n * Closed interval contains the min/max values.\n *\n * Formula for reference\n * For given {x ∈ R | x ≥ 0} and {minDis ∈ R | minDis ≥ 0}, ∃ D(x) where D(x) ≥ a and D(x) ≤ b  =>\n *         |\n * D(x)  = |                  (b - a)\n *         |  round( ------------------------ * x  )   + a\n *         |                (b - a + 1)\n *         |        round( -----------  )\n *         |                 minDis\n */\nfunction getContinuousUniformDistributionValues(\n  minDistributionDistance: number,\n  closedInterval: [number, number]\n): number[] {\n  const result = [];\n  const [intervalIni, intervalEnd] = closedInterval;\n\n  const intervalSize = intervalEnd - intervalIni + 1;\n  const intensity = Math.floor(intervalSize / minDistributionDistance);\n\n  let x = 0;\n  let continuosDistributionValue =\n    Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n\n  while (continuosDistributionValue <= intervalEnd) {\n    result.push(continuosDistributionValue);\n    x++;\n    continuosDistributionValue =\n      Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n  }\n\n  return result;\n}\n\n/**\n * Interpolates a segment of points from iniIndex until endIndex.\n * The process of interpolation considers the param knotsRatioPercentage as being the percentage of points from Segment that are likely to be considered.\n * By default it uses b-spline algorithm.\n * The result total of points is equal to original points.\n */\nexport default function interpolateSegmentPoints(\n  points: (Types.Point2 | Types.Point3)[],\n  iniIndex: number,\n  endIndex: number,\n  knotsRatioPercentage: number\n): (Types.Point2 | Types.Point3)[] {\n  const segmentSize = endIndex - iniIndex + 1;\n\n  const amountOfKnots =\n    Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n  const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n\n  if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n    return points;\n  }\n\n  // segment should be at least the double of desired minKnot distance. This will ensure at there will enough knots to interpolate.\n  if (segmentSize / minKnotDistance < 2) {\n    return points;\n  }\n\n  const interpolationIniIndex = Math.max(0, iniIndex);\n  const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n  const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n\n  const segmentPointsUnchangedEnd = points.slice(\n    interpolationEndIndex + 1,\n    points.length\n  );\n\n  const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n    interpolationIniIndex,\n    interpolationEndIndex,\n  ]);\n\n  const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n\n  return [\n    ...segmentPointsUnchangedBeg,\n    ...interpolatedPoints,\n    ...segmentPointsUnchangedEnd,\n  ];\n}\n","import {\n  interpolateBasis as d3InterpolateBasis,\n  quantize as d3Quantize,\n} from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nimport { Types } from '@cornerstonejs/core';\n\nfunction isPoints3D(\n  points: (Types.Point2 | Types.Point3)[]\n): points is Types.Point3[] {\n  return (points as Types.Point3[])[0]?.length === 3;\n}\n\n/**\n * Returns an array of the originalPoints length containing the interpolated data.\n * It interpolates a set of points indexed by knotsIndexes.\n * That is, it DISCARDS all points except those in knotsIndexes. Then, a new set of points is created by using a b-spline on the remaining points, in order to re-create a new set of points.\n */\nexport function interpolatePoints(\n  originalPoints: (Types.Point2 | Types.Point3)[],\n  knotsIndexes: number[]\n): (Types.Point2 | Types.Point3)[] {\n  if (\n    !knotsIndexes ||\n    knotsIndexes.length === 0 ||\n    knotsIndexes.length === originalPoints.length\n  ) {\n    return originalPoints;\n  }\n\n  const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n  const xInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][0])\n  );\n  const yInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][1])\n  );\n\n  if (isPoints3D(originalPoints)) {\n    const zInterpolator = d3InterpolateBasis(\n      knotsIndexes.map((k) => originalPoints[k][2])\n    );\n    return <Types.Point3[]>(\n      d3Zip(\n        d3Quantize(xInterpolator, n),\n        d3Quantize(yInterpolator, n),\n        d3Quantize(zInterpolator, n)\n      )\n    );\n  } else {\n    return <Types.Point2[]>(\n      d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n))\n    );\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nexport function shouldInterpolate(configuration: Record<any, any>): boolean {\n  return (\n    configuration?.interpolation?.interpolateOnAdd === true ||\n    configuration?.interpolation?.interpolateOnEdit === true\n  );\n}\n\n/**\n * Tells whether two points are equal by proximity or not as far as interpolation goes.\n */\nfunction isEqualByProximity(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) < 0.001;\n}\n\n/**\n * Tells whether two points are strictly equal or not as far as interpolation goes.\n */\nfunction isEqual(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) === 0;\n}\n\n/**\n * Finds the indexes of points list and otherPoints list that points are identical.\n */\nfunction findMatchIndexes(\n  points: Types.Point2[],\n  otherPoints: Types.Point2[]\n): [number, number] | undefined {\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < otherPoints.length; j++) {\n      if (isEqual(points[i], otherPoints[j])) {\n        return [i, j];\n      }\n    }\n  }\n}\n/**\n * Returns the following index value (on circular basis) of index param on the given direction.\n */\nfunction followingIndex(\n  index: number,\n  size: number,\n  direction: number\n): number {\n  return (index + size + direction) % size;\n}\n/**\n * Array of params to be used on circular find next index.\n * The values respresent start index, indexDelimiter, list of points\n */\ntype ListParamsType = [number, number, Types.Point2[]];\n\n/**\n * Circular finding that returns the next index for two list where the criteria is met.\n *\n * It can compare two lists out of sync considering it does a circular iteration over them.\n *\n * @example\n *\n * ```\n * const pointsA = [[0, 1], [1, 3], [1, 5], [1,2]];\n * const pointsB = [[1, 2], [1, 5], [1, 3], [0,0]];\n * let firstParam = [0, 0, pointsA]\n * let secondParam = [1, 1, pointsB]\n * const criteria = (pointA, pointB) => areSamePosition(pointA, pointB)\n * const direction = 1;\n * let result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * console.log(result);\n * // prints [1, 2]\n * // use this result and find again\n * firstParam = [result[0]+1, result[0], pointsA]\n * secondParam = [result[1]+1, result[1], pointsB]\n * result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * * // prints [3, 0]\n *\n */\nfunction circularFindNextIndexBy(\n  listParams: ListParamsType,\n  otherListParams: ListParamsType,\n  criteria: (pointA: Types.Point2, pointB: Types.Point2) => boolean,\n  direction: number\n): [number | undefined, number | undefined] {\n  const [, indexDelimiter, points] = listParams;\n  const [, otherIndexDelimiter, otherPoints] = otherListParams;\n\n  const pointsLength = points.length;\n  const otherPointsLength = otherPoints.length;\n\n  let startIndex = listParams[0];\n  let otherStartIndex = otherListParams[0];\n\n  if (\n    !points[startIndex] ||\n    !otherPoints[otherStartIndex] ||\n    !points[indexDelimiter] ||\n    !otherPoints[otherIndexDelimiter]\n  ) {\n    return [undefined, undefined];\n  }\n\n  while (\n    startIndex !== indexDelimiter &&\n    otherStartIndex !== otherIndexDelimiter\n  ) {\n    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n      return [startIndex, otherStartIndex];\n    }\n\n    startIndex = followingIndex(startIndex, pointsLength, direction);\n    otherStartIndex = followingIndex(\n      otherStartIndex,\n      otherPointsLength,\n      direction\n    );\n  }\n\n  return [undefined, undefined];\n}\n\n/**\n * Given two list it will find the first and last index of segment from points that diverges from previousPoints\n */\nfunction findChangedSegment(\n  points: Types.Point2[],\n  previousPoints: Types.Point2[]\n): [number, number] {\n  const [firstMatchIndex, previousFirstMatchIndex] =\n    findMatchIndexes(points, previousPoints) || [];\n\n  const toBeNotEqualCriteria = (pointA, pointB) =>\n    isEqualByProximity(pointA, pointB) === false;\n\n  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy(\n    [\n      followingIndex(firstMatchIndex, points.length, 1),\n      firstMatchIndex,\n      points,\n    ],\n    [\n      followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n      previousFirstMatchIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    1\n  );\n\n  const [highIndex] = circularFindNextIndexBy(\n    [followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points],\n    [\n      followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n      lowOtherDiffIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    -1\n  );\n\n  return [lowDiffIndex, highIndex];\n}\n\n/**\n * Interpolates the given list of points. In case there is a pointsOfReference the interpolation will occur only on segment disjoint of two list. I.e list of points from param points that are not on list of points from param pointsOfReference.\n */\nexport function getInterpolatedPoints(\n  configuration: Record<any, any>,\n  points: Types.Point2[],\n  pointsOfReference?: Types.Point2[]\n): Types.Point2[] {\n  const { interpolation } = configuration;\n\n  const result = points;\n\n  if (interpolation) {\n    const {\n      knotsRatioPercentageOnAdd,\n      knotsRatioPercentageOnEdit,\n      interpolateOnAdd = false,\n      interpolateOnEdit = false,\n    } = interpolation;\n\n    const knotsRatioPercentage = pointsOfReference\n      ? knotsRatioPercentageOnEdit\n      : knotsRatioPercentageOnAdd;\n    const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n\n    if (isEnabled) {\n      // partial or total interpolation\n      const [changedIniIndex, changedEndIndex] = pointsOfReference\n        ? findChangedSegment(points, pointsOfReference)\n        : [0, points.length - 1];\n\n      // do not interpolate if there is no valid segment\n      if (!points[changedIniIndex] || !points[changedEndIndex]) {\n        return points;\n      }\n\n      return <Types.Point2[]>(\n        interpolateSegmentPoints(\n          points,\n          changedIniIndex,\n          changedEndIndex,\n          knotsRatioPercentage\n        )\n      );\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Finds the length of the longest line from the midpoint of the line\n * that joins the start and end of the open contour, to the surface of the\n * open contour.\n */\nexport default function findOpenUShapedContourVectorToPeak(\n  canvasPoints: Types.Point2[],\n  viewport: Types.IStackViewport | Types.IVolumeViewport\n): Types.Point3[] {\n  // Find chord from first to last point.\n  const first = canvasPoints[0];\n  const last = canvasPoints[canvasPoints.length - 1];\n\n  const firstToLastUnitVector = vec2.create();\n\n  vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n  vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n\n  // Get the two possible normal vector to this vector\n  // Note: Use the identity that the perpendicular line must have a gradient of\n  // 1 / gradient of the line.\n\n  const normalVector1 = vec2.create();\n  const normalVector2 = vec2.create();\n\n  vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n  vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n\n  // Find the center of the chord.\n  const centerOfFirstToLast: Types.Point2 = [\n    (first[0] + last[0]) / 2,\n    (first[1] + last[1]) / 2,\n  ];\n\n  // Get furthest point.\n\n  const furthest = {\n    dist: 0,\n    index: null,\n  };\n\n  for (let i = 0; i < canvasPoints.length; i++) {\n    const canvasPoint = canvasPoints[i];\n\n    const distance = vec2.dist(canvasPoint, <vec2>centerOfFirstToLast);\n\n    if (distance > furthest.dist) {\n      furthest.dist = distance;\n      furthest.index = i;\n    }\n  }\n\n  const toFurthest: [Types.Point2, Types.Point2] = [\n    canvasPoints[furthest.index],\n    centerOfFirstToLast,\n  ];\n  const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n\n  return toFurthestWorld;\n}\n\nexport function findOpenUShapedContourVectorToPeakOnRender(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): Types.Point3[] {\n  const { viewport } = enabledElement;\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { EventTypes } from '../../../types';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\n\nconst {\n  addCanvasPointsToArray,\n  pointsAreWithinCloseContourProximity,\n  getFirstIntersectionWithPolyline,\n  getSubPixelSpacingAndXYDirections,\n} = polyline;\n\n/**\n * Activates the contour drawing event loop.\n */\nfunction activateDraw(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.drawData = {\n    canvasPoints: [canvasPos],\n    polylineIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n/**\n * Dectivates and cleans up the contour drawing event loop.\n */\nfunction deactivateDraw(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to a set of preview canvas points of the contour being created.\n * Checks if crossing of lines means early completion and editing needs to be started.\n */\nfunction mouseDragDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const {\n    annotation,\n    viewportIdsToRender,\n    xDir,\n    yDir,\n    spacing,\n    movingTextBox,\n  } = this.commonData;\n  const { polylineIndex, canvasPoints } = this.drawData;\n\n  const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (movingTextBox) {\n    this.isDrawing = false;\n\n    // Drag mode - Move the text boxes world position\n    const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n    const worldPosDelta = deltaPoints.world;\n\n    const { textBox } = annotation.data.handles;\n    const { worldPosition } = textBox;\n\n    worldPosition[0] += worldPosDelta[0];\n    worldPosition[1] += worldPosDelta[1];\n    worldPosition[2] += worldPosDelta[2];\n\n    textBox.hasMoved = true;\n  } else {\n    const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n\n    if (crossingIndex !== undefined) {\n      // If we have crossed our drawing line, create a closed contour and then\n      // start an edit.\n      this.applyCreateOnCross(evt, crossingIndex);\n    } else {\n      const numPointsAdded = addCanvasPointsToArray(\n        element,\n        canvasPoints,\n        canvasPos,\n        this.commonData\n      );\n\n      this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n    }\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the contour on mouse up. If the `allowOpenContours` configuration\n * option is `true`, checks if we should create an open or closed contour.\n * If the `allowOpenContours` configuration option is `false`, always creates a\n * closed contour.\n */\nfunction mouseUpDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating a closed contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawClosedContour(element: HTMLDivElement): boolean {\n  this.removeCrossedLinesOnCompleteDraw();\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  // Convert annotation to world coordinates\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[0],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = false;\n  const { textBox } = annotation.data.handles;\n\n  if (!textBox.hasMoved) {\n    this.triggerAnnotationCompleted(annotation);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * If lines are crossed during the draw loop, remove the points drawn over the\n * crossing.\n */\nfunction removeCrossedLinesOnCompleteDraw(): void {\n  const { canvasPoints } = this.drawData;\n  const numPoints = canvasPoints.length;\n\n  const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n  const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    canvasPointsMinusEnds,\n    endToStart[0],\n    endToStart[1],\n    false\n  );\n\n  if (lineSegment) {\n    const indexToRemoveUpTo = lineSegment[1];\n\n    this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating an open contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawOpenContour(element: HTMLDivElement): boolean {\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  const { textBox } = annotation.data.handles;\n\n  // Add the first and last points to the list of handles. These means they\n  // will render handles on mouse hover.\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  // If the annotation is an open U-shaped annotation, find the annotation vector.\n  if (annotation.data.isOpenUShapeContour) {\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n  }\n\n  if (!textBox.hasMoved) {\n    this.triggerAnnotationCompleted(annotation);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * Searches for a crossing of the contour during create. If found, returns the\n * index of the point just before the lines cross.\n */\nfunction findCrossingIndexDuringCreate(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  // Note as we super sample the added points, we need to check the whole last mouse move, not the points\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { canvasPoints } = this.drawData;\n  const pointsLessLastOne = canvasPoints.slice(0, -1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    pointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (lineSegment === undefined) {\n    return;\n  }\n\n  const crossingIndex = lineSegment[0];\n\n  return crossingIndex;\n}\n\n/**\n * On crossing of the draw line, create a closed contour, and then start an edit\n * since this occurs during a mouse drag.\n */\nfunction applyCreateOnCross(\n  evt: EventTypes.InteractionEventType,\n  crossingIndex: number\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const { canvasPoints } = this.drawData;\n  const { annotation, viewportIdsToRender } = this.commonData;\n\n  // Add points between the end point and crossing point\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[crossingIndex],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  // Remove points up to just before the crossing index\n  for (let i = 0; i < crossingIndex; i++) {\n    canvasPoints.shift();\n  }\n\n  if (this.completeDrawClosedContour(element)) {\n    // pos complete operation\n    this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n  }\n}\n\n/**\n * Completes the contour on a cancel method call during the draw loop.\n */\nfunction cancelDrawing(element: HTMLElement) {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Tell whether a drawing should be halted or not. It will be true when canvas points is less than the minimum required.\n */\nfunction shouldHaltDrawing(\n  canvasPoints: any,\n  subPixelResolution: number\n): boolean {\n  const minPoints = Math.max(\n    /**\n     * The number of points to span 3 voxels in length, this is a realistically\n     * smallest open contour one could reasonably define (2 voxels should probably be a line).\n     */\n    subPixelResolution * 3,\n    /**\n     * Minimum 3 points, there are other annotations for one point (probe)\n     * or 2 points (line), so this comes only from a mistake in practice.\n     */\n    3\n  );\n  return canvasPoints.length < minPoints;\n}\n\n/**\n * Check and halt a drawing for a given event. It returns true in case drawing is halted, otherswise false.\n */\nfunction haltDrawing(element: HTMLDivElement, canvasPoints: any): boolean {\n  const { subPixelResolution } = this.configuration;\n\n  if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n    // Remove annotation instead of completing it.\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    removeAnnotation(annotation.annotationUID);\n\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.deactivateDraw(element);\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerDrawLoop(toolInstance): void {\n  toolInstance.activateDraw = activateDraw.bind(toolInstance);\n  toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n\n  toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n  toolInstance.findCrossingIndexDuringCreate =\n    findCrossingIndexDuringCreate.bind(toolInstance);\n  toolInstance.completeDrawOpenContour =\n    completeDrawOpenContour.bind(toolInstance);\n  toolInstance.removeCrossedLinesOnCompleteDraw =\n    removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n  toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n  toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n  toolInstance.completeDrawClosedContour =\n    completeDrawClosedContour.bind(toolInstance);\n  toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n  toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\n\nexport default registerDrawLoop;\n","import { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { EventTypes } from '../../../types';\n\nconst { addCanvasPointsToArray, getFirstIntersectionWithPolyline } = polyline;\n\n/**\n * Check if the `editCanvasPoints` have crossed the `prevCanvasPoints` during\n * an edit.\n *\n * @privateRemarks The following tricks are required to make the UX smooth and\n * the editing not very picky on exactly where you click:\n * - If we don't cross after 2 points, but projecting the line backwards the\n * proximity distance means we cross, extend the line back.\n * - If we travel the full proximity in canvas points but don't cross a line, we\n * are likely drawing along the line, which is intuitive to the user. At this point\n * snap the start of the edit to the closest place on the `prevCanvasPoints`,\n * so that the edit can be executed in-line.\n */\nfunction checkForFirstCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): void {\n  const eventDetail = evt.detail;\n  const { element, currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (crossedLineSegment) {\n    this.editData.startCrossingIndex = crossedLineSegment[0];\n\n    // On the first crossing, remove the first lines prior to the crossing\n    this.removePointsUpUntilFirstCrossing(isClosedContour);\n    // prevent continue if there are not the minimum of points for this op.\n  } else if (prevCanvasPoints.length >= 2) {\n    if (\n      editCanvasPoints.length >\n      this.configuration.checkCanvasEditFallbackProximity\n    ) {\n      // At this point, likely we are drawing along the line, we are past the proximity for grabbing.\n      // Search for nearest line segment to the start of the edit.\n      // Set the crossing index to the lower index of the segment.\n\n      const firstEditCanvasPoint = editCanvasPoints[0];\n\n      const distanceIndexPairs = [];\n\n      for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n\n        distanceIndexPairs.push({ distance, index: i });\n      }\n\n      distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n      const twoClosestDistanceIndexPairs = [\n        distanceIndexPairs[0],\n        distanceIndexPairs[1],\n      ];\n\n      const lowestIndex = Math.min(\n        twoClosestDistanceIndexPairs[0].index,\n        twoClosestDistanceIndexPairs[1].index\n      );\n\n      this.editData.startCrossingIndex = lowestIndex;\n    } else {\n      // Check if extending a line back 6 (Proximity) canvas pixels would cross a line.\n\n      // Extend point back 6 canvas pixels from first point.\n      const dir = vec2.create();\n\n      vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n      vec2.normalize(dir, dir);\n\n      const proximity = 6;\n\n      const extendedPoint: Types.Point2 = [\n        editCanvasPoints[0][0] - dir[0] * proximity,\n        editCanvasPoints[0][1] - dir[1] * proximity,\n      ];\n\n      const crossedLineSegmentFromExtendedPoint =\n        getFirstIntersectionWithPolyline(\n          prevCanvasPoints,\n          extendedPoint,\n          editCanvasPoints[0],\n          isClosedContour\n        );\n\n      if (crossedLineSegmentFromExtendedPoint) {\n        // Add points.\n        const pointsToPrepend = [extendedPoint];\n\n        addCanvasPointsToArray(\n          element,\n          pointsToPrepend,\n          editCanvasPoints[0],\n          this.commonData\n        );\n\n        editCanvasPoints.unshift(...pointsToPrepend);\n\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n\n        this.editData.editIndex = editCanvasPoints.length - 1;\n        this.editData.startCrossingIndex =\n          crossedLineSegmentFromExtendedPoint[0];\n      }\n    }\n  }\n}\n\n/**\n * Removes the points from the `editCanvasPoints` up until the first crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsUpUntilFirstCrossing(isClosedContour: boolean): void {\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n  let numPointsToRemove = 0;\n\n  for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n    const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      firstLine[0],\n      firstLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    numPointsToRemove++;\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n\n  // Remove the points\n  editCanvasPoints.splice(0, numPointsToRemove);\n\n  this.editData.editIndex = editCanvasPoints.length - 1;\n}\n\n/**\n * Returns `true` if the `editCanvasPoints` crosses the `prevCanvasPoints` a\n * second time.\n */\nfunction checkForSecondCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { prevCanvasPoints } = this.editData;\n\n  // Note this method is looking for the first corssing found of\n  // *the lines given* to it. The parameters given to it are specified to search\n  // for the second crossing of the prevCanvasPoints, by checking if the last\n  // mouse drag crossed these. This class method is only called if the edit loop\n  // has already has a crossing earlier in the edit.\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (!crossedLineSegment) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Removes the points from the `editCanvasPoints` after the second crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsAfterSecondCrossing(isClosedContour: boolean): void {\n  const { prevCanvasPoints, editCanvasPoints } = this.editData;\n\n  // Remove points after the crossing\n  for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n    const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      lastLine[0],\n      lastLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    editCanvasPoints.pop();\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n}\n\n/**\n * During an edit, finds the index on the `prevCanvasPoints` that the\n * `editCanvasPoints` should snap to to create one continuous contour.\n *\n * Returns the index, but returns -1 if there is no index on the\n * `prevCanvasPoints` that can be snapped to with causing a crossing of the\n * `editCanvasPoints`.\n */\nfunction findSnapIndex(): number {\n  const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  if (\n    startCrossingIndex === undefined // Haven't crossed line yet\n  ) {\n    return;\n  }\n\n  const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n  const distanceIndexPairs = [];\n\n  for (let i = 0; i < prevCanvasPoints.length; i++) {\n    const prevCanvasPoint = prevCanvasPoints[i];\n    const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n\n    distanceIndexPairs.push({ distance, index: i });\n  }\n\n  distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n  // Search through from shortest distance and check which snap line doesn't\n  // Cross the edit line, in most cases the snap index will just be the first one.\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n\n  for (let i = 0; i < distanceIndexPairs.length; i++) {\n    const { index } = distanceIndexPairs[i];\n    const snapCanvasPosition = prevCanvasPoints[index];\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n    const crossedLineSegment = getFirstIntersectionWithPolyline(\n      editCanvasPointsLessLastOne,\n      snapCanvasPosition,\n      lastEditCanvasPoint,\n      false // The edit line is not a closed contour\n    );\n\n    if (!crossedLineSegment) {\n      return index;\n    }\n  }\n\n  // If all of the lines caused a crossing, this means we should start a new edit.\n  // Use -1 to signify this.\n  return -1;\n}\n\n/**\n * Checks if the `editCanvasPoints` cross themselves. If they do, remove the\n * region after the cross index, these removes isolated \"island\" loops that the\n * user can draw which make closed contours no longer simple polygons, or open\n * contours twisted.\n */\nfunction checkAndRemoveCrossesOnEditLine(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { editCanvasPoints } = this.editData;\n\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    editCanvasPointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (!crossedLineSegment) {\n    return;\n  }\n\n  // We have found a crossing, remove points after the crossing, cutting off\n  // the \"island\" loop drawn.\n\n  const editIndexCrossed = crossedLineSegment[0];\n  const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n\n  for (let i = 0; i < numPointsToRemove; i++) {\n    editCanvasPoints.pop();\n  }\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerEditLoopCommon(toolInstance) {\n  toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n  toolInstance.removePointsUpUntilFirstCrossing =\n    removePointsUpUntilFirstCrossing.bind(toolInstance);\n  toolInstance.checkForSecondCrossing =\n    checkForSecondCrossing.bind(toolInstance);\n  toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n  toolInstance.removePointsAfterSecondCrossing =\n    removePointsAfterSecondCrossing.bind(toolInstance);\n  toolInstance.checkAndRemoveCrossesOnEditLine =\n    checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\n\nexport default registerEditLoopCommon;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { EventTypes } from '../../../types';\nimport { polyline } from '../../../utilities/math';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport {\n  getInterpolatedPoints,\n  shouldInterpolate,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\n\nconst {\n  getSubPixelSpacingAndXYDirections,\n  addCanvasPointsToArray,\n  calculateAreaOfPoints,\n} = polyline;\n\n/**\n * Activates the closed contour edit event loop.\n */\nfunction activateClosedContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingClosed = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  hideElementCursor(element);\n}\n\n/**\n * Dectivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateClosedContourEdit(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by editing in\n * a way that requires a new edit to keep the contour a simple polygon.\n */\nfunction mouseDragClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    // If we haven't found the index of the first crossing yet,\n    // see if we can find it.\n    this.checkForFirstCrossing(evt, true);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  if (this.editData.snapIndex === -1) {\n    // No point on the prevCanvasPoints for the editCanvasPoints line to\n    // snap to. Apply edit, and start a new edit as we've gone back on ourselves.\n    this.finishEditAndStartNewEdit(evt);\n    return;\n  }\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, true)\n  ) {\n    // Crossed a second time, apply edit, and start a new edit from the crossing.\n    this.removePointsAfterSecondCrossing(true);\n    this.finishEditAndStartNewEdit(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Finish the current edit, and start a new one.\n */\nfunction finishEditAndStartNewEdit(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = false;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n    snapIndex: undefined,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we combine a few tricks to find the optimal\n * contour:\n * - As the contour is closed, our edit might stradle the boundary between the\n * last and 0th point of the contour, e.g. a small edit might go from e.g. index\n * 960 to index 4. We therefore calculate two possible contours, and find the\n * one with the biggest area, which will define the actual edit the user desired.\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithClosedContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  // Generate two possible contours that could be intepreted from the edit:\n  //\n  // pointSet1 => 0 -> low -> edit -> high - max.\n  // pointSet2 => low -> high -> edit\n  //\n  // Depending on the placement of the edit and the origin, either of these could be the intended edit.\n  // We'll choose the one with the largest area, as edits are considered to be changes to the original area with\n  // A relative change of much less than unity.\n\n  // Point Set 1\n  const pointSet1 = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  let inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  let reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the orignal contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Point Set 2\n  const pointSet2 = [];\n\n  for (let i = lowIndex; i < highIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  inPlaceDistance =\n    distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n\n  reverseDistance =\n    distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const areaPointSet1 = calculateAreaOfPoints(pointSet1);\n  const areaPointSet2 = calculateAreaOfPoints(pointSet2);\n\n  const pointsToRender: Types.Point2[] =\n    areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n\n  return pointsToRender;\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction mouseUpClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction completeClosedContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n\n    annotation.invalidated = true;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingClosed = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateClosedContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the closed\n * contour edit loop.\n */\nfunction cancelClosedContourEdit(element: HTMLDivElement) {\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Registers the closed contour edit loop to the tool instance.\n */\nfunction registerClosedContourEditLoop(toolInstance): void {\n  toolInstance.activateClosedContourEdit =\n    activateClosedContourEdit.bind(toolInstance);\n  toolInstance.deactivateClosedContourEdit =\n    deactivateClosedContourEdit.bind(toolInstance);\n  toolInstance.mouseDragClosedContourEditCallback =\n    mouseDragClosedContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpClosedContourEditCallback =\n    mouseUpClosedContourEditCallback.bind(toolInstance);\n  toolInstance.finishEditAndStartNewEdit =\n    finishEditAndStartNewEdit.bind(toolInstance);\n  toolInstance.fuseEditPointsWithClosedContour =\n    fuseEditPointsWithClosedContour.bind(toolInstance);\n  toolInstance.cancelClosedContourEdit =\n    cancelClosedContourEdit.bind(toolInstance);\n  toolInstance.completeClosedContourEdit =\n    completeClosedContourEdit.bind(toolInstance);\n}\n\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport type { EventTypes, Annotation } from '../../../types';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\n\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour edit event loop.\n */\nfunction activateOpenContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: Annotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingOpen = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  hideElementCursor(element);\n}\n\n/**\n * Deactivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateOpenContourEdit(element: HTMLDivElement) {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by dragging\n * the edit line past the end of the open contour.\n */\nfunction mouseDragOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Get pixel spacing in the direction.\n  // Check that we have moved at least one voxel in each direction.\n\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    this.checkForFirstCrossing(evt, false);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, false)\n  ) {\n    this.removePointsAfterSecondCrossing(false);\n    this.finishEditOpenOnSecondCrossing(evt);\n  } else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n    this.openContourEditOverwriteEnd(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Overwrite the end of the contour with the edit, and then switch to the\n * open contour end edit loop.\n */\nfunction openContourEditOverwriteEnd(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  // Note: Contours generate from fusedCanvasPoints will be in the direction\n  // with the last point being the current mouse position\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n  annotation.data.handles.activeHandleIndex = 1;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  // Jump to a normal line edit now.\n  this.deactivateOpenContourEdit(element);\n  this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\n\n/**\n * Checks if we are moving the `editCanvasPoints` past the end of one of the\n * open contour's `prevCanvasPoint`s.\n */\nfunction checkIfShouldOverwriteAnEnd(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPos = lastPoints.canvas;\n\n  const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    // Edit not started\n    return false;\n  }\n\n  // No snap index can be found, so contour is being edited away from line.\n  if (snapIndex === -1) {\n    return true;\n  }\n\n  if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n    // Not snapping to final index\n    return false;\n  }\n\n  // Work out the angle between the last mouse move and\n  // And the current point to the snapped point.\n  const p1 = canvasPos;\n  const p2 = lastCanvasPos;\n  const p3 = prevCanvasPoints[snapIndex];\n\n  const a = vec2.create();\n  const b = vec2.create();\n\n  vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n  vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n\n  const aDotb = vec2.dot(a, b);\n  const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n  const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n\n  const theta = Math.acos(aDotb / (magA * magB));\n\n  if (theta < Math.PI / 2) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a single contour ready for\n * end editing.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsForOpenContourEndEdit(): Types.Point2[] {\n  const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  const newCanvasPoints = [];\n\n  // Note: Generated contours will both be in the direction with the\n  // last point being the current mouse position\n\n  if (snapIndex === 0) {\n    // end -> crossingpoint -> edit\n    // Add points from the end of the previous contour, to the crossing point.\n    for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // start -> crossingpoint -> edit\n    // Add points from the orignal contour origin up to the low index.\n    for (let i = 0; i < startCrossingIndex; i++) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[0]\n  );\n\n  const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[editCanvasPoints.length - 1]\n  );\n\n  if (\n    distanceBetweenCrossingIndexAndFirstPoint <\n    distanceBetweenCrossingIndexAndLastPoint\n  ) {\n    // In order\n    for (let i = 0; i < editCanvasPoints.length; i++) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // reverse\n    for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  return newCanvasPoints;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithOpenContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return undefined;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const pointsToRender = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  const inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  const reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the original contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  return pointsToRender;\n}\n\n/**\n * On a second crossing, apply edit, and start a new edit from the crossing.\n */\nfunction finishEditOpenOnSecondCrossing(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the edit of the open contour when the mouse button is released.\n */\nfunction mouseUpOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Completes the edit of the open contour.\n */\nfunction completeOpenContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n      worldPoints[0],\n      worldPoints[worldPoints.length - 1],\n    ];\n\n    // If the annotation is an open U-shaped annotation, find the annotation vector.\n    if (annotation.data.isOpenUShapeContour) {\n      annotation.data.openUShapeContourVectorToPeak =\n        findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n    }\n\n    annotation.invalidated = true;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateOpenContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the open\n * contour edit loop.\n */\nfunction cancelOpenContourEdit(element: HTMLDivElement) {\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Registers the open contour edit loop to the tool instance.\n */\nfunction registerOpenContourEditLoop(toolInstance) {\n  toolInstance.activateOpenContourEdit =\n    activateOpenContourEdit.bind(toolInstance);\n  toolInstance.deactivateOpenContourEdit =\n    deactivateOpenContourEdit.bind(toolInstance);\n  toolInstance.mouseDragOpenContourEditCallback =\n    mouseDragOpenContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpOpenContourEditCallback =\n    mouseUpOpenContourEditCallback.bind(toolInstance);\n  toolInstance.fuseEditPointsWithOpenContour =\n    fuseEditPointsWithOpenContour.bind(toolInstance);\n  toolInstance.finishEditOpenOnSecondCrossing =\n    finishEditOpenOnSecondCrossing.bind(toolInstance);\n  toolInstance.checkIfShouldOverwriteAnEnd =\n    checkIfShouldOverwriteAnEnd.bind(toolInstance);\n  toolInstance.fuseEditPointsForOpenContourEndEdit =\n    fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n  toolInstance.openContourEditOverwriteEnd =\n    openContourEditOverwriteEnd.bind(toolInstance);\n  toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n  toolInstance.completeOpenContourEdit =\n    completeOpenContourEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  Annotation,\n  ToolHandle,\n  TextBoxHandle,\n} from '../../../types';\nimport { polyline } from '../../../utilities/math';\n\nconst { getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour end edit. This actually just sets up the state so\n * that the tool thinks we are mid draw, and then jumps into the drawing loop.\n */\nfunction activateOpenContourEndEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: Annotation,\n  viewportIdsToRender: string[],\n  handle: ToolHandle | null\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n\n  // If 0, invert point direction, if 1, keep point direction the same.\n  // This is so we can just jump as into the state as if the annotation was just being drawn.\n  if (handleIndexGrabbed === 0) {\n    canvasPoints.reverse();\n  }\n\n  let movingTextBox = false;\n  if ((handle as TextBoxHandle).worldPosition) {\n    movingTextBox = true;\n  }\n\n  this.drawData = {\n    canvasPoints: canvasPoints,\n    polylineIndex: canvasPoints.length - 1,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox,\n  };\n\n  state.isInteractingWithTool = true;\n\n  // Jump into drawing loop.\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n\n/**\n * Registers the open contour end edit loop to the tool instance.\n */\nfunction registerOpenContourEndEditLoop(toolInstance): void {\n  toolInstance.activateOpenContourEndEdit =\n    activateOpenContourEndEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEndEditLoop;\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n} from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { SVGDrawingHelper } from '../../../types';\n\nconst { pointsAreWithinCloseContourProximity } = polyline;\n\ntype PlanarFreehandROIRenderOptions = {\n  color?: string;\n  width?: number;\n  connectFirstToLast?: boolean;\n};\n\nfunction _getRenderingOptions(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): PlanarFreehandROIRenderOptions {\n  const styleSpecifier: StyleSpecifier = {\n    toolGroupId: this.toolGroupId,\n    toolName: this.getToolName(),\n    viewportId: enabledElement.viewport.id,\n    annotationUID: annotation.annotationUID,\n  };\n\n  const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n  const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n  const color = this.getStyle('color', styleSpecifier, annotation);\n\n  const isOpenContour = annotation.data.isOpenContour;\n\n  const options = {\n    color: color === undefined ? undefined : <string>color,\n    width: lineWidth === undefined ? undefined : <number>lineWidth,\n    lineDash: lineDash === undefined ? undefined : <number[]>lineDash,\n    connectLastToFirst: !isOpenContour,\n  };\n\n  return options;\n}\n\n/**\n * Renders a `PlanarFreehandROIAnnotation` that is not currently being drawn or edited.\n */\nfunction renderContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  // prevent drawing or further calculation in case viewport data is not ready yet\n  if (!enabledElement?.viewport?.getImageData()) {\n    return;\n  }\n  // Check if the contour is an open contour\n  if (annotation.data.isOpenContour) {\n    // If its an open contour, check i its a U-shaped contour\n    if (annotation.data.isOpenUShapeContour) {\n      calculateUShapeContourVectorToPeakIfNotPresent(\n        enabledElement,\n        annotation\n      );\n\n      this.renderOpenUShapedContour(\n        enabledElement,\n        svgDrawingHelper,\n        annotation\n      );\n    } else {\n      // If not a U-shaped contour, render standard open contour.\n      this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    }\n  } else {\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n  }\n}\n\n/**\n * If the open U-shaped contour does not have a peak.\n */\nfunction calculateUShapeContourVectorToPeakIfNotPresent(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  if (!annotation.data.openUShapeContourVectorToPeak) {\n    // Annotation just been set to be an open U-shaped contour.\n    // calculate its peak vector here.\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n  }\n}\n\n/**\n * Renders an closed `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderClosedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Its unfortunate that we have to do this for each annotation,\n  // Even if its unchanged. In the future we could cache the canvas points per\n  // element on the tool? That feels very weird also as we'd need to manage\n  // it/clean them up. Its a pre-optimisation for now and we can tackle it if it\n  // becomes a problem.\n  const canvasPoints = annotation.data.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderOpenContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const canvasPoints = annotation.data.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n\n  const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n\n  if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n    const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n\n    // Draw highlighted points\n    const handleGroupUID = '0';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const handlePoints = [\n      canvasPoints[0],\n      canvasPoints[canvasPoints.length - 1],\n    ];\n\n    // Don't render a hovered handle, as this will be rendered larger in\n    // the next block.\n    if (activeHandleIndex === 0) {\n      handlePoints.shift();\n    } else if (activeHandleIndex === 1) {\n      handlePoints.pop();\n    }\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      handlePoints,\n      {\n        color: options.color,\n        handleRadius: radius,\n      }\n    );\n  }\n\n  if (activeHandleIndex !== null) {\n    // Draw highlighted points\n    const handleGroupUID = '1';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const indexOfCanvasPoints =\n      activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n\n    const handlePoint = canvasPoints[indexOfCanvasPoints];\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      [handlePoint],\n      { color: options.color }\n    );\n  }\n}\n\nfunction renderOpenUShapedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const { polyline, openUShapeContourVectorToPeak } = annotation.data;\n\n  this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n  // prevent rendering u shape in case openUShapeContourVectorToPeak is not set yet\n  if (!openUShapeContourVectorToPeak) {\n    return;\n  }\n\n  const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n  const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n\n  const openUShapeContourVectorToPeakCanvas = [\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n  ];\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Join first and last points\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'first-to-last',\n    [firstCanvasPoint, lastCanvasPoint],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n\n  // Render midpoint to open contour surface line\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'midpoint-to-open-contour',\n    [\n      openUShapeContourVectorToPeakCanvas[0],\n      openUShapeContourVectorToPeakCanvas[1],\n    ],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n}\n\n/**\n * Renders a new `PlanarFreehandROIAnnotation` annotation during\n * creation/drawing.\n */\nfunction renderContourBeingDrawn(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n\n  // Override rendering whilst drawing the contour, we don't know if its open\n  // or closed yet\n  options.connectLastToFirst = false;\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    '1',\n    canvasPoints,\n    options\n  );\n\n  if (allowOpenContours) {\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n    // Check if start and end are within close proximity\n    if (\n      pointsAreWithinCloseContourProximity(\n        firstPoint,\n        lastPoint,\n        this.configuration.closeContourProximity\n      )\n    ) {\n      // Preview join last points\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        '2',\n        [lastPoint, firstPoint],\n        options\n      );\n    } else {\n      // Draw start point\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        handleGroupUID,\n        [firstPoint],\n        { color: options.color, handleRadius: 2 }\n      );\n    }\n  }\n}\n\n/**\n * Renders a closed `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderClosedContourBeingEdited(\n  enabledElement,\n  svgDrawingHelper,\n  annotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderOpenContourBeingEdited(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Registers the render methods of various contour states to the tool instance.\n */\nfunction registerRenderMethods(toolInstance) {\n  toolInstance.renderContour = renderContour.bind(toolInstance);\n  toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n  toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n  toolInstance.renderOpenUShapedContour =\n    renderOpenUShapedContour.bind(toolInstance);\n\n  toolInstance.renderContourBeingDrawn =\n    renderContourBeingDrawn.bind(toolInstance);\n\n  toolInstance.renderClosedContourBeingEdited =\n    renderClosedContourBeingEdited.bind(toolInstance);\n  toolInstance.renderOpenContourBeingEdited =\n    renderOpenContourBeingEdited.bind(toolInstance);\n  toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\n\nexport default registerRenderMethods;\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport { Events } from '../../enums';\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getIntersectionCoordinatesWithPolyline } from '../../utilities/math/polyline/getIntersectionWithPolyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The interpolation process uses b-spline algorithm and consider 4 configurations properties:\n * - interpolation.interpolateOnAdd: to tell whether it should be interpolated or not (for editing it is considered the property interpolateOnEdit) (default: false)\n * - interpolation.interpolateOnEdit: to tell whether it should be interpolated or not when editing (default: false)\n * - interpolation.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during interpolation (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - interpolation.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the interpolation might occur when:\n * - drawing is done (i.e mouse is released) and interpolation.interpolateOnAdd is true. Interpolation algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and interpolation.interpolateOnEdit is true. Interpolation algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * Interpolation does not occur when:\n * - interpolation.interpolateOnAdd is false and drawing is completed\n * - interpolation.interpolateOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of interpolation will be a smoother set of segments.\n * Changing tool configuration (see below) you can fine-tune the interpolation process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive interpolation.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more agressive interpolation.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set interpolation agressiveness while adding new annotation (ps: this does not change if interpolation is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set interpolation to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { interpolateOnAdd: false, interpolateOnEdit: true  },\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  private activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finese to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        interpolation: {\n          interpolateOnAdd: false,\n          interpolateOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        calculateStats: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: PlanarFreehandROIAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          points: [], // Handle points for open contours\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        polyline: [<Types.Point3>[...worldPos]], // Polyline coordinates\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.isOpenContour) {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const points = annotation.data.polyline;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n\n      const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (distance === true) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (annotation.data.isOpenContour) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    const distance = pointCanProjectOnLine(\n      canvasCoords,\n      pStart,\n      pEnd,\n      proximity\n    );\n\n    if (distance === true) {\n      return true;\n    }\n\n    return false;\n  };\n\n  cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: PlanarFreehandROIAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n\n    const eventDetail: AnnotationCompletedEventDetail = {\n      annotation,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    );\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  /**\n   * Draws the `PlanarFreehandROIAnnotation`s at each request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n\n    const targetId = this.getTargetId(viewport);\n\n    let annotations = <PlanarFreehandROIAnnotation[]>(\n      getAnnotations(this.getToolName(), element)\n    );\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as PlanarFreehandROIAnnotation[];\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      annotations.forEach((annotation) => {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      });\n    } else {\n      // One of the annotations will need special rendering treatment, render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      annotations.forEach((annotation) => {\n        if (annotation.annotationUID === activeAnnotationUID) {\n          if (isDrawing) {\n            this.renderContourBeingDrawn(\n              enabledElement,\n              svgDrawingHelper,\n              annotation\n            );\n          } else if (isEditingClosed) {\n            this.renderClosedContourBeingEdited(\n              enabledElement,\n              svgDrawingHelper,\n              annotation\n            );\n          } else if (isEditingOpen) {\n            this.renderOpenContourBeingEdited(\n              enabledElement,\n              svgDrawingHelper,\n              annotation\n            );\n          } else {\n            throw new Error(\n              `Unknown ${this.getToolName()} annotation rendering state`\n            );\n          }\n        } else {\n          this.renderContour(enabledElement, svgDrawingHelper, annotation);\n        }\n      });\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    annotations.forEach((annotation) => {\n      const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n      if (\n        annotation.annotationUID === activeAnnotationUID &&\n        !this.commonData?.movingTextBox\n      ) {\n        return;\n      }\n\n      if (!this.commonData?.movingTextBox) {\n        const { data } = annotation;\n        if (\n          !data.cachedStats[targetId] ||\n          data.cachedStats[targetId].areaUnit == null\n        ) {\n          data.cachedStats[targetId] = {\n            Modality: null,\n            area: null,\n            max: null,\n            mean: null,\n            stdDev: null,\n            areaUnit: null,\n          };\n\n          this._calculateCachedStats(\n            annotation,\n            viewport,\n            renderingEngine,\n            enabledElement\n          );\n        } else if (annotation.invalidated) {\n          this._throttledCalculateCachedStats(\n            annotation,\n            viewport,\n            renderingEngine,\n            enabledElement\n          );\n        }\n      }\n\n      this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n    });\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { cachedStats, polyline: points } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const scale = getCalibratedScale(image);\n      let area =\n        polyline.calculateAreaOfPoints(canvasCoordinates) / scale / scale;\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n      let iMin = worldPosIndex[0];\n      let iMax = worldPosIndex[0];\n\n      let jMin = worldPosIndex[1];\n      let jMax = worldPosIndex[1];\n\n      let kMin = worldPosIndex[2];\n      let kMax = worldPosIndex[2];\n\n      for (let j = 1; j < points.length; j++) {\n        const worldPosIndex = csUtils.transformWorldToIndex(\n          imageData,\n          points[j]\n        );\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        iMin = Math.min(iMin, worldPosIndex[0]);\n        iMax = Math.max(iMax, worldPosIndex[0]);\n\n        jMin = Math.min(jMin, worldPosIndex[1]);\n        jMax = Math.max(jMax, worldPosIndex[1]);\n\n        kMin = Math.min(kMin, worldPosIndex[2]);\n        kMax = Math.max(kMax, worldPosIndex[2]);\n      }\n\n      // Expand bounding box\n      const iDelta = 0.01 * (iMax - iMin);\n      const jDelta = 0.01 * (jMax - jMin);\n      const kDelta = 0.01 * (kMax - kMin);\n\n      iMin = Math.floor(iMin - iDelta);\n      iMax = Math.ceil(iMax + iDelta);\n      jMin = Math.floor(jMin - jDelta);\n      jMax = Math.ceil(jMax + jDelta);\n      kMin = Math.floor(kMin - kDelta);\n      kMax = Math.ceil(kMax + kDelta);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n      let curRow = 0;\n      let intersections = [];\n      let intersectionCounter = 0;\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS, pointIJK) => {\n          let result = true;\n          const point = viewport.worldToCanvas(pointLPS);\n          if (point[1] != curRow) {\n            intersectionCounter = 0;\n            curRow = point[1];\n            intersections = getIntersectionCoordinatesWithPolyline(\n              canvasCoordinates,\n              point,\n              [canvasPosEnd[0], point[1]]\n            );\n            intersections.sort(\n              (function (index) {\n                return function (a, b) {\n                  return a[index] === b[index]\n                    ? 0\n                    : a[index] < b[index]\n                    ? -1\n                    : 1;\n                };\n              })(0)\n            );\n          }\n          if (intersections.length && point[0] > intersections[0][0]) {\n            intersections.shift();\n            intersectionCounter++;\n          }\n          if (intersectionCounter % 2 === 0) {\n            result = false;\n          }\n          return result;\n        },\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        mean: stats[1]?.value,\n        max: stats[0]?.value,\n        stdDev: stats[3]?.value,\n        statsArray: stats,\n        pointsInShape: pointsInShape,\n        areaUnit: getCalibratedAreaUnits(null, image),\n        modalityUnit,\n      };\n    }\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  _renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId, renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    } else {\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const { renderingEngine, viewportId, renderingEngineId } =\n      getEnabledElement(element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    triggerEvent(eventTarget, eventType, {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    });\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the point that doesn't have the arrowhead by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport roundNumber from '../../utilities/roundNumber';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n    if (!point3) {\n      return false;\n    }\n\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n\n      cachedStats[targetId] = {\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Return the midpoint (think average) of all the provided points.\n */\nconst midPoint = (\n  ...args: (Types.Point2 | Types.Point3)[]\n): Types.Point2 | Types.Point3 => {\n  const ret =\n    args[0].length === 2 ? <Types.Point2>[0, 0] : <Types.Point3>[0, 0, 0];\n  const len = args.length;\n  for (const arg of args) {\n    ret[0] += arg[0] / len;\n    ret[1] += arg[1] / len;\n    if (ret.length === 3) {\n      ret[2] += arg[2] / len;\n    }\n  }\n  return ret;\n};\n\nconst midPoint2 = midPoint as (...args: Types.Point2[]) => Types.Point2;\n\nexport default midPoint;\n\nexport { midPoint2 };\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    isNearFirstLine?: boolean;\n    isNearSecondLine?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      25,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): CobbAngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CobbAngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n      viewport,\n      points: data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    interactionType: InteractionTypes,\n    canvasCoords: Types.Point2,\n    proximity = 6\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n      viewport,\n      points: annotation.data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * Handles the mouse down for all points that follow the very first mouse down.\n   * The very first mouse down is handled by addAnnotation.\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\n   */\n  _mouseDownCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const { annotation, handleIndex } = this.editData;\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const worldPos = currentPoints.world;\n    const { data } = annotation;\n\n    if (handleIndex === 1) {\n      // This is the mouse down for the second point of the first segment.\n      // The mouse up takes care of adding the first point of the second segment.\n      data.handles.points[1] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\n        data.handles.points[1][1] !== data.handles.points[0][0];\n      return;\n    }\n\n    if (handleIndex === 3) {\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\n      data.handles.points[3] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\n        data.handles.points[3][1] !== data.handles.points[2][0];\n\n      this.angleStartedNotYetCompleted = false;\n      return;\n    }\n\n    // This is the first mouse down of the first point of the second line segment.\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\n    this.editData.hasMoved = false;\n    hideElementCursor(element);\n\n    // Add the last segment points for the subsequent drag/mouse move.\n    data.handles.points[2] = data.handles.points[3] = worldPos;\n    this.editData.handleIndex = data.handles.points.length - 1;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n      isNearFirstLine,\n      isNearSecondLine,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (\n      handleIndex === undefined &&\n      (isNearFirstLine || isNearSecondLine)\n    ) {\n      // select tool mode - moving annotation\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      // separate the logic for moving handles to move them separately\n      if (isNearFirstLine) {\n        const firstLinePoints = [points[0], points[1]];\n        firstLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      } else if (isNearSecondLine) {\n        const secondLinePoints = [points[2], points[3]];\n        secondLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      }\n\n      annotation.invalidated = true;\n    } else {\n      // Drag handle mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length < 4) {\n      // If it is mid-draw\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.angleStartedNotYetCompleted = false;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CobbAngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n          arc1Angle: null,\n          arc2Angle: null,\n          points: {\n            world: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n            canvas: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n          },\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n\n      let lineUID = 'line1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        firstLine[0],\n        firstLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add the stats until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = 'line2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        secondLine[0],\n        secondLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = 'linkLine';\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      // Calculating the arcs\n\n      const { arc1Start, arc1End, arc2End, arc2Start } =\n        data.cachedStats[targetId].points.canvas;\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n\n      lineUID = 'arc1';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        arc1Start as Types.Point2,\n        arc1End as Types.Point2,\n        {\n          color,\n          lineWidth: '1',\n        }\n      );\n\n      lineUID = 'arc2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        arc2Start as Types.Point2,\n        arc2End as Types.Point2,\n        {\n          color,\n          lineWidth: '1',\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = 'cobbAngleText';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n\n      const arc1TextBoxUID = 'arcAngle1';\n\n      const arc1TextLine = [\n        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n      ];\n\n      const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        arc1TextBoxUID,\n        arc1TextLine,\n        arch1TextPosCanvas,\n        {\n          ...options,\n          padding: 3,\n        }\n      );\n\n      const arc2TextBoxUID = 'arcAngle2';\n\n      const arc2TextLine = [\n        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n      ];\n\n      const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        arc2TextBoxUID,\n        arc2TextLine,\n        arch2TextPosCanvas,\n        {\n          ...options,\n          padding: 3,\n        }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\n    let minDist = Number.MAX_VALUE;\n\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\n    // are the closest (Euclidean distance-wise) to each other. Thus\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\n    // is calculated.\n    // The assumption here is that the Cobb angle line segments are drawn\n    // such that the segments intersect nearest the segment endpoints\n    // that are closest AND those closest endpoints are the tails of the\n    // vectors used to calculate the angle between the vectors/line segments.\n    for (let i = 0; i < 2; i += 1) {\n      for (let j = 2; j < 4; j += 1) {\n        const dist = vec3.distance(\n          data.handles.points[i],\n          data.handles.points[j]\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          seg1[1] = data.handles.points[i];\n          seg1[0] = data.handles.points[(i + 1) % 2];\n          seg2[0] = data.handles.points[j];\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n        }\n      }\n    }\n    const { viewport } = enabledElement;\n\n    const canvasPoints = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\n\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\n      this.getArcsStartEndPoints({\n        firstLine,\n        secondLine,\n        mid1,\n        mid2,\n      });\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      cachedStats[targetId] = {\n        angle: angleBetweenLines(seg1, seg2),\n        arc1Angle,\n        arc2Angle,\n        points: {\n          canvas: {\n            arc1Start,\n            arc1End,\n            arc2End,\n            arc2Start,\n          },\n          world: {\n            arc1Start: viewport.canvasToWorld(arc1Start),\n            arc1End: viewport.canvasToWorld(arc1End),\n            arc2End: viewport.canvasToWorld(arc2End),\n            arc2Start: viewport.canvasToWorld(arc2Start),\n          },\n        },\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n    const [point1, point2, point3, point4] = points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    let isNearFirstLine = false;\n    let isNearSecondLine = false;\n\n    if (distanceToPoint <= proximity) {\n      isNearFirstLine = true;\n    } else if (distanceToPoint2 <= proximity) {\n      isNearSecondLine = true;\n    }\n    return {\n      distanceToPoint,\n      distanceToPoint2,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n  };\n\n  getArcsStartEndPoints = ({\n    firstLine,\n    secondLine,\n    mid1,\n    mid2,\n  }): {\n    arc1Start: Types.Point2;\n    arc1End: Types.Point2;\n    arc2Start: Types.Point2;\n    arc2End: Types.Point2;\n    arc1Angle: number;\n    arc2Angle: number;\n  } => {\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\n\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\n\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\n\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n\n    const linkLineLength = Math.sqrt(\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\n        (linkLine[1][1] - linkLine[0][1]) ** 2\n    );\n    const ratio = 0.1; // 10% of the line length\n\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n\n    // For arc1Start\n    const directionVectorStartArc1 = [\n      firstLine[arc1Side][0] - midFirstLine[0],\n      firstLine[arc1Side][1] - midFirstLine[1],\n    ];\n    const magnitudeStartArc1 = Math.sqrt(\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\n    );\n    const normalizedDirectionStartArc1 = [\n      directionVectorStartArc1[0] / magnitudeStartArc1,\n      directionVectorStartArc1[1] / magnitudeStartArc1,\n    ];\n    const arc1Start = [\n      midFirstLine[0] +\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n      midFirstLine[1] +\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Existing logic for arc1End\n    const directionVectorEndArc1 = [\n      midLinkLine[0] - mid1[0],\n      midLinkLine[1] - mid1[1],\n    ];\n    const magnitudeEndArc1 = Math.sqrt(\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\n    );\n    const normalizedDirectionEndArc1 = [\n      directionVectorEndArc1[0] / magnitudeEndArc1,\n      directionVectorEndArc1[1] / magnitudeEndArc1,\n    ];\n    const arc1End = [\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2Start\n    const directionVectorStartArc2 = [\n      secondLine[arc2Side][0] - midSecondLine[0],\n      secondLine[arc2Side][1] - midSecondLine[1],\n    ];\n    const magnitudeStartArc2 = Math.sqrt(\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\n    );\n    const normalizedDirectionStartArc2 = [\n      directionVectorStartArc2[0] / magnitudeStartArc2,\n      directionVectorStartArc2[1] / magnitudeStartArc2,\n    ];\n    const arc2Start = [\n      midSecondLine[0] +\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n      midSecondLine[1] +\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2End\n    const directionVectorEndArc2 = [\n      midLinkLine[0] - mid2[0],\n      midLinkLine[1] - mid2[1],\n    ];\n    const magnitudeEndArc2 = Math.sqrt(\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\n    );\n    const normalizedDirectionEndArc2 = [\n      directionVectorEndArc2[0] / magnitudeEndArc2,\n      directionVectorEndArc2[1] / magnitudeEndArc2,\n    ];\n    const arc2End = [\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    return {\n      arc1Start,\n      arc1End,\n      arc2Start,\n      arc2End,\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\n\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { AnnotationCompletedEventDetail } from '../../types/EventTypes';\n\nimport { resetElementCursor } from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { Annotation } from '../../types';\n\ntype Point2 = Types.Point2;\n\nclass KeyImageTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        getTextCallback,\n        changeTextCallback,\n        canvasPosition: [10, 10],\n        canvasSize: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.configuration.getTextCallback((text) => {\n      if (!text) {\n        removeAnnotation(annotation.annotationUID);\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n        this.isDrawing = false;\n        return;\n      }\n      annotation.data.text = text;\n\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n    });\n\n    return annotation;\n  };\n\n  public cancel() {\n    // No op - the annotation can't be in a partial state\n  }\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { canvasPosition, canvasSize } = this.configuration;\n    if (!canvasPosition?.length) {\n      return false;\n    }\n    if (\n      Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n        canvasSize / 2 &&\n      Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n        canvasSize / 2\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    annotation.highlighted = true;\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle\n  ): void {\n    // Nothing special to do here.\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this._deactivateModify(element);\n    resetElementCursor(element);\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as Annotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as Annotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const { renderingEngine, viewportId, renderingEngineId } =\n      getEnabledElement(element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    triggerEvent(eventTarget, eventType, {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    });\n  }\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const { canvasPosition, canvasSize } = this.configuration;\n      if (canvasPosition?.length) {\n        const arrowUID = '1';\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasPosition.map((it) => it + canvasSize) as Point2,\n          canvasPosition as Point2,\n          {\n            color,\n            width: 1,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nKeyImageTool.toolName = 'KeyImage';\n\nexport default KeyImageTool;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { pointInShapeCallback } from '../../../utilities';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { LabelmapToolOperationData } from '../../../types';\nimport { getStrategyData } from './utils/getStrategyData';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\n/**\n * For each point in the bounding box around the rectangle, if the point is inside\n * the rectangle, set the scalar value to the segmentIndex\n * @param toolGroupId - string\n * @param operationData - OperationData\n * @param constraintFn - can be used to perform threshold segmentation\n * @param inside - boolean\n */\n// Todo: why we have another constraintFn? in addition to the one in the operationData?\nfunction fillRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  const { points, segmentsLocked, segmentIndex, segmentationId, constraintFn } =\n    operationData;\n\n  const strategyData = getStrategyData({\n    operationData,\n    viewport: enabledElement.viewport,\n  });\n\n  if (!strategyData) {\n    console.warn('No data found for fillRectangle');\n    return;\n  }\n\n  const { segmentationImageData, segmentationScalarData } = strategyData;\n\n  let rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(segmentationImageData, world);\n  });\n\n  // math round\n  rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n    return point.map((coord) => {\n      return Math.round(coord);\n    });\n  });\n\n  const boundsIJK = getBoundingBoxAroundShape(\n    rectangleCornersIJK,\n    segmentationImageData.getDimensions()\n  );\n\n  // Since always all points inside the boundsIJK is inside the rectangle...\n  const pointInRectangle = () => true;\n\n  const callback = ({ value, index, pointIJK }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n\n    if (!constraintFn) {\n      segmentationScalarData[index] = segmentIndex;\n      return;\n    }\n\n    if (constraintFn(pointIJK)) {\n      segmentationScalarData[index] = segmentIndex;\n    }\n  };\n\n  pointInShapeCallback(\n    segmentationImageData,\n    pointInRectangle,\n    callback,\n    boundsIJK\n  );\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Fill the inside of a rectangle\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n * @param constraintFn - can be used to perform threshold segmentation\n */\nexport function fillInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Fill the area outside of a rectangle for the toolGroupId and segmentationRepresentationUID.\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n * @param constraintFn - can be used to perform threshold segmentation\n */\nexport function fillOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, false);\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { LabelmapToolOperationData } from '../../../types';\nimport { fillInsideRectangle } from './fillRectangle';\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\nfunction eraseRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillRectangle functionality.\n  const eraseOperationData = Object.assign({}, operationData, {\n    segmentIndex: 0,\n  });\n\n  fillInsideRectangle(enabledElement, eraseOperationData);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels inside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - OperationData\n */\nexport function eraseInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  eraseRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels outside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - OperationData\n */\nexport function eraseOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  eraseRectangle(enabledElement, operationData, false);\n}\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    //\n    imageIdReferenceMap: Map<string, string>;\n    volumeId: string;\n    referencedVolumeId: string;\n    //\n    annotation: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData = representationData[\n      SegmentationRepresentations.Labelmap\n    ] as LabelmapSegmentationData;\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    this.editData = {\n      annotation,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (isVolumeSegmentation(labelmapData as LabelmapSegmentationData)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n    segmentationRepresentationUID?: string;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          // ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const labelmapData = representationData[type];\n\n    if (!labelmapData) {\n      throw new Error(\n        'No labelmap data found for the active segmentation, create one before using scissors tool'\n      );\n    }\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (isVolumeSegmentation(labelmapData as LabelmapSegmentationData)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationRepresentationUID: string;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentationRepresentationUID,\n      segmentIndex,\n      segmentsLocked,\n      segmentColor,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    } as any;\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData as LabelmapSegmentationData)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { Events } from '../../enums';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngineId } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId: viewport.id,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = targetId.split('volumeId:')[1];\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const volumeId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(volumeId.split('volumeId:')[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.\n *\n * @param {function} getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param {number[]} seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param {function} [options.onFlood] An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param {function} [options.onBoundary] An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param {function} [options.equals] An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param {boolean} [options.diagonals] Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns {Object}\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals || defaultEquals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = {};\n  const bounds = {};\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  function visited(key) {\n    return visits[key] === true;\n  }\n\n  function markAsVisited(key) {\n    visits[key] = true;\n  }\n\n  function member(getArgs) {\n    const node = safely(get, [getArgs]);\n\n    return safely(equals, [node, startNode]);\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    bounds[prevArgs] = prevArgs;\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  function safely(f, args) {\n    try {\n      return f(...args);\n    } catch (error) {\n      return;\n    }\n  }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = [];\n\n    for (const key in bounds) {\n      if (bounds[key] !== undefined) {\n        array.unshift(bounds[key]);\n      }\n    }\n\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    let dimensions: Types.Point3;\n    let direction: Types.Mat3;\n    let scalarData: Types.PixelDataTypedArray;\n    let index: Types.Point3;\n\n    if (isVolumeSegmentation(labelmapData)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n\n      const segmentation = cache.getVolume(volumeId);\n      ({ dimensions, direction } = segmentation);\n      scalarData = segmentation.getScalarData();\n\n      index = transformWorldToIndex(segmentation.imageData, worldPos);\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = enabledElement.viewport.getCurrentImageId();\n      const currentSegmentationImageId =\n        imageIdReferenceMap.get(currentImageId);\n\n      if (!currentSegmentationImageId) {\n        throw new Error(\n          'No active segmentation imageId detected, create one before using scissors tool'\n        );\n      }\n\n      const segmentationImage = cache.getImage(currentSegmentationImageId);\n      scalarData = segmentationImage.getPixelData();\n      const { imageData } = viewport.getImageData();\n      dimensions = imageData.getDimensions();\n      direction = imageData.getDirection();\n      index = transformWorldToIndex(imageData, worldPos);\n    }\n\n    const fixedDimension = this.getFixedDimension(\n      viewPlaneNormal,\n      direction as number[]\n    );\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) {\n        minJ = j;\n      }\n      if (j > maxJ) {\n        maxJ = j;\n      }\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Types.PixelDataTypedArray,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\nimport { BaseTool } from './base';\nimport { getRenderingEngines } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\n\nconst OverlayMarkerType = {\n  ANNOTATED_CUBE: 1,\n  AXES: 2,\n  CUSTOM: 3,\n};\n\n/**\n * The OrientationMarker is a tool that includes an orientation marker in viewports\n * when activated\n */\nclass OrientationMarkerTool extends BaseTool {\n  static toolName;\n  static CUBE = 1;\n  static AXIS = 2;\n  static VTPFILE = 3;\n  orientationMarkers;\n  polyDataURL;\n\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\n\n  configuration_invalidated = true;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {\n        orientationWidget: {\n          enabled: true,\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n          viewportSize: 0.15,\n          minPixelSize: 100,\n          maxPixelSize: 300,\n        },\n        overlayMarkerType:\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n        overlayConfiguration: {\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n            faceProperties: {\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\n              yPlus: {\n                text: 'P',\n                faceColor: '#00ffff',\n                fontColor: 'white',\n                faceRotation: 180,\n              },\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n              zPlus: { text: 'S' },\n              zMinus: { text: 'I' },\n            },\n            defaultStyle: {\n              fontStyle: 'bold',\n              fontFamily: 'Arial',\n              fontColor: 'black',\n              fontSizeScale: (res) => res / 2,\n              faceColor: '#0000ff',\n              edgeThickness: 0.1,\n              edgeColor: 'black',\n              resolution: 400,\n            },\n          },\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n            polyDataURL:\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.orientationMarkers = {};\n    this.configuration_invalidated = true;\n  }\n\n  onSetToolEnabled = (): void => {\n    this.initViewports();\n    this.configuration_invalidated = true;\n  };\n\n  onSetToolActive = (): void => {\n    this.initViewports();\n  };\n\n  onSetToolDisabled = (): void => {\n    this.cleanUpData();\n  };\n\n  private cleanUpData() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach((viewport) => {\n      const orientationMarker = this.orientationMarkers[viewport.id];\n      if (!orientationMarker) {\n        return;\n      }\n\n      const { actor, orientationWidget } = orientationMarker;\n      orientationWidget?.setEnabled(false);\n      orientationWidget?.delete();\n      actor?.delete();\n\n      const renderWindow = viewport\n        .getRenderingEngine()\n        .offscreenMultiRenderWindow.getRenderWindow();\n      renderWindow.render();\n      viewport.getRenderingEngine().render();\n\n      delete this.orientationMarkers[viewport.id];\n    });\n  }\n\n  private initViewports() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n    viewports.forEach((viewport) => this.addAxisActorInViewport(viewport));\n  }\n\n  async addAxisActorInViewport(viewport) {\n    const viewportId = viewport.id;\n    const type = this.configuration.overlayMarkerType;\n\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\n\n    if (this.orientationMarkers[viewportId]) {\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n      // remove the previous one\n      viewport.getRenderer().removeActor(actor);\n      orientationWidget.setEnabled(false);\n    }\n\n    let actor;\n    if (type === 1) {\n      actor = this.createAnnotationCube(overlayConfiguration);\n    } else if (type === 2) {\n      actor = vtkAxesActor.newInstance();\n    } else if (type === 3) {\n      actor = await this.createCustomActor();\n    }\n\n    const renderer = viewport.getRenderer();\n    const renderWindow = viewport\n      .getRenderingEngine()\n      .offscreenMultiRenderWindow.getRenderWindow();\n\n    const {\n      enabled,\n      viewportCorner,\n      viewportSize,\n      minPixelSize,\n      maxPixelSize,\n    } = this.configuration.orientationWidget;\n\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n      actor,\n      interactor: renderWindow.getInteractor(),\n      parentRenderer: renderer,\n    });\n\n    orientationWidget.setEnabled(enabled);\n    orientationWidget.setViewportCorner(viewportCorner);\n    orientationWidget.setViewportSize(viewportSize);\n    orientationWidget.setMinPixelSize(minPixelSize);\n    orientationWidget.setMaxPixelSize(maxPixelSize);\n\n    orientationWidget.updateMarkerOrientation();\n    this.orientationMarkers[viewportId] = {\n      orientationWidget,\n      actor,\n    };\n    renderWindow.render();\n    viewport.getRenderingEngine().render();\n\n    this.configuration_invalidated = false;\n  }\n\n  private async createCustomActor() {\n    const url =\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n        .polyDataURL;\n\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\n    vtpReader.update();\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.shallowCopy(vtpReader.getOutputData());\n    polyData.getPointData().setActiveScalars('Color');\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyData);\n    mapper.setColorModeToDirectScalars();\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.rotateZ(180);\n    return actor;\n  }\n\n  private createAnnotationCube(overlayConfiguration: any) {\n    const actor = vtkAnnotatedCubeActor.newInstance();\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n    actor.setXPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.xPlus,\n    });\n    actor.setXMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.xMinus,\n    });\n    actor.setYPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.yPlus,\n    });\n    actor.setYMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.yMinus,\n    });\n    actor.setZPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.zPlus,\n    });\n    actor.setZMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.zMinus,\n    });\n    return actor;\n  }\n\n  async createAnnotatedCubeActor() {\n    const axes = vtkAnnotatedCubeActor.newInstance();\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n\n    axes.setDefaultStyle(defaultStyle);\n\n    Object.keys(faceProperties).forEach((key) => {\n      const methodName = `set${\n        key.charAt(0).toUpperCase() + key.slice(1)\n      }FaceProperty`;\n      axes[methodName](faceProperties[key]);\n    });\n\n    return axes;\n  }\n}\n\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { _cloneDeep } from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId?: string;\n    scalarData?: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer?: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata?: any;\n    dimensions?: Types.Point3;\n    spacing?: Types.Point3;\n    origin?: Types.Point3;\n    direction?: Float32Array;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = _cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD_INSIDE_CIRCLE.threshold =\n      threshold;\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration\n    .THRESHOLD_INSIDE_CIRCLE.threshold;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.VolumeScalarData,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.VolumeScalarData,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst loop = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, isDynamicCinePlaying);\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, isDynamicCinePlaying);\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement): void {\n  _stopClip(element, true);\n}\n\nfunction _stopClip(element: HTMLDivElement, stopDynamicCine: boolean): void {\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    return;\n  }\n  const { viewport } = enabledElement;\n  const cineToolData = getToolState(viewport.element);\n\n  if (cineToolData) {\n    _stopClipWithData(cineToolData);\n  }\n\n  if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","import { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROITool } from '../../tools';\nimport { ToolGroupManager } from '../../store';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nfunction shouldPreventInterpolation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  if (!annotation?.data?.polyline || knotsRatioPercentage <= 0) {\n    return true;\n  }\n\n  if (!enabledElement.viewport) {\n    return true;\n  }\n\n  const { renderingEngineId, viewportId, FrameOfReferenceUID } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (annotation.metadata.FrameOfReferenceUID !== FrameOfReferenceUID) {\n    return true;\n  }\n\n  if (!toolGroup) {\n    return true;\n  }\n\n  const toolInstance = toolGroup.getToolInstance(annotation.metadata.toolName);\n\n  // strategy to prevent non PlanarFreehandTool\n  if (!(toolInstance instanceof PlanarFreehandROITool)) {\n    return true;\n  }\n\n  return (\n    toolInstance.isDrawing ||\n    toolInstance.isEditingOpen ||\n    toolInstance.isEditingClosed\n  );\n}\n/**\n * Interpolates a given annotation from a given enabledElement.\n * It mutates annotation param.\n * The param knotsRatioPercentage defines the percentage of points to be considered as knots on the interpolation process.\n * Interpolation will be skipped in case: annotation is not present in enabledElement (or there is no toolGroup associated with it), related tool is being modified.\n */\nexport default function interpolateAnnotation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  // prevent running while there is any tool annotation being modified\n  if (\n    shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage)\n  ) {\n    return false;\n  }\n\n  const { viewport } = enabledElement;\n  // use only 2 dimensions on interpolation (what visually matters),\n  // otherwise a 3d interpolation might have a totally different output as it consider one more dimension.\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const interpolatedCanvasPoints = <Types.Point2[]>(\n    interpolateSegmentPoints(\n      canvasPoints,\n      0,\n      canvasPoints.length,\n      knotsRatioPercentage\n    )\n  );\n\n  if (interpolatedCanvasPoints === canvasPoints) {\n    return false;\n  }\n\n  annotation.data.polyline = interpolatedCanvasPoints.map(\n    viewport.canvasToWorld\n  );\n\n  return true;\n}\n","import interpolateAnnotation from './interpolateAnnotation';\n\nexport default {\n  interpolateAnnotation,\n};\n\nexport { interpolateAnnotation };\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state: Record<number, any> = {};\n\nfunction addToolState(element: HTMLDivElement, data): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): any {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getToolState } from './state';\n\nexport const requestType = Enums.RequestType.Prefetch;\nexport const priority = 0;\n\nexport function range(lowEnd, highEnd) {\n  // Javascript version of Python's range function\n  // http://stackoverflow.com/questions/3895478/does-javascript-have-a-method-like-range-to-generate-an-array-based-on-suppl\n  lowEnd = Math.round(lowEnd) || 0;\n  highEnd = Math.round(highEnd) || 0;\n\n  const arr = [];\n  let c = highEnd - lowEnd + 1;\n\n  if (c <= 0) {\n    return arr;\n  }\n\n  while (c--) {\n    arr[c] = highEnd--;\n  }\n\n  return arr;\n}\n\nexport function nearestIndex(arr, x) {\n  // Return index of nearest values in array\n  // http://stackoverflow.com/questions/25854212/return-index-of-nearest-values-in-an-array\n  let low = 0;\n  let high = arr.length - 1;\n\n  arr.forEach((v, idx) => {\n    if (v < x) {\n      low = Math.max(idx, low);\n    } else if (v > x) {\n      high = Math.min(idx, high);\n    }\n  });\n\n  return { low, high };\n}\n\nexport function getStackData(element) {\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    // Can be not valid if the data is changed part way through prefetch\n    return null;\n  }\n\n  const { viewport } = enabledElement;\n\n  if (!(viewport instanceof StackViewport)) {\n    throw new Error(\n      'stackPrefetch: element must be a StackViewport, VolumeViewport stackPrefetch not yet implemented'\n    );\n  }\n\n  return {\n    currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n    imageIds: viewport.getImageIds(),\n  };\n}\n\nexport function getPromiseRemovedHandler(element) {\n  return function (e) {\n    const eventData = e.detail;\n\n    // When an imagePromise has been pushed out of the cache, re-add its index\n    // It to the indicesToRequest list so that it will be retrieved later if the\n    // CurrentImageIdIndex is changed to an image nearby\n    let stackData;\n\n    try {\n      // It will throw an exception in some cases (eg: thumbnails)\n      stackData = getStackData(element);\n    } catch (error) {\n      return;\n    }\n\n    if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n      return;\n    }\n\n    const stack = stackData;\n    const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n\n    // Make sure the image that was removed is actually in this stack\n    // Before adding it to the indicesToRequest array\n    if (imageIdIndex < 0) {\n      return;\n    }\n\n    const stackPrefetchData = getToolState(element);\n\n    if (\n      !stackPrefetchData ||\n      !stackPrefetchData.data ||\n      !stackPrefetchData.data.length\n    ) {\n      return;\n    }\n\n    stackPrefetchData.indicesToRequest.push(imageIdIndex);\n  };\n}\n\nexport const clearFromImageIds = (stack) => {\n  const imageIdSet = new Set<string>(stack.imageIds);\n  return (requestDetails) =>\n    requestDetails.type !== requestType ||\n    !imageIdSet.has(requestDetails.additionalDetails.imageId);\n};\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport roundNumber from '../roundNumber';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points array of number, each point defined by three consecutive numbers\n * @param idx index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx) {\n  if (idx < points.length / 3) {\n    return [points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]];\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst isRangeValid = (range: ColorbarImageRange) => {\n  return range && range.upper > range.lower;\n};\n\nexport { isRangeValid as default, isRangeValid };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst isColorbarSizeValid = (size: ColorbarSize) => {\n  return !!size && size.width > 0 && size.height > 0;\n};\n\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst areColorbarRangesEqual = (\n  a: ColorbarImageRange,\n  b: ColorbarImageRange\n) => {\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\n\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\n  return !!a && !!b && a.width === b.width && a.height === b.height;\n};\n\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\nimport type { ColorbarSize } from './types/ColorbarSize';\nimport {\n  isRangeValid,\n  areColorbarRangesEqual,\n  isColorbarSizeValid,\n  areColorbarSizesEqual,\n} from './common';\n\nconst { clamp } = utilities;\n\n/**\n * Canvas referenced by the color bar where the colormap is rendered. It may\n * show the full image range or only the VOI range.\n */\nclass ColorbarCanvas {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _colormap: IColorMapPreset;\n  private _showFullImageRange: boolean;\n\n  constructor(props: ColorbarCanvasProps) {\n    ColorbarCanvas.validateProps(props);\n\n    const {\n      colormap,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    this._colormap = colormap;\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._showFullImageRange = showFullPixelValueRange;\n    this._canvas = this._createRootElement(size);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get colormap(): IColorMapPreset {\n    return this._colormap;\n  }\n\n  public set colormap(colormap: IColorMapPreset) {\n    this._colormap = colormap;\n    this.render();\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  public get imageRange(): ColorbarImageRange {\n    return { ...this._imageRange };\n  }\n\n  public set imageRange(imageRange: ColorbarImageRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  public get voiRange(): ColorbarVOIRange {\n    return { ...this._voiRange };\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  public get showFullImageRange(): boolean {\n    return this._showFullImageRange;\n  }\n\n  public set showFullImageRange(showFullImageRange: boolean) {\n    if (showFullImageRange === this._showFullImageRange) {\n      return;\n    }\n\n    this._showFullImageRange = showFullImageRange;\n    this.render();\n  }\n\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  public dispose() {\n    const { _canvas: canvas } = this;\n    const { parentElement } = canvas;\n\n    parentElement?.removeChild(canvas);\n  }\n\n  private static validateProps(props: ColorbarCanvasProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createRootElement(size: ColorbarSize) {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      pointerEvents: 'none',\n      boxSizing: 'border-box',\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  private render(): void {\n    if (!this._canvas.isConnected) {\n      return;\n    }\n\n    const { _colormap: colormap } = this;\n    const { RGBPoints: rgbPoints } = colormap;\n    const colorsCount = rgbPoints.length / 4;\n\n    // Returns a color point from rgbPoints. Each point has position, red,\n    // green and blue components which means each point has an offset equal\n    // to `4 * index`\n    const getColorPoint = (index) => {\n      const offset = 4 * index;\n\n      // It can get out of bounds when `voiRange.upper` is smaller than\n      // `imageRange.upper`. It's also checking if is smaller than zero\n      // for safety only because that should never happens.\n      if (index < 0 || index >= colorsCount) {\n        return;\n      }\n\n      return {\n        index,\n        position: rgbPoints[offset],\n        color: [\n          rgbPoints[offset + 1],\n          rgbPoints[offset + 2],\n          rgbPoints[offset + 3],\n        ],\n      };\n    };\n\n    const { width, height } = this._canvas;\n    const canvasContext = this._canvas.getContext('2d');\n    const isHorizontal = width > height;\n    const maxValue = isHorizontal ? width : height;\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\n      voiRange.lower,\n      voiRange.upper\n    );\n\n    let previousColorPoint = undefined;\n    let currentColorPoint = getColorPoint(0);\n\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n    let rawPixelValue = range.lower;\n\n    for (let i = 0; i < maxValue; i++) {\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\n\n      // Find the color in a linear way (O(n) complexity).\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\n      // than or equal to next color position.\n      if (currentColorPoint) {\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\n          if (tVoiRange <= currentColorPoint.position) {\n            break;\n          }\n\n          previousColorPoint = currentColorPoint;\n          currentColorPoint = getColorPoint(i + 1);\n        }\n      }\n\n      let normColor;\n\n      // For:\n      //   - firstColorPoint = getColorPoint(0)\n      //   - secondColorPoint = getColorPoint(1)\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\n      // Then\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\n      //   - previousColorPoint and currentColorPoint will be defined when\n      //     currentColorPoint.position is between secondColorPoint.position and\n      //     lastColorPoint.position.\n      if (!previousColorPoint) {\n        normColor = [...currentColorPoint.color];\n      } else if (!currentColorPoint) {\n        normColor = [...previousColorPoint.color];\n      } else {\n        const tColorRange =\n          (tVoiRange - previousColorPoint.position) /\n          (currentColorPoint.position - previousColorPoint.position);\n\n        normColor = interpolateVec3(\n          previousColorPoint.color,\n          currentColorPoint.color,\n          tColorRange\n        );\n      }\n\n      const color = normColor.map((color) =>\n        clamp(Math.round(color * 255), 0, 255)\n      );\n\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\n      if (isHorizontal) {\n        canvasContext.fillRect(i, 0, 1, height);\n      } else {\n        canvasContext.fillRect(0, height - i - 1, width, 1);\n      }\n\n      rawPixelValue += incRawPixelValue;\n    }\n  }\n}\n\nexport { ColorbarCanvas as default, ColorbarCanvas };\n","/**\n * Linear interpolation between two vec3.\n * Can be used, for example, to interpolate between two RGB colors.\n * @param a - First vec3\n * @param b - Second vec3\n * @param t - Time \"t\".\n *   - Vector A is returned for values smaller than or equel to 0.\n *   - Vector B is returned for values greater than or equal to 1.\n *   - An interpolation between vectors A and B is returned otherwise.\n * @returns\n */\nconst interpolateVec3 = (a, b, t) => {\n  return [\n    a[0] * (1 - t) + b[0] * t,\n    a[1] * (1 - t) + b[1] * t,\n    a[2] * (1 - t) + b[2] * t,\n  ];\n};\n\nexport { interpolateVec3 as default, interpolateVec3 };\n","import type {\n  ColorbarImageRange,\n  ColorbarVOIRange,\n  ColorbarSize,\n  ColorbarTicksProps,\n} from './types';\nimport {\n  isColorbarSizeValid,\n  isRangeValid,\n  areColorbarRangesEqual,\n  areColorbarSizesEqual,\n} from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\n\nconst DEFAULTS = {\n  FONT: '10px Arial',\n  COLOR: 'white',\n  TICK_SIZE: 5,\n  TICK_WIDTH: 1,\n  TICK_LABEL_MARGIN: 3,\n  MAX_NUM_TICKS: 8,\n\n  // Must start with 1 and end with 10\n  TICKS_STEPS: [1, 2.5, 5, 10],\n};\n\nclass ColorbarTicks {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _color: string;\n  private _tickSize: number;\n  private _tickWidth: number;\n  private _labelMargin: number;\n  private _maxNumTicks: number;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n  private _showFullPixelValueRange: boolean;\n  private _font: string;\n\n  constructor(props: ColorbarTicksProps) {\n    ColorbarTicks.validateProps(props);\n\n    const {\n      top = 0,\n      left = 0,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      ticks: ticksProps,\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n    this._rangeTextPosition =\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n    this._showFullPixelValueRange = showFullPixelValueRange;\n    this._canvas = this._createCanvasElement(size, top, left);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  /**\n   * Canvas top position (pixels)\n   */\n  public get top(): number {\n    return Number.parseInt(this._canvas.style.top);\n  }\n\n  /**\n   * Change the canvas top position (pixels)\n   */\n  public set top(top: number) {\n    const { _canvas: canvas } = this;\n    const currentTop = this.top;\n\n    if (top === currentTop) {\n      return;\n    }\n\n    canvas.style.top = `${top}px`;\n    this.render();\n  }\n\n  /**\n   * Canvas left position (pixels)\n   */\n  public get left(): number {\n    return Number.parseInt(this._canvas.style.left);\n  }\n\n  /**\n   * Change the canvas left position (pixels)\n   */\n  public set left(left: number) {\n    const { _canvas: canvas } = this;\n    const currentLeft = this.left;\n\n    if (left === currentLeft) {\n      return;\n    }\n\n    canvas.style.left = `${left}px`;\n    this.render();\n  }\n\n  /**\n   * Image range\n   */\n  public get imageRange() {\n    return { ...this._imageRange };\n  }\n\n  /**\n   * Set the image range that should goes from minPixelValue to maxPixelValue\n   */\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  /**\n   * VOI range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public get voiRange() {\n    return { ...this._voiRange };\n  }\n\n  /**\n   * Set the VOI Range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  /**\n   * Tick size (pixels)\n   */\n  public get tickSize(): number {\n    return this._tickSize;\n  }\n\n  /**\n   * Set the tick size\n   */\n  public set tickSize(tickSize: number) {\n    if (tickSize === this._tickSize) {\n      return;\n    }\n\n    this._tickSize = tickSize;\n    this.render();\n  }\n\n  /**\n   * Tick width (pixels)\n   */\n  public get tickWidth(): number {\n    return this._tickWidth;\n  }\n\n  /**\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\n   */\n  public set tickWidth(tickWidth: number) {\n    if (tickWidth === this._tickWidth) {\n      return;\n    }\n\n    this._tickWidth = tickWidth;\n    this.render();\n  }\n\n  /**\n   * Color used for ticks and labels.\n   */\n  public get color(): string {\n    return this._color;\n  }\n\n  /**\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\n   * and `fillStyle` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n   */\n  public set color(color: string) {\n    if (color === this._color) {\n      return;\n    }\n\n    this._color = color;\n    this.render();\n  }\n\n  /**\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\n   * to `voiRange.upper`\n   */\n  public get showFullPixelValueRange(): boolean {\n    return this._showFullPixelValueRange;\n  }\n\n  /**\n   * Change which range should be used when rendering the ticks. Set it to `true`\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\n   * `voiRange.lower` to `voiRange.upper`.\n   */\n  public set showFullPixelValueRange(showFullRange: boolean) {\n    if (showFullRange === this._showFullPixelValueRange) {\n      return;\n    }\n\n    this._showFullPixelValueRange = showFullRange;\n    this.render();\n  }\n\n  /**\n   * Ticks visibility\n   */\n  public get visible() {\n    return this._canvas.style.display === 'block';\n  }\n\n  /**\n   * Show/Hide the ticks\n   */\n  public set visible(visible) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    this._canvas.style.display = visible ? 'block' : 'none';\n\n    if (visible) {\n      this.render();\n    }\n  }\n\n  /**\n   * Append the canvas to its parent element\n   * @param container - HTML element where the canvas should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  private static validateProps(props: ColorbarTicksProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createCanvasElement(\n    size: ColorbarSize,\n    top: number,\n    left: number\n  ): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      display: 'none',\n      position: 'absolute',\n      boxSizing: 'border-box',\n      top: `${top}px`,\n      left: `${left}px`,\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  /**\n   * Calculate how many ticks can be displayed on the screen based on the\n   * pre-defined steps (`TICKS_STEPS`) as follow:\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\n   *   the number of desired steps (`maxNumTicks`).\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\n   *   called `roughtStepNormalized`.\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\n   *   the `roughtStepNormalized` value (`normalizedStep`).\n   *   4. Multiply the `normalizedStep` to move it to the real range.\n   *\n   * @param range - Range with \"lower\" and \"upper\" values\n   */\n  private _getTicks(range) {\n    const { lower, upper } = range;\n    const rangeValue = upper - lower;\n\n    // First approximation based on the max number of ticks\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\n\n    // Normalize rough step to find the normalized one that fits best\n    const stepPower = Math.pow(\n      10,\n      -Math.floor(Math.log10(Math.abs(roughStep)))\n    );\n\n    // Get a number between 1 and 10\n    const roughtStepNormalized = roughStep * stepPower;\n\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\n      (n) => n >= roughtStepNormalized\n    );\n\n    // Move `normalizedStep` to the real range\n    const step = normalizedStep / stepPower;\n\n    // Determine the scale limits based on the chosen step.\n    const scaleMax = Math.ceil(upper / step) * step;\n    const scaleMin = Math.floor(lower / step) * step;\n\n    // Find a possible tick values for the `step` computed\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n    const ticks = [];\n\n    for (let i = 0; i < ticksCount; i++) {\n      ticks.push(scaleMin + i * step);\n    }\n\n    return { scaleMin, scaleMax, step, ticks };\n  }\n\n  private _getLeftTickInfo({ position, labelMeasure }) {\n    const { width } = this._canvas;\n    const labelX =\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\n    const labelPoint = [labelX, position];\n    const tickPoints = {\n      start: [width - this._tickSize, position],\n      end: [width, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getRightTickInfo({ position }) {\n    const labelPoint = [this._tickSize + this._labelMargin, position];\n    const tickPoints = {\n      start: [0, position],\n      end: [this._tickSize, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getTopTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private _getBottomTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private render() {\n    const { _canvas: canvas } = this;\n\n    if (!canvas.isConnected || !this.visible) {\n      return;\n    }\n\n    const { width, height } = canvas;\n    const isHorizontal = width >= height;\n    const maxCanvasPixelValue = isHorizontal ? width : height;\n    const canvasContext = canvas.getContext('2d');\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullPixelValueRange\n      ? this._imageRange\n      : { ...voiRange };\n    const rangeWidth = range.upper - range.lower;\n    const { ticks } = this._getTicks(range);\n\n    canvasContext.clearRect(0, 0, width, height);\n    canvasContext.font = this._font;\n    canvasContext.textBaseline = 'middle';\n    canvasContext.fillStyle = this._color;\n    canvasContext.strokeStyle = this._color;\n    canvasContext.lineWidth = this.tickWidth;\n\n    ticks.forEach((tick) => {\n      let position = Math.round(\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\n      );\n\n      // Zero at the bottom and max at the top on vertical colorbars\n      if (!isHorizontal) {\n        position = height - position;\n      }\n\n      if (position < 0 || position > maxCanvasPixelValue) {\n        return;\n      }\n\n      const label = tick.toString();\n      const labelMeasure = canvasContext.measureText(label);\n      let tickInfo;\n\n      if (isHorizontal) {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n        }\n      } else {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getRightTickInfo({ position });\n        }\n      }\n\n      const { labelPoint, tickPoints } = tickInfo;\n      const { start: tickStart, end: tickEnd } = tickPoints;\n\n      canvasContext.beginPath();\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n      canvasContext.stroke();\n\n      return position;\n    });\n  }\n}\n\nexport { ColorbarTicks as default, ColorbarTicks };\n","import type { WidgetProps, WidgetSize } from './types';\n\n/**\n * Base class for any widget that can be added to cornerstone. Currently it is\n * responsible only for holding the `rootElement`, contains a method that allows\n * adding it to the DOM and it also listens to container's size changes when the\n * widget is already added to the DOM. `dispose` must be called to destroy the\n * widget because it removes the widget from the DOM and stop listening to\n * container changes.\n *\n * You can apply some styles to widgets using the widget id or the `widget` class.\n *\n * Example:\n *   type ColorPickerProps = WidgetProps & {\n *     selectedColor: string;\n *   }\n *\n *   class ColorPicker extends Widget {\n *     constructor(props: ColorPickerProps) {\n *       super(props);\n *       // [code]\n *     }\n *\n *     public show() {\n *       console.log('Show color picker');\n *     }\n *\n *     protected containerResized() {\n *       console.log('New container size: ', this.containerSize);\n *     }\n *   }\n *\n *   const colorPicker = new ColorPicker({\n *     container: document.body,\n *     selectedColor: '#000';\n *   });\n *\n *   // another way to add the color picker to the DOM\n *   colorPicker.appendTo(document.body)\n *\n *   // Show color picker\n *   colorPicker.show();\n */\nabstract class Widget {\n  private _id: string;\n  private _rootElement: HTMLElement;\n  private _containerSize: WidgetSize;\n  private _containerResizeObserver: ResizeObserver;\n\n  constructor({ id, container }: WidgetProps) {\n    this._id = id;\n    this._containerSize = { width: 0, height: 0 };\n    this._rootElement = this.createRootElement(id);\n    this._containerResizeObserver = new ResizeObserver(\n      this._containerResizeCallback\n    );\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  /**\n   * Widget id\n   */\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Widget's root element\n   */\n  public get rootElement(): HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Append the widget to a parent element\n   * @param container - HTML element where the widget should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement: currentContainer } = rootElement;\n\n    if (!container || container === currentContainer) {\n      return;\n    }\n\n    if (currentContainer) {\n      resizeObserver.unobserve(currentContainer);\n    }\n\n    container.appendChild(rootElement);\n    resizeObserver.observe(container);\n  }\n\n  /**\n   * Removes the widget from the DOM and stop listening to DOM events\n   */\n  public destroy() {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement } = rootElement;\n\n    parentElement?.removeChild(rootElement);\n    resizeObserver.disconnect();\n  }\n\n  protected get containerSize(): WidgetSize {\n    // Returns a copy to prevent any external change\n    return { ...this._containerSize };\n  }\n\n  /**\n   * Creates the root element which is a div by default\n   * @param id - Root element id\n   * @returns A new HTML element where all other elements should be added to\n   */\n  protected createRootElement(id: string): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    rootElement.id = id;\n    rootElement.classList.add('widget');\n\n    Object.assign(rootElement.style, {\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  /**\n   * Method called every time widget's container is resize giving the\n   * opportunity to children classes to act when that happens.\n   */\n  protected onContainerResize() {\n    // no-op\n  }\n\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\n    let width;\n    let height;\n\n    const { contentRect, contentBoxSize } = entries[0];\n\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\n    // but it is left over from an earlier implementation of the Resize Observer API\n    // and may be deprecated in future versions.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\n    if (contentRect) {\n      width = contentRect.width;\n      height = contentRect.height;\n    } else if (contentBoxSize?.length) {\n      width = contentBoxSize[0].inlineSize;\n      height = contentBoxSize[0].blockSize;\n    }\n\n    this._containerSize = { width, height };\n    this.onContainerResize();\n  };\n}\n\nexport { Widget as default, Widget };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import { ColorbarRangeTextPosition } from '../enums';\n\nfunction isRangeTextPositionValid(\n  colorbarWidth: number,\n  colorbarHeight: number,\n  rangeTextPosition: ColorbarRangeTextPosition\n) {\n  const isHorizontal = colorbarWidth >= colorbarHeight;\n  const validRangeTextPositions = isHorizontal\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n\n  return validRangeTextPositions.includes(rangeTextPosition);\n}\n\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n    this.showAndAutoHideTicks();\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\n\nconst DEFAULT_MULTIPLIER = 4;\n\nfunction getVOIMultipliers(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  volumeId?: string,\n  options?: {\n    fixedPTWindowWidth?: boolean;\n  }\n): [number, number] {\n  const modality = csUtils.getViewportModality(viewport, volumeId);\n\n  if (modality === 'PT') {\n    const { clientWidth, clientHeight } = viewport.element;\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\n    const { fixedPTWindowWidth = true } = options ?? {};\n\n    // Set the \"X\" multiplier equal to zero in order to do not allow\n    // any change to the window width (0 * cursorDeltaX = 0)\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n\n    return isPreScaled\n      ? [xMultiplier, ptMultiplier]\n      : [xMultiplier, DEFAULT_MULTIPLIER];\n  }\n\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\n\nexport { getVOIMultipliers as default, getVOIMultipliers };\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { state, ToolGroupManager } from '../../store';\nimport ToolModes from '../../enums/ToolModes';\n\nconst { Active } = ToolModes;\n\n/**\n * @function customCallbackHandler This is used as a generic event handler for tool events\n * on viewports. It:\n *\n * - Finds an \"active\" tool with:\n *    - A matching `handlerType`\n *    - A matching `customFunction` on its tool instance\n *\n * Then calls that custom function with raised event.\n *\n * @param handlerType - 'Mouse' | 'Touch' | 'MouseWheel'\n * @param customFunction - Function name that's expected to live on implementing\n *   (and event handling) active tool ex. 'doubleClickCallback'\n * @param evt\n */\nexport default function customCallbackHandler(\n  handlerType: string,\n  customFunction: string,\n  evt\n) {\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return false;\n  }\n\n  // TODO: Filter tools by interaction type?\n  /**\n   * Iterate tool group tools until we find a tool that is:\n   * - active\n   * - has the custom callback function\n   *\n   */\n  let activeTool;\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n    // TODO: Should be getter\n    const toolInstance = toolGroup.getToolInstance(toolName);\n\n    if (\n      // TODO: Should be enum?\n      tool.mode === Active &&\n      // TODO: Should be implements interface?\n      // Weird that we need concrete instance. Other options to filter / get callback?\n      typeof toolInstance[customFunction] === 'function'\n    ) {\n      activeTool = toolGroup.getToolInstance(toolName);\n      break;\n    }\n  }\n\n  if (!activeTool) {\n    return;\n  }\n\n  activeTool[customFunction](evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse click events. Uses `customCallbackHandler` to fire\n * the `mouseClickCallback` function on active tools.\n */\nconst mouseClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'mouseClickCallback'\n);\n\nexport default mouseClick;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * @function mouseDoubleClick - Event handler for mouse double click events. Uses `customCallbackHandler` to fire\n * the `doubleClickCallback` function on active tools.\n */\nconst mouseDoubleClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'doubleClickCallback'\n);\n\nexport default mouseDoubleClick;\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationsPair,\n  ToolsWithMoveableHandles,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools, returning only tools with moveable handles at the mouse location that are not locked\n *\n * @param element - The element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction (e.g. 'mouse' or 'touch')\n * @returns The filtered array.\n */\nexport default function filterToolsWithMoveableHandles(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolsWithMoveableHandles[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n  const toolsWithMoveableHandles = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const handle = tool.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        proximity\n      );\n\n      if (handle) {\n        toolsWithMoveableHandles.push({\n          tool,\n          annotation,\n          handle,\n        });\n        break;\n      }\n    }\n  });\n\n  return toolsWithMoveableHandles;\n}\n","import { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport { ToolAnnotationsPair } from '../types/InternalToolTypes';\nimport type AnnotationTool from '../tools/base/AnnotationTool';\nimport BaseTool from '../tools/base/BaseTool';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\n/**\n * Filters an array of tools, returning only tools which have annotation.\n *\n * @param element - The cornerstone3D enabled element.\n * @param tools - The array of tools to check.\n *\n * @returns The array of tools with their found annotations.\n */\nexport default function filterToolsWithAnnotationsForElement(\n  element: HTMLDivElement,\n  tools: AnnotationTool[]\n): ToolAnnotationsPair[] {\n  const result = [];\n  for (let i = 0; i < tools.length; i++) {\n    const tool = tools[i];\n\n    if (!tool) {\n      console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n      continue;\n    }\n\n    let annotations = getAnnotations(\n      (tool.constructor as typeof BaseTool).toolName,\n      element\n    );\n\n    if (!annotations?.length) {\n      continue;\n    }\n\n    if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n      // If the tool has a annotations filter (e.g. with in-plane-annotations-only filtering), use it.\n      annotations = tool.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n    }\n\n    if (annotations.length > 0) {\n      result.push({ tool, annotations });\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationPair,\n  ToolAnnotationsPair,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools with annotations, returning the first annotation\n * for each tool that is moveable and at the mouse location. It results in\n * one annotation per tool.\n *\n *\n * @param element - The HTML element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction that is taking place.\n * @returns The filtered array containing ToolAndAnnotation\n */\nexport default function filterMoveableAnnotationTools(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolAnnotationPair[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n\n  // TODO - This could get pretty expensive pretty quickly. We don't want to fetch the camera\n  // And do world to canvas on each coord.\n\n  // We want to produce a matrix from canvas to world for the viewport and just do a matrix operation on each handle.\n  // This could still be expensive for ROIs, but we probably shouldn't have \"handles\" for them anyway.\n\n  const moveableAnnotationTools = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const near = tool.isPointNearTool(\n        element,\n        annotation,\n        canvasCoords,\n        proximity,\n        interactionType\n      );\n\n      if (near) {\n        moveableAnnotationTools.push({\n          tool,\n          annotation,\n        });\n        break;\n      }\n    }\n  });\n\n  return moveableAnnotationTools;\n}\n","import { KeyboardBindings as kb } from '../../enums';\n\n/**\n * Gets the mouse modifier key from a mouse event.\n * Supports Shift, Ctrl, Alt, in singly and in combinations of 2\n * Supports Meta singly.\n */\nconst getMouseModifierKey = (evt) => {\n  // The logic is a hard coded key mapping\n  if (evt.shiftKey) {\n    if (evt.ctrlKey) {\n      return kb.ShiftCtrl;\n    }\n    if (evt.altKey) {\n      return kb.ShiftAlt;\n    }\n    if (evt.metaKey) {\n      return kb.ShiftMeta;\n    }\n    return kb.Shift;\n  }\n  if (evt.ctrlKey) {\n    if (evt.altKey) {\n      return kb.CtrlAlt;\n    }\n    if (evt.metaKey) {\n      return kb.CtrlMeta;\n    }\n    return kb.Ctrl;\n  }\n  if (evt.altKey) {\n    return (evt.metaKey && kb.AltMeta) || kb.Alt;\n  }\n  if (evt.metaKey) {\n    return kb.Meta;\n  }\n  return undefined;\n};\n\nexport default getMouseModifierKey;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our MouseEvent's `buttons`. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The event dispatcher mouse event.\n *\n * @returns tool\n */\nexport default function getActiveToolForMouseEvent(\n  evt: EventTypes.NormalizedMouseEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForMouseEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const mouseEvent = evt.detail.event;\n\n  // If any keyboard modifier key is also pressed - get the mouse version\n  // first since it handles combinations, while the key event handles non-modifier\n  // keys.\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some((binding) => {\n        return (\n          binding.mouseButton ===\n            (mouseEvent ? mouseEvent.buttons : defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n        );\n      });\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  modesFilter: ModesFilter,\n  evtButton?: any\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button - we match those with\n    // any modifier keys too since they can be passively interacted with\n    const correctBinding =\n      evtButton != null && // not null or undefined\n      tool.bindings.length &&\n      tool.bindings.some((binding) => binding.mouseButton === evtButton);\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      // Should not filter by event's button\n      // or should, and the tool binding includes the event's button\n      (!evtButton || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\n// Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getToolsWithActionsForMouseEvent from '../shared/getToolsWithActionsForMouseEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * Look for active or passive annotations with an action that could handle the\n * event based on the bindings and invoke the first one found.\n *\n * @param evt - The normalized mouseDown event.\n * @returns True if an action has executed or false otherwise\n */\nexport default function mouseDownAnnotationAction(\n  evt: EventTypes.MouseDownEventType\n): boolean {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { canvas: canvasCoords } = eventDetail.currentPoints;\n\n  if (!enabledElement) {\n    return false;\n  }\n\n  // Find all tools that might respond to this mouse down\n  const toolsWithActions = getToolsWithActionsForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const tools = Array.from(toolsWithActions.keys());\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    tools\n  );\n\n  // Only moveable annotations (unlocked, visible and close to the canvas coordinates) may trigger actions\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = moveableAnnotationTools[0];\n    const action = toolsWithActions.get(tool);\n    const method =\n      typeof action.method === 'string' ? tool[action.method] : action.method;\n\n    method.call(tool, evt, annotation);\n\n    return true;\n  }\n\n  return false;\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { ToolAction, EventTypes } from '../../types';\n\nimport { keyEventListener } from '../../eventListeners';\nimport getMouseModifier from './getMouseModifier';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the mouse event and a list of tool modes, find all tool instances\n * with actions that were added to the tool group associated with the viewport\n * that triggered the event.\n *\n * @param evt - mouseDown event triggered by a cornerstone viewport\n * @param toolModes - List of tool modes used to filter the tools registered\n *                    in the viewport's tool group\n */\nexport default function getToolsWithActionsForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  toolModes: ToolModes[]\n): Map<any, ToolAction> {\n  const toolsWithActions = new Map();\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return toolsWithActions;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n  const mouseEvent = evt.detail.event;\n  const mouseButton = mouseEvent?.buttons ?? defaultMousePrimary;\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.getToolInstance(toolName);\n    const actionsConfig = tool.configuration?.actions ?? {};\n    const actions = Object.values(actionsConfig);\n\n    if (!actions?.length || !toolModes.includes(tool.mode)) {\n      continue;\n    }\n\n    const action = actions.find(\n      (action: any) =>\n        action.bindings.length &&\n        action.bindings.some(\n          (binding) =>\n            binding.mouseButton === mouseButton &&\n            binding.modifierKey === modifierKey\n        )\n    );\n\n    if (action) {\n      toolsWithActions.set(tool, action);\n    }\n  }\n\n  return toolsWithActions;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport mouseDownAnnotationAction from './mouseDownAnnotationAction';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * When the mouse is depressed we check which entities can process these events in the following manner:\n *\n * - First we get the `activeTool` for the mouse button pressed.\n * - If the `activeTool` has a `preMouseDownCallback`, this is called. If the callback returns `true`,\n *   the event does not propagate further.\n * - Next we get all tools which are active or passive (`activeAndPassiveTools`), as annotation. for these tools could\n *   possibly catch and handle these events. We then filter the `activeAndPassiveTools` using `filterToolsWithAnnotationsForElement`, which filters tools with annotations\n *   for this frame of reference. Optionally a tool can employ a further filtering (via a\n *   `filterInteractableAnnotationsForElement` callback) for tools interactable within the current camera view\n *   (e.g. tools that only render when viewed from a certain direction).\n * - Next we check if any handles are interactable for each tool (`filterToolsWithMoveableHandles`). If interactable\n *   handles are found, the first tool/handle found consumes the event and the event does not propagate further.\n * - Next we check any tools are interactable (e.g. moving an entire length annotation rather than one of its handles:\n *   `filterMoveableAnnotationTools`). If interactable tools are found, the first tool found consumes the event and the\n *   event does not propagate further.\n * - If the `activeTool` has `postMouseDownCallback`, this is called.  If the callback returns `true`,\n *   the event does not propagate further.\n * - Finally, look for annotations actions that could handle the event such as showing a dropdown to allow the user\n *   change the magnifying glass zoom factor.\n *\n * If the event is not consumed the event will bubble to the `mouseDownActivate` handler.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDown(evt: EventTypes.MouseDownEventType) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  // Check for preMouseDownCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.preMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  // Find all tools that might respond to this mouse down\n  const isPrimaryClick = evt.detail.event.buttons === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(\n    evt,\n    [Active],\n    evt.detail.event.buttons\n  );\n  const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n    ? getToolsWithModesForMouseEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n  ];\n\n  // Actions need to run before tool/handle selected callbacks otherwise actions\n  // like the one from SplineTool to remove/add control points would not work.\n  const actionExecuted = mouseDownAnnotationAction(evt);\n\n  if (actionExecuted) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this mouse down\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // Preserve existing selections when shift key is pressed\n  const isMultiSelect = !!evt.detail.event.shiftKey;\n\n  // If there are annotation tools whose handle is near the mouse, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the mouse, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Mouse', canvasCoords);\n\n    return;\n  }\n\n  // Run the postMouseDownCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.postMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that mouseDownActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { EventTypes } from '../../types';\n\n/**\n * If the `mouseDown` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * mouse button pressed.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDownActivate(\n  evt: EventTypes.MouseDownActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store';\nimport { MouseDragEventType } from '../../types/EventTypes';\n\n/**\n * mouseDrag - Event handler for mouse drag events. Fires the `mouseDragCallback`\n * function on active tools.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDrag(evt: MouseDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  const noFoundToolOrDoesNotHaveMouseDragCallback =\n    !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n    return;\n  }\n\n  activeTool.mouseDragCallback(evt);\n}\n","// // State\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\n\n// // Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport { MouseMoveEventType } from '../../types/EventTypes';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * mouseMove - On mouse move when not dragging, fire tools `mouseMoveCallback`s.\n * This is mostly used to update the [un]hover state\n * of a tool.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseMove(evt: MouseMoveEventType) {\n  // Tool interactions when mouse moved are handled inside each tool.\n  // This function is mostly used to update the [un]hover state\n  if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n    return;\n  }\n\n  const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Annotation tool specific\n  const toolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    activeAndPassiveTools\n  );\n\n  const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n    const doesNotHaveAnnotations = !toolsWithAnnotations.some(\n      (toolAndAnnotation) =>\n        toolAndAnnotation.tool.getToolName() === tool.getToolName()\n    );\n\n    return doesNotHaveAnnotations;\n  });\n\n  let annotationsNeedToBeRedrawn = false;\n\n  for (const { tool, annotations } of toolsWithAnnotations) {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      annotationsNeedToBeRedrawn =\n        tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n    }\n  }\n\n  // Run mouse move handlers for non-annotation tools\n  toolsWithoutAnnotations.forEach((tool) => {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      tool.mouseMoveCallback(evt);\n    }\n  });\n\n  // Annotation activation status changed, redraw the annotations\n  if (annotationsNeedToBeRedrawn === true) {\n    triggerAnnotationRender(element);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse up events. Uses `customCallbackHandler` to fire\n * the `mouseUpCallback` function on active tools.\n */\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\n\nexport default mouseUp;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * Event handler for mouse wheel events. Uses `customCallbackHandler` to fire\n * the `mouseWheelCallback` function on active tools.\n */\nconst mouseWheel = customCallbackHandler.bind(\n  null,\n  'MouseWheel',\n  'mouseWheelCallback'\n);\n\nexport default mouseWheel;\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes, MouseBindings } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our Keyboard pressed keys. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The normalized keyboard event.\n *\n * @returns tool\n */\nexport default function getActiveToolForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  // Get the current mouse button clicked\n  const mouseButton = getMouseButton();\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey = keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some(\n        (binding) =>\n          binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyDown(evt: KeyDownEventType): void {\n  // get the active tool given the key and mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyUp(evt: KeyDownEventType): void {\n  // get the active tool for the primary mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  // Reset the modifier key\n  resetModifierKey();\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\nimport { keyEventListener } from '../../eventListeners';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our TouchEvent's `buttons`. It's possible there will be no match\n * (no active tool for that touch button combination).\n *\n * @param evt - The event dispatcher touch event.\n *\n * @returns tool\n */\nexport default function getActiveToolForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForTouchEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const touchEvent = evt.detail.event;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  const numTouchPoints = Object.keys(touchEvent.touches).length;\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey =\n    getMouseModifier(touchEvent) || keyEventListener.getModifierKey();\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      toolOptions.bindings.length &&\n      /**\n       * TODO: setActiveTool treats MouseBindings.Primary in a special way\n       * which is analgous to numTouchPoints === 1 as the primary interaction\n       * for touch based applications. The ToolGroup set active and get active\n       * logic should be updated to account for numTouchPoints === 1\n       */\n      toolOptions.bindings.some(\n        (binding) =>\n          (binding.numTouchPoints === numTouchPoints ||\n            (numTouchPoints === 1 &&\n              binding.mouseButton === defaultMousePrimary)) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized touch event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized touchStart event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType,\n  modesFilter: ModesFilter,\n  numTouchPoints?: number\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      numTouchPoints != null &&\n      tool.bindings.length &&\n      tool.bindings.some(\n        (binding) => binding.numTouchPoints === numTouchPoints\n      );\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      (!numTouchPoints || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * touchStart - Event handler for touchStart events. Uses `customCallbackHandler` to fire\n * the `touchStartCallback` function on active tools.\n */\nexport default function touchStart(evt: EventTypes.TouchStartEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  // Check for preTouchStartCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.preTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(\n    evt,\n    [Active],\n    Object.keys(evt.detail.event.touches).length\n  );\n  const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n    ? getToolsWithModesForTouchEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n    activeTool,\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this touch start\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  const isMultiSelect = false;\n\n  // If there are annotation tools whose handle is near the touch, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the touch, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Touch');\n\n    return;\n  }\n\n  // Run the postTouchStartCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.postTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that touchStartActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport { EventTypes } from '../../types';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\n\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\n\n/**\n * If the `touchStart` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * touch button pressed.\n *\n * @param evt - The normalized touchStart event.\n */\nexport default function touchStartActivate(\n  evt: EventTypes.TouchStartActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'touch');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store';\nimport { TouchDragEventType } from '../../types/EventTypes';\n\n/**\n * touchDrag - Event handler for touchDrag events. Uses `customCallbackHandler` to fire\n * the `touchDragCallback` function on active tools.\n */\nexport default function touchDrag(evt: TouchDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  const noFoundToolOrDoesNotHaveTouchDragCallback =\n    !activeTool || typeof activeTool.touchDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n    return;\n  }\n\n  activeTool.touchDragCallback(evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchEnd - Event handler for touchEnd events. Uses `customCallbackHandler` to fire\n * the `touchEndCallback` function on active tools.\n */\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\n\nexport default touchEnd;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchTap - Event handler for touch tap events. Uses `customCallbackHandler` to fire\n * the `touchTapCallback` function on active tools.\n */\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\n\nexport default touchTap;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchPress - Event handler for touch press events. Uses `customCallbackHandler` to fire\n * the `touchPressCallback` function on active tools.\n */\nconst touchPress = customCallbackHandler.bind(\n  null,\n  'Touch',\n  'touchPressCallback'\n);\n\nexport default touchPress;\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n  imageChangeEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): IToolGroup | undefined {\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\nimport imageChangeEventListener from '../eventListeners/segmentation/imageChangeEventListener';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n\n  // labelmap\n  imageChangeEventListener.disable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _auxiliaryEventNames: string[];\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  private _options: any;\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler,\n    options?: any\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n    this._options = options || {};\n    this._auxiliaryEventNames = this._options.auxiliaryEventNames || [];\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const viewport =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    if (!viewport) {\n      console.warn(\n        `Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`\n      );\n      return;\n    }\n\n    const element = viewport.element;\n\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n\n    if (this._auxiliaryEventNames.length) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        element.addEventListener(eventName, this._onEvent.bind(this));\n      });\n    }\n\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n\n    //@ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n\n    if (this._auxiliaryEventNames) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        //@ts-ignore\n        element.removeEventListener(eventName, this._eventHandler);\n      });\n    }\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    const promises = [];\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n        const result = this._eventHandler(\n          this,\n          sourceViewport,\n          targetViewport,\n          sourceEvent,\n          this._options\n        );\n\n        // if the result is a promise, then add it to the list of promises\n        // to wait for before setting _ignoreFiredEvents to false\n        if (result instanceof Promise) {\n          promises.push(result);\n        }\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      if (promises.length) {\n        Promise.allSettled(promises).then(() => {\n          this._ignoreFiredEvents = false;\n        });\n      } else {\n        this._ignoreFiredEvents = false;\n      }\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(\n        vUid.renderingEngineId\n      ).getViewport(vUid.viewportId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const { element } = renderingEngine;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @param options - Options for the synchronizer.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler,\n  options?: any\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler,\n    options\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","import { MouseBindings, ToolModes } from '../../enums';\nimport cloneDeep from 'lodash.clonedeep';\nimport get from 'lodash.get';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  /**\n   * Options used for restoring a tool\n   */\n  restoreToolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(\n        toolName,\n        options || this.restoreToolOptions[toolName]\n      );\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   */\n  public setToolPassive(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const defaultMousePrimary = this.getDefaultMousePrimary();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        binding.mouseButton !== defaultMousePrimary || binding.modifierKey\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(\n        this._toolInstances[toolName].configuration,\n        configuration\n      );\n    }\n\n    this._toolInstances[toolName].configuration = _configuration;\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   *\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration =\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\n      this._toolInstances[toolName].configuration;\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const defaultMousePrimary = this.getDefaultMousePrimary();\n\n    return toolOptions?.bindings?.some(\n      (binding) =>\n        binding.mouseButton === defaultMousePrimary &&\n        binding.modifierKey === undefined\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import {\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationRemovedEventDetail } from '../../types/EventTypes';\nimport { AnnotationGroupSelector } from '../../types';\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (!annotation.annotationUID) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  manager.addAnnotation(annotation, groupKey);\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  } else {\n    // if no element is provided, render all viewports that have the\n    // same frame of reference.\n    // Todo: we should do something else here for other types of annotation managers.\n    triggerAnnotationAddedForFOR(annotation);\n  }\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  manager.removeAnnotation(annotationUID);\n\n  // trigger annotation removed\n  const eventType = Events.ANNOTATION_REMOVED;\n\n  const eventDetail: AnnotationRemovedEventDetail = {\n    annotation,\n    annotationManagerUID: manager.uid,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  manager.removeAllAnnotations();\n}\n\nexport {\n  getAnnotations,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n};\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport { AnnotationAddedEventDetail } from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  if (!viewportsToRender.length) {\n    return;\n  }\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    const eventDetail: AnnotationAddedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR };\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationSelectionListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n  annotationModifiedListener,\n} from './eventListeners';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import {\n  BaseVolumeViewport,\n  getRenderingEngine,\n  StackViewport,\n  Types,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param voiModifiedEvent - The VOI_MODIFIED event.\n * @param options - Options for the synchronizer.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  voiModifiedEvent: Types.EventTypes.VoiModifiedEvent,\n  options?: any\n): void {\n  const eventDetail = voiModifiedEvent.detail;\n  const { volumeId, range, invertStateChanged, invert } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const tProperties:\n    | Types.VolumeViewportProperties\n    | Types.StackViewportProperties = {\n    voiRange: range,\n  };\n\n  if (options?.syncInvertState && invertStateChanged) {\n    tProperties.invert = invert;\n  }\n\n  if (tViewport instanceof BaseVolumeViewport) {\n    tViewport.setProperties(tProperties, volumeId);\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties(tProperties);\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\ntype VOISynchronizerOptions = {\n  syncInvertState: boolean;\n};\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @param options - The options for the synchronizer. By default the voi\n * synchronizer will also sync the invert state of the volume, but this can be\n * disabled by setting `syncInvertState` to false.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string,\n  options = { syncInvertState: true } as VOISynchronizerOptions\n): Synchronizer {\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback,\n    options\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","import { vec3, mat4 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n\nconst getSpatialRegistration = (targetId, sourceId) =>\n  utilities.spatialRegistrationMetadataProvider.get(\n    'spatialRegistrationModule',\n    targetId,\n    sourceId\n  );\n\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack.\n *\n * This synchronizer does a setup (which can already be predefined as required)\n * to register the target and soruce viewports.  The registration will default\n * to the identity registration if the same FOR is present in both viewports,\n * unless the option `useInitialPosition` is set in the target viewport.\n *\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\n * the registrationMetadataProvider to override the data here. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function imageSliceSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  if (options?.disabled) {\n    return;\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  // if the frame of reference is different we need to use the registrationMetadataProvider\n  // and add that to the imagePositionPatient of the source viewport to get the\n  // imagePositionPatient of the target viewport's closest image in its stack\n  let registrationMatrixMat4 = getSpatialRegistration(\n    targetViewport.viewportId,\n    sourceViewport.viewportId\n  );\n\n  if (!registrationMatrixMat4) {\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    if (\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\n      options?.useInitialPosition !== false\n    ) {\n      registrationMatrixMat4 = mat4.identity(mat4.create());\n    } else {\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n      registrationMatrixMat4 = getSpatialRegistration(\n        targetViewport.viewportId,\n        sourceViewport.viewportId\n      );\n    }\n    if (!registrationMatrixMat4) {\n      return;\n    }\n  }\n\n  // apply the registration matrix to the source viewport's imagePositionPatient\n  // to get the target viewport's imagePositionPatient\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n    vec3.create(),\n    sourceImagePositionPatient,\n    registrationMatrixMat4\n  );\n\n  // find the closest image in the target viewport's stack to the\n  // targetImagePositionPatientWithRegistrationMatrix\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\n    targetImagePositionPatientWithRegistrationMatrix,\n    targetImageIds\n  );\n\n  let imageIndexToSet = closestImageIdIndex2.index;\n  if (tViewport instanceof VolumeViewport) {\n    // since in case of volume viewport our stack is reversed, we should\n    // reverse the index as well\n    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n  }\n\n  if (\n    closestImageIdIndex2.index !== -1 &&\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n  ) {\n    await jumpToSlice(tViewport.element, {\n      imageIndex: imageIndexToSet,\n    });\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  // todo: handle multiframe images\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport | Types.IVolumeViewport,\n  viewport2: Types.IStackViewport | Types.IVolumeViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `ImageSliceSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createImageSliceSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    imageSliceSyncCallback,\n    {\n      auxiliaryEventNames: [VOLUME_NEW_IMAGE],\n    }\n  );\n\n  return stackImageSynchronizer;\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\n\n// for backward compatibility\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\n\nexport {\n  createCameraPositionSynchronizer,\n  createVOISynchronizer,\n  createZoomPanSynchronizer,\n  createImageSliceSynchronizer,\n  createStackImageSynchronizer,\n};\n","import { vec3, vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRedactionRect as drawRedactionRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { EventTypes, SVGDrawingHelper } from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nclass VideoRedactionTool extends AnnotationTool {\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportUIDsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  _configuration: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(toolConfiguration = {}) {\n    super(toolConfiguration, {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: { shadow: true, preventHandleOutsideImage: false },\n    });\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): VideoRedactionAnnotation => {\n    const eventData = evt.detail;\n    const { currentPoints, element } = eventData;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      metadata: {\n        // We probably just want a different type of data here, hacking this\n        // together for now.\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\n        viewUp: <Types.Point3>[0, 1, 0],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        active: true,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    return annotation;\n  };\n\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  };\n\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n  };\n\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { data } = annotation;\n\n    data.active = true;\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt,\n    annotation,\n    handle,\n    interactionType = 'mouse'\n  ) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { data } = annotation;\n\n    data.active = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if (handle.worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  _mouseUpCallback = (evt) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  _mouseDragCallback = (evt) => {\n    this.isDrawing = true;\n\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventData;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      data.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventData;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      data.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  cancel(element) {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportUIDsToRender } = this.editData;\n\n    const { data } = annotation;\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    this.editData = null;\n    return annotation.metadata.annotationUID;\n  }\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n      const toolMetadata = annotation.metadata;\n\n      const data = annotation.data;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        // !isToolDataLocked(toolData) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRedactionRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color: 'black',\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n    let imageVolume, viewport;\n    if (targetUID.startsWith('stackTarget')) {\n      const coloneIndex = targetUID.indexOf(':');\n      const viewportUID = targetUID.substring(coloneIndex + 1);\n      const viewport = renderingEngine.getViewport(viewportUID);\n      imageVolume = viewport.getImageData();\n    } else {\n      imageVolume = cache.getVolume(targetUID);\n    }\n\n    return { imageVolume, viewport };\n  }\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param {object} data - The toolData tool-specific data.\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetUIDs = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetUIDs.length; i++) {\n      const targetUID = targetUIDs[i];\n\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\n        targetUID,\n        renderingEngine\n      );\n\n      const {\n        dimensions,\n        scalarData,\n        vtkImageData: imageData,\n        metadata,\n      } = imageVolume;\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\n\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = worldWidth * worldHeight;\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    data.invalidated = false;\n\n    // Dispatching measurement modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail = {\n      annotation,\n      viewportUID,\n      renderingEngineUID,\n      sceneUID: sceneUID,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  _getTargetStackUID(viewport) {\n    return `stackTarget:${viewport.uid}`;\n  }\n\n  _getTargetVolumeUID = (scene) => {\n    if (this.configuration.volumeUID) {\n      return this.configuration.volumeUID;\n    }\n\n    const volumeActors = scene.getVolumeActors();\n\n    if (!volumeActors && !volumeActors.length) {\n      // No stack to scroll through\n      return;\n    }\n\n    return volumeActors[0].uid;\n  };\n}\n\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n"],"names":["MouseBindings","KeyboardBindings","ToolModes","AnnotationStyleStates","Events","SegmentationRepresentations","Swipe","globalLockedAnnotationsSet","Set","setAnnotationLocked","annotation","locked","arguments","length","undefined","detail","makeEventDetail","lockedAnnotationsSet","has","add","added","push","lock","unlock","publish","unlockAllAnnotations","forEach","clearLockedAnnotationsSet","getAnnotationsLocked","Array","from","isAnnotationLocked","getAnnotationsLockedCount","size","checkAndDefineIsLockedProperty","isLocked","descriptor","Object","getOwnPropertyDescriptor","configurable","set","setIsLocked","get","getIsLocked","isExtensible","shouldDefineIsLockedProperty","defineProperty","enumerable","freeze","removed","delete","item","triggerEvent","eventTarget","ANNOTATION_LOCK_CHANGE","this","selectedAnnotationUIDs","setAnnotationSelected","annotationUID","preserveSelected","clearSelectionSet","selectAnnotation","deselectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","toolName","filter","getAnnotation","metadata","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","value","ANNOTATION_SELECTION_CHANGE","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","checkAndDefineIsVisibleProperty","isVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","hidden","ANNOTATION_VISIBILITY_CHANGE","FrameOfReferenceSpecificAnnotationManager","constructor","uid","getGroupKey","annotationGroupSelector","element","enabledElement","getEnabledElement","Error","FrameOfReferenceUID","_imageVolumeModifiedHandler","evt","eventDetail","frameOfReferenceSpecificAnnotations","annotations","keys","invalidated","getFramesOfReference","getAnnotations","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","addAnnotation","removeAnnotation","groupAnnotations","toolAnnotations","index","findIndex","splice","removeAnnotations","saveAnnotations","cloneDeep","restoreAnnotations","state","getNumberOfAllAnnotations","count","removeAllAnnotations","utilities","addEventListener","Enums","IMAGE_VOLUME_MODIFIED","defaultFrameOfReferenceSpecificAnnotationManager","svgNodeCache","defaultState","isInteractingWithTool","isMultiPartToolActive","tools","toolGroups","synchronizers","enabledElements","handleRadius","resetCornerstoneToolsState","_cloneDeep","addTool","ToolClass","toolAlreadyAdded","name","toolClass","removeTool","getMouseEventPoints","elementToUse","currentTarget","viewport","clientPoint","clientX","clientY","_clientToPoint","pagePoint","pageX","pageY","_pageToPoint","canvasPoint","rect","getBoundingClientRect","left","window","pageXOffset","top","pageYOffset","_pagePointsToCanvasPoints","page","client","canvas","world","canvasToWorld","viewportId","renderingEngineId","startPoints","event","eventName","MOUSE_DOUBLE_CLICK","camera","lastPoints","currentPoints","deltaPoints","stopImmediatePropagation","preventDefault","MOUSE_MOVE","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_CLICK","MOUSE_UP","MOUSE_DRAG","DOUBLE_CLICK_DRAG_TOLERANCE","mouseButton","isClickEvent","clickDelay","preventClickTimeout","doubleClickState","doubleClickTimeout","mouseDownEvent","mouseUpEvent","ignoreDoubleClick","_onMouseDrag","_updateMouseEventsLastPoints","_getDeltaPoints","_isDragPastDoubleClickTolerance","_doStateMouseDownAndUp","_copyPoints","_onMouseUp","clearTimeout","_cleanUp","_onMouseMove","document","removeEventListener","mouseMoveListener","delta","Math","abs","_preventClickHandler","_clearDoubleClickTimeoutAndEvents","_doMouseDown","JSON","parse","stringify","points","_subtractPoints2D","point0","point1","mouseDoubleClickIgnoreListener","buttons","setTimeout","disable","mouseDoubleClickListener","mouseDownListener","capture","enable","pointerType","mouse","touch","lastInteractionType","lastInteractionTime","handleTap","type","e","now","Date","stopPropagation","handleTapMouse","bind","handleTapTouch","attachEvents","eventList","interactionType","tapHandler","passive","removeEvents","mouseEvents","touchEvents","getTouchEventPoints","touches","changedTouches","map","i","identifier","radiusX","radiusY","force","rotationAngle","getDeltaPoints","curr","getMeanPoints","last","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","reduce","prev","getMeanTouchPoints","pairedDistance","j","sqrt","pow","Settings","getRuntimeSettings","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_PRESS","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_SWIPE","zeroIPoint","zeroIDistance","startPointsList","lastPointsList","isTouchStart","startTime","pressTimeout","pressDelay","pressMaxDistance","accumulatedDistance","swipeDistanceThreshold","swiped","swipeToleranceMs","defaultTapState","taps","tapTimeout","tapMaxDistance","tapToleranceMs","tapState","triggerEventCallback","ele","_onTouchDrag","currentPointsList","_updateTouchEventsLastPoints","deltaDistance","totalDistance","currentTime","getTime","x","y","swipe","RIGHT","LEFT","DOWN","UP","_checkTouchSwipe","_onTouchEnd","distanceFromStart","_checkTouchTap","lp","_onTouchPress","_onTouchStart","preventGhostClick","touchStartListener","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","deltaY","spinX","spinY","pixelX","pixelY","wheelDelta","wheelDeltaY","wheelDeltaX","deltaX","deltaMode","normalizeWheel","direction","MOUSE_WHEEL","wheel","wheelListener","key","keyCode","keyListener","KEY_DOWN","_onKeyUp","_onVisibilityChange","visibilityState","resetModifierKey","KEY_UP","keyDownListener","getModifierKey","defaultContourConfig","renderOutline","outlineWidthActive","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","renderFill","fillAlpha","fillAlphaInactive","defaultLabelmapConfig","renderFillInactive","getDefaultLabelmapConfig","getDefaultContourConfig","initialDefaultState","colorLUT","segmentations","globalConfig","renderInactiveSegmentations","representations","Labelmap","Contour","defaultSegmentationStateManager","csUtils","getState","getToolGroups","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","getSegmentation","segmentationId","find","segmentation","addSegmentation","getSegmentationRepresentations","toolGroupId","toolGroupSegRepresentationsWithConfig","segmentationRepresentations","getAllSegmentationRepresentations","toolGroupSegReps","entries","_ref","addSegmentationRepresentation","segmentationRepresentation","config","_handleActiveSegmentation","getGlobalConfig","setGlobalConfig","getSegmentationRepresentationByUID","segmentationRepresentationUID","representation","removeSegmentation","removeSegmentationRepresentation","toolGroupSegmentationRepresentations","segData","console","warn","removedSegmentationRepresentation","setActiveSegmentationRepresentation","toolGroupSegmentations","segmentationData","active","getToolGroupSpecificConfig","toolGroupStateWithConfig","getSegmentationRepresentationSpecificConfig","segmentationRepresentationSpecificConfig","setSegmentationRepresentationSpecificConfig","getSegmentSpecificConfig","segmentIndex","segmentSpecificConfig","setSegmentSpecificConfig","setSegmentationRepresentationConfig","addColorLUT","structuredClone","removeColorLUT","colorLUTIndex","recentlyAddedOrRemovedSegmentationRepresentation","triggerSegmentationRemoved","SEGMENTATION_REMOVED","triggerSegmentationRepresentationRemoved","SEGMENTATION_REPRESENTATION_REMOVED","triggerSegmentationRepresentationModified","SEGMENTATION_REPRESENTATION_MODIFIED","triggerSegmentationModified","segmentationIds","getSegmentations","SEGMENTATION_MODIFIED","triggerSegmentationDataModified","modifiedSlicesToUse","SEGMENTATION_DATA_MODIFIED","segmentationInput","cachedStats","segmentLabels","label","segmentsLocked","activeSegmentIndex","representationData","data","getDefaultSegmentationStateManager","suppressEvents","segmentationStateManager","normalizeSegmentationInput","getToolGroupIdsWithSegmentation","toolGroupIds","foundToolGroupIds","setToolGroupSpecificConfig","getSegmentSpecificRepresentationConfig","setSegmentSpecificRepresentationConfig","isVolumeSegmentation","operationData","volumeId","async","labelMapData","renderingEngine","id","volumeInputs","actorUID","visibility","blendMode","MAXIMUM_INTENSITY_BLEND","addVolumesToViewports","stackInputs","imageId","imageIdReferenceMap","getCurrentImageId","addImageSlicesToViewports","StackViewport","removeVolumeActors","MAX_NUMBER_COLORS","labelMapConfigCache","Map","getRepresentationRenderingConfig","cfun","vtkColorTransferFunction","ofun","vtkPiecewiseFunction","addPoint","_getLabelmapConfig","toolGroupLabelmapConfig","segmentationRepresentationLabelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","outlineWidth","_needsTransferFunctionUpdate","_ref2","segmentColor","segmentsHidden","cacheUID","oldConfig","slice","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_addLabelmapToViewport","labelmapData","addLabelmapToElement","render","toolGroupConfig","renderingConfig","SegmentationState","Representations","actorEntry","getActor","labelmapUID","cache","getVolume","referencedVolumeId","defaultActor","getDefaultActor","defaultActorUID","volume","referencedVolume","isSameFrameOfReference","numColors","min","segmentSpecificLabelmapConfig","addRGBPoint","segmentOpacity","removePoint","addPointLong","actor","getProperty","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","renderImmediate","toolGroup","getToolGroup","viewportsInfo","viewportInfo","getEnabledElementByIds","removeLabelmapFromElement","_removeLabelmapFromToolGroupViewports","getViewportsInfo","contourRepresentation","segmentId","CONTOUR","configCachePerSegmentationRepresentationUID","getConfigCache","setConfigCache","addContourSetsToElement","geometryIds","contourRepresentationConfig","contourActorUID","appendPolyData","vtkAppendPolyData","scalarToColorMap","segmentSpecificMap","geometryId","geometry","getGeometry","getSegmentIndex","validateGeometry","contourSet","polyData","pointArray","vtkPoints","lines","vtkCellArray","pointIndex","getContours","contour","pointList","getPoints","flatPoints","getFlatPointsArray","getType","pointIndexes","_","pointListIndex","CLOSED_PLANAR","linePoints","Float32Array","insertNextCell","setData","polygon","vtkPolyData","setPoints","setLines","getPolyData","color","getColor","getNumberOfPoints","scalars","vtkDataArray","numberOfComponents","dataType","setTuple","getPointData","setScalars","setInputData","addInputData","polyDataOutput","getOutputData","mapper","vtkMapper","vtkActor","setMapper","setLineWidth","assign","setForceOpaque","addActor","resetCamera","updateContourSets","newContourConfig","cachedConfig","contourSetsActor","newOutlineWithActive","getMapper","lut","getLookupTable","segmentsToSetToInvisible","segmentsToSetToVisible","mergedInvisibleSegments","includes","concat","contourSets","segmentSpecificConfigs","acc","affectedSegments","hasCustomSegmentSpecificConfig","values","some","polyDataModified","getInputData","appendScalarsData","getScalars","getData","offset","getTotalNumberOfPoints","segmentConfig","modified","setLookupTable","actorUIDsToRemove","getActors","Boolean","removeActors","representationConfig","contourData","addOrUpdateContourSets","removeContourFromElement","_removeContourFromToolGroupViewports","deleteConfigCache","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","segmentationDataUID","labelmapDisplay","contourDisplay","_removeSegmentation","segmentationInputArray","validateLabelmap","validateSegmentationInput","segInput","addSegmentationToState","segmentationConfig","getGlobalRepresentationConfig","representationType","setGlobalRepresentationConfig","segmentationRepresentationConfig","getRepresentationSpecificConfig","representationInput","getLabelmapRenderingConfig","representationInputArray","toolGroupSpecificRepresentationConfig","promises","toolGroupSpecificConfig","options","colorLUTOrIndexInput","colorLUTOrIndex","colorLUTIndexToUse","nextIndex","isArray","CORNERSTONE_COLOR_LUT","toolGroupSpecificRepresentation","currentToolGroupConfig","SegmentationConfig","mergedConfig","addSegmentationRepresentationToState","Promise","all","getActiveSegmentationRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegments","unshift","setColorLUT","segRepresentation","getColorForSegmentIndex","setColorForSegmentIndex","colorReference","setSegmentationVisibility","indices","scalarData","getScalarData","keySet","it","parseInt","getSegmentationIndices","clear","getSegmentationVisibility","setSegmentsVisibility","segmentIndices","setSegmentVisibility","setActiveSegmentIndex","getActiveSegmentIndex","BaseTool","toolProps","defaultToolProps","initialProps","configuration","supportedInteractionTypes","strategies","defaultStrategy","activeStrategy","strategyOptions","mode","Disabled","getToolName","applyActiveStrategy","call","setConfiguration","newConfiguration","setActiveStrategy","strategyName","getTargetVolumeId","actorEntries","getClassName","getTargetIdImage","targetId","startsWith","split","imageURI","viewports","getImageData","getTargetId","BaseVolumeViewport","VideoViewport","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","viewportElement","internalDivElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","fn","svgDrawingHelper","getSvgDrawingHelper","drawingElementType","nodeUID","attributes","currentValue","getAttribute","newValue","removeAttribute","setAttribute","circleUID","center","radius","dataId","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","_getHash","existingCircleElement","cx","cy","r","stroke","setAttributesIfNecessary","newCircleElement","createElementNS","setNewAttributesIfValid","ellipseUID","canvasCoordinates","existingEllipse","bottom","right","w","hypot","h","angle","atan2","PI","rx","ry","svgEllipseElement","corner1","corner2","drawEllipseByCoordinates","handleGroupUID","handlePoints","opacity","handle","svgns","side","parseFloat","height","existingHandleElement","newHandleElement","drawLine","lineUID","start","end","isNaN","shadow","existingLine","dropShadowStyle","x1","y1","x2","y2","style","newLine","drawPolyline","polylineUID","fillColor","connectLastToFirst","existingPolyLine","pointsAttribute","point","firstPoint","newPolyLine","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","getBBox","insertBefore","firstChild","bBox","textUID","textLines","position","padding","fontFamily","fontSize","background","textGroupBoundingBox","existingTextGroup","textElement","textSpans","children","textSpan","textGroupAttributes","transform","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","findClosestPoint","sourcePoints","targetPoint","minPoint","minDistance","Number","MAX_SAFE_INTEGER","sourcePoint","distance","p1","p2","_distanceBetween","linkUID","annotationAnchorPoints","refPoint","boundingBox","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","textBoxUID","textBoxPosition","textBox","mergedOptions","centering","canvasBoundingBox","drawTextBox","drawLink","drawRect","rectangleUID","_width","existingRect","tlhc","svgRectElement","drawArrow","arrowUID","firstLine","cos","sin","secondLine","drawRedactionRect","_setAttributesIfNecessary","_setNewAttributesIfValid","getToolsWithModesForElement","modesFilter","ToolGroupManager","enabledTools","toolGroupToolNames","toolOptions","toolInstance","getToolInstance","Active","Passive","Enabled","annotationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedViewports","_throwIfDestroyed","elements","_viewportElements","_triggerRender","addViewportElement","removeViewportElement","_reset","renderViewport","_setViewportsToBeRenderedNextFrame","hasBeenDestroyed","_setAllViewportsToBeRenderedNextFrame","elementsEnabled","indexOf","_render","requestAnimationFrame","getRenderingEngine","drawSvg","anyRendered","tool","renderAnnotation","rendered","ANNOTATION_RENDERED","cancelAnimationFrame","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","filterAnnotationsWithinSlice","spacingInNormalDirection","viewPlaneNormal","annotationsWithParallelNormals","td","annotationViewPlaneNormal","referencedImageId","imageOrientationPatient","metaData","rowCosineVec","vec3","colCosineVec","isParallel","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","handles","dir","dot","AnnotationFrameRange","imageIdToFrames","match","frameRangeExtractor","range","framesToString","String","framesToImageId","newRangeString","replace","setFrameRange","eventBase","ANNOTATION_MODIFIED","getFrameRange","baseUrlExtractor","filterAnnotationsForDisplay","colonIndex","substring","getFrameOfReferenceUID","testURI","hasImageURI","annotationFrameRange","frameNumber","getFrameNumber","VolumeViewport","getCamera","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","getViewportToolStyles","getToolGroupToolStyles","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","getStyleProperty","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","alternatives","list","getHierarchalPropertyStyles","highlighted","Highlighted","Selected","Locked","Default","AnnotationDisplayTool","onImageSpacingCalibrated","annotationManager","getAnnotationManager","frameOfReference","triggerAnnotationRender","filterInteractableAnnotationsForElement","getReferencedImageId","worldPos","viewUp","imageVolume","getStyle","AnnotationTool","super","mouseMoveCallback","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","activateHandleIndex","activeHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","getTextLines","statsCalculator","getHandleNearImagePoint","proximity","worldBoundingBox","topLeft","worldToCanvas","topRight","bottomLeft","bottomRight","annotationCanvasCoordinate","vec2","getLinkedTextBoxStyle","isSuvScaled","scaling","PT","scalingModule","suvbw","isPointNearTool","pointToString","decimals","toFixed","polyDataCache","updateSurfacePlanes","vtkPlanes","clippingFilter","imageIndex","getCurrentImageIdIndex","cacheId","actorCache","setClippingPlanes","update","error","surface","polys","getPolys","triangles","setPolys","VolumeViewport3D","vtkClipClosedSurface","clippingPlanes","activePlaneId","passPointData","setGenerateOutline","setGenerateFaces","filteredData","setColor","CLIPPING_PLANES_UPDATED","SurfaceData","Surface","SURFACE","surfaceUID","addSurfaceToElement","_renderSurface","removeSurfaceFromElement","_removeSurfaceFromToolGroupViewports","SegmentationDisplayTool","renderSegmentation","toolGroupViewports","segmentationRenderList","_getMergedRepresentationsConfig","viewportsRenderList","display","surfaceDisplay","renderedViewport","allSettled","then","onSetToolEnabled","onSetToolDisabled","segmentationRenderingEngine","_renderFlaggedToolGroups","removeToolGroup","renderToolGroupSegmentations","_setToolGroupSegmentationToBeRenderedNextFrame","getViewport","segmentationDisplayToolInstance","onSegmentationRender","IMAGE_RENDERED","getToolGroupForViewport","csToolsEvents","SEGMENTATION_RENDERED","triggerSegmentationRender","segmentationVolume","imageData","vtkOpenGLTexture","slicesToUpdate","numSlices","getDimensions","setUpdatedFrame","currentImageId","segImageData","currentSegmentationImageId","segmentationImage","getImage","_imageChangeEventListener","eventData","representationList","segmentationActor","derivedImageId","segmentationImageData","scalarArray","Uint8Array","vtkImageData","derivedImage","origin","dimensions","spacing","getImageDataMetadata","setOrigin","addImages","callback","imageActor","getPixelData","setDimensions","setSpacing","setDirection","STACK_NEW_IMAGE","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","_toolInstances","found","findAnnotationNearPointByTool","currentId","func","wait","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","_len","_key","leadingEdge","isObject","max","cancel","cancelTimer","flush","pending","debounce","clip","val","low","high","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","USER","scale","getStackViewports","getImageIds","calibrateSpacing","CalibrationTypes","PIXEL_UNITS","getCalibratedLengthUnits","image","calibration","hasPixelSpacing","units","UNCALIBRATED","SequenceOfUltrasoundRegions","getCalibratedAreaUnits","getCalibratedScale","getCalibratedAspect","aspect","viewportIdsToRender","scroll","viewportType","scrollSlabs","debounceLoading","loop","useSlabThickness","numScrollSteps","currentStepIndex","sliceRangeInfo","sliceRange","newFocalPoint","newPosition","setCamera","desiredStepIndex","VolumeScrollEventDetail","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","scrollVolume","currentImageIndex","numberOfSlices","getTargetImageIdIndex","_getImageSliceData","imageIndexToJump","lastSliceIndex","_getImageIndexToJump","pointInShapeCallback","pointInShapeFn","boundsIJK","iMin","iMax","jMin","jMax","kMin","kMax","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","pointsInShape","currentPos","k","startPosJ","startPosI","pointIJK","pointLPS","numSlicesToProject","sliceNormalIndex","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","p","floor","depth","transformWorldToIndex","pointInSurroundingSphereCallback","circlePoints","centerWorld","radiusWorld","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","viewRight","topLeftWorld","bottomRightWorld","sphereCornersIJK","getBoundingBoxAroundShape","_computeBoundsIJKWithCamera","_getBounds","sphereObj","sphere","pointInSphere","roundNumber","precision","v","join","fixedPrecision","imageScalarData","strategySpecificConfiguration","THRESHOLD_INSIDE_CIRCLE","voxelValue","threshold","getStrategyData","segmentationScalarData","fillSphere","strategyData","scalarIndex","isWithinThreshold","sliceArray","minSlice","maxSlice","fillInsideSphere","thresholdInsideSphere","eraseInsideSphere","pointInEllipse","ellipse","inverts","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","inside","dx","dy","dz","getCanvasEllipseCorners","ellipseCanvasPoints","fillCircle","ellipseObj","getCenter","topLeftCanvas","bottomRightCanvas","ellipsoidCornersIJK","every","_ref3","getEllipse","fast","fillInsideCircle","thresholdInsideCircle","eraseInsideCircle","DEFINED_CURSORS","Symbol","STANDARD_CURSORS","MouseCursor","fallback","getName","addFallbackStyleProperty","getDefinedCursor","definedCursors","getDefinedCursors","mouseCursor","setDefinedCursor","cursor","context","symbol","standardCursorNames","ImageMouseCursor","url","getUniqueInstanceName","prefix","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","create","registerCursor","svgCursorNames","STATE","MODE","SVGMouseCursor","pointer","urn","getCursorURN","getDefinedSVGCursorDescriptor","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","prototype","hasOwnProperty","svgSize","cursorName","log","setElementCursor","CursorNames","ELEMENT_CURSORS_MAP","initElementCursor","_getElementCursors","_setElementCursor","cursors","resetElementCursor","hideElementCursor","WeakMap","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE","brushSize","onSetToolPassive","disableCursor","preMouseDownCallback","activeSegmentationRepresentation","activeSegmentation","segmentLocking","segmentationState","firstVolumeActorUID","_editData","_activateDraw","triggerAnnotationRenderForViewportUIDs","updateCursor","_dragCallback","brushCursor","_hoverData","_endCallback","_deactivateDraw","centerCanvas","segmentIndexController","_calculateCursor","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","invalidateBrushCursor","toolMetadata","brushCursorUID","drawCircleSvg","getBrushToolInstances","toolInstances","equalsCheck","a","b","getVoxelOverlap","voxelSpacing","voxelCenter","voxelCornersWorld","voxelCornersIJK","processVolumes","thresholdVolumeInformation","segmentationSpacing","volumeInfoList","baseVolumeIdx","volumeSize","referenceValues","lower","upper","overwrite","overlapType","overlaps","testOverlapRange","volumeInfo","overlapBounds","overlapTest","testRange","computeOffsetIndex","insert","AnnotationGroup","annotationUIDs","_isVisible","visibleFilter","unboundVisibleFilter","setVisible","baseEvent","findNearby","uids","remove","_len2","_key2","PanTool","touchDragCallback","mouseDragCallback","deltaPointsWorld","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","rotateCamera","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","mat4","currentPointsCanvas","lastPointsCanvas","clientWidth","clientHeight","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","vtkMath","noe","angleX","acos","sign","upVec","atV","rightV","forwardV","angleY","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint16Array","Int16Array","frame","buffer","_getMinMax","modality","newRange","viewportsContainingVolumeUID","isPreScaled","properties","getProperties","voiRange","Modality","preScale","scaled","scalingParameters","getPTScaledNewRange","deltaPointsCanvas","getNewRange","setProperties","vp","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","windowWidth","windowCenter","imageDynamicRange","calculatedDynamicRange","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","round","getRange","voxel","StackScrollTool","invert","debounceIfNotLoaded","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","getNumberOfSlices","offsetHeight","angleBetweenLines","line1","line2","p3","p4","v1","v2","angleBetween3DLines","angleBetween2DLines","PlanarRotateTool","currentPointWorld","startPointWorld","cross","rotAngle","rotMat","rotatedViewUp","rotation","StackScrollMouseWheelTool","mouseWheelCallback","ZoomTool","_this","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","preTouchStartCallback","_dragParallelProjection","pinch","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","t","cappedParallelScale","thresholdExceeded","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","parallelProjection","_panCallback","DIRECTIONS","X","Y","Z","CUSTOM","VolumeRotateMouseWheelTool","cz","ax","ay","az","getWorldWidthAndHeightFromCorners","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","cameraPosition","step","bounds","getBounds","vector","pickedPoint","pointT","_inBounds","pointToPick","getIntensityFromWorld","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","maxFn","intensity","getViewports","foundToolGroup","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","filterViewportsWithParallelNormals","INSIDE","OUTSIDE","clipT","num","denom","c","tE","tL","box","da","db","distanceToPointSquared","aabb","aabbWidth","maxX","minX","aabbHeight","maxY","minY","aabbSize","aabbCenter","translatedPoint","dist","distanceToPoint","BasicStatsCalculator","Calculator","singleArrayAsNumber","z1","z2","mirror","mirrorPoint","staticPoint","getIntersectionCoordinatesWithPolyline","q1","polylineIndexes","initialI","intersections","doesIntersect","getAllIntersectionsWithPolyline","intersection","getIntersection","getFirstIntersectionWithPolyline","getClosestIntersectionWithPolyline","q2","distances","intersectionPoints","midpoint","segment","orient","orientation","onSegment","q","orientationValue","denominator","numerator1","numerator2","sum","sumSquares","squaredDiffSum","statsCallback","newArray","idx","getStatistics","mean","stdDev","stdDevWithSumSquare","currentMax","unit","getSubPixelSpacingAndXYDirections","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","pointsAreWithinCloseContourProximity","closeContourProximity","addCanvasPointsToArray","canvasPoints","newCanvasPoint","commonData","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","pointCanProjectOnLine","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","calculateAreaOfPoints","n","area","lineSegments","rectToLineSegments","lineStart","lineEnd","lineSegment","distanceToPointSquaredInfo","closestPoint","distanceSquared","math","dotProduct","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","autoPan","enabled","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","mobile","toolCenter","initializeViewport","_getAnnotations","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","_getViewportsInfo","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","normal2","point2","normal3","point3","firstPlane","secondPlane","thirdPlane","triggerAnnotationRenderForViewportIds","addNewAnnotation","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_activateModify","handleSelectedCallback","_pointNearTool","toolSelectedCallback","onCameraModified","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","getViewportIds","_autoPanViewportIfNecessary","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","_areViewportIdArraysEqual","renderStatus","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","vtkMatrixBuilder","buildFromDegree","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","line","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","drawLineSvg","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","drawHandlesSvg","viewportIds","_onNewVolume","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","actors","otherViewportActors","sameScene","_ref4","viewportsAnnotationsToUpdate","_applyDeltaShiftToSelectedViewportCameras","_deactivateModify","editData","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","translate","otherViewportsIds","renderViewports","referenceAnnotations","viewportsIds","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","onSetToolActive","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","_ref5","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","_ref6","VOLUME_VIEWPORT_NEW_VOLUME","_ref7","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","slabThickness","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","_applyDeltaShiftToViewportCamera","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_getReferencedImageId","_createMagnificationViewport","viewportProperties","canvasPos","magnifyToolElement","magnifyElement","createElement","classList","viewportInput","STACK","enableElement","magnifyViewport","setStack","_dragEndCallback","disableElement","getCanvasCircleRadius","circleCanvasPoints","getCanvasCircleCorners","MAGNIFY_VIEWPORT_INITIAL_RADIUS","isSegmentation","referenceId","AdvancedMagnifyViewport","magnifyViewportId","sourceEnabledElement","zoomFactor","_enabledElement","_sourceToolGroup","_magnifyToolGroup","_isViewportReady","_radius","_resized","_canAutoPan","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_mouseDragCallback","_resizeViewportAsync","_resizeViewport","_initialize","_syncViewports","dispose","_removeEventListeners","parentNode","magnifyToolGroup","toolBindingsOptions","setToolActive","setToolPassive","setToolEnabled","setToolDisabled","_inheritBorderRadius","borderRadius","_createViewportNode","overflow","boxSizing","_convertZoomFactorToParalellScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceViewport","sourceActors","magnifyToolGroupId","sourceToolGroup","clone","AdvancedMagnifyTool","addViewport","_cloneStack","imageIds","_cloneVolumes","volumeInputArray","setVolumes","_cloneViewport","sourceViewportOptions","defaultOptions","_cancelMouseEventCallback","target","closest","canvasCurrent","magnifyRadius","canvasCenter","maxDist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","_addBrowserEventListeners","_removeBrowserEventListeners","_addEventListeners","cstEvents","TOOL_MODE_CHANGED","sourceCanvas","_syncViewportsCameras","_syncStackViewports","setImageIdIndex","sourceProperties","resize","AdvancedMagnifyViewportManager","createViewport","sourceElement","_addSourceElementEventListener","_magnifyViewportsMap","_annotationRemovedCallback","_destroyViewport","_newStackImageCallback","sourceViewportId","_getMagnifyViewportsMapEntriesBySourceViewportId","_newVolumeImageCallback","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","len","getInstance","_singleton","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","ANNOTATION_REMOVED","VOLUME_NEW_IMAGE","AdvancedMagnifyToolActions","magnifyingGlass","zoomFactorList","actions","showZoomFactorsList","method","bindings","Secondary","modifierKey","Shift","worldHandlesPoints","_getWorldHandlesPoints","magnifyViewportManager","annotationPoints","canvasTop","canvasBottom","canvasLeft","radiusPoint","handleIndex","newAnnotation","isDrawing","eventType","ANNOTATION_COMPLETED","_dragDrawCallback","worldPosDelta","hasMoved","_dragModifyCallback","_dragHandle","newRadius","newWorldHandlesPoints","activeHandleCanvasCoords","canvasCenterPos","canvasRadius","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","which","toLowerCase","option","title","defaultSelected","Actions","ReferenceLines","showFullDimension","_init","getRenderingEngines","sourceViewportCanvasCornersInWorld","targetViewport","sourceViewPlaneNormal","targetViewportPlane","pointSet1","pointSet2","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","targetImage","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","OverlayGridTool","sourceImageIds","imagePlaneModule","pointSets","calculateImageIdPointSets","viewportData","imagePositionPatient","rows","columns","rowPixelSpacing","columnPixelSpacing","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","getCacheId","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","toString","colorToString","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","worldPosition","previousCamera","oldFocalPoint","cameraNormal","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","centerSpace","lineLength","plane","currentMousePosition","closestIndex","normalizedViewPlane","scaledPlaneNormal","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBoxSvg","scaleSizeDisplayValue","scaleSizeUnits","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","handlesLeftToRight","sort","_compareX","handlesTopToBottom","_compareY","_determineCorners","BidirectionalTool","defaultGetTextLines","canvasPoint1","canvasPoint2","movingTextBox","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_throttledCalculateCachedStats","_calculateCachedStats","dataId1","dataId2","canvasTextBoxCoords","drawLinkedTextBoxSvg","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","dist1","_calculateLength","dist2","index1","index2","index3","index4","_isInsideVolume","vector1","vector2","throttle","LengthTool","cachedVolumeStats","getModalityUnit","generalSeriesModule","petSeriesModule","_handlePTModality","isViewportPreScaled","targetIdTokens","ProbeTool","eventDispatchDetail","referencedImageURI","currentImageURI","modalityUnitOptions","samplesPerPixel","baseIndex","modalityUnit","DragProbeTool","postMouseDownCallback","postTouchStartCallback","RectangleROITool","_getRectangleImageCoordinates","rectangle","bottomLeftCanvas","topRightCanvas","bottomLeftWorld","topRightWorld","areaUnit","drawRectSvg","worldPos1Index","worldPos2Index","stats","statsArray","getWorldWidthAndHeightFromTwoPoints","EllipticalROITool","centerPointRadius","initialRotation","getRotation","canvasCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","currentCanvasPoints","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","dYCanvas","newHalfCanvasWidth","canvasRight","dXCanvas","newHalfCanvasHeight","drawEllipseSvg","centerPoint","_getCanvasEllipseCenter","isEmptyArea","normalized","areaLine","CircleROITool","canvasEnd","radiusUnit","perimeter","radiusLine","Spline","props","_controlPoints","_invalidated","_length","_resolution","resolution","_closed","closed","controlPoints","numControlPoints","_update","_aabb","hasTangentPoints","addControlPoint","addControlPoints","addControlPointAtU","u","_getLineSegmentAt","startPoint","endPoint","curveSegmentIndex","curveSegment","_curveSegments","controlPointPos","insertIndex","deleteControlPointByIndex","minControlPoints","clearControlPoints","setControlPoints","updateControlPoint","newControlPoint","getControlPoints","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","squaredDist","getClosestControlPointWithinDistance","closestControlPoint","getClosestPoint","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","csA","csB","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","uValue","previousLineSegmentsLength","getClosestPointOnControlPointLines","getPolylinePoints","_convertCurveSegmentsToPolyline","getPreviewPolylinePoints","controlPointPreview","closeDistance","closeSpline","previewCurveSegments","getPreviewCurveSegments","isPointNearCurve","curveSegments","_getCurveSegmmentsWithinDistance","maxDistSquared","containsPoint","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","numIntersections","curveSegAABB","lineSegmentAABB","isVerticalLine","xIntersection","getSplineCurves","curveSegLength","polylinePoints","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","CubicSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","getTransformMatrix","_getCurveSegment","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","p0","_getCurveSegmentPoints","tt","ttt","tValues","vec4","qValues","p0Index","p2Index","p3Index","_getLineSegments","numLineSegments","inc","maxU","curveSegmentLength","lineSegAABB","lineSegLength","CardinalSpline","_scale","_fixedScale","fixedScale","s","s2","LinearSpline","CatmullRomSpline","TRANSFORM_MATRIX","BSpline","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","calculateStats","spline","Cardinal","Class","CatmullRom","Linear","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","splineType","splineConfig","_getSplineConfig","instance","polyline","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","_mouseMoveCallback","_mouseDownCallback","doubleClick","worldPoint","addNewPoint","triggerAnnotationModified","_updateSplineInstance","splinePolylineCanvas","splinePolylineWorld","drawPolylineSvg","controlPointsConnectors","_renderStats","addControlPointCallback","closestPointInfo","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","splineConfigs","_updateSplineScale","SplineTypes","interpolateSegmentPoints","iniIndex","endIndex","knotsRatioPercentage","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","interpolatedPoints","originalPoints","knotsIndexes","xInterpolator","d3InterpolateBasis","yInterpolator","zInterpolator","d3Zip","d3Quantize","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","continuosDistributionValue","getContinuousUniformDistributionValues","shouldInterpolate","interpolation","interpolateOnAdd","interpolateOnEdit","followingIndex","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","startIndex","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","pointA","pointB","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","highIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","changedIniIndex","changedEndIndex","findOpenUShapedContourVectorToPeak","first","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","activateDraw","drawData","polylineIndex","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","lastWorldPoint","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","allowOpenContours","lastPoint","completeDrawOpenContour","completeDrawClosedContour","removeCrossedLinesOnCompleteDraw","haltDrawing","pop","worldPoints","isOpenContour","triggerAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","indexToRemoveUpTo","isOpenUShapeContour","openUShapeContourVectorToPeak","pointsLessLastOne","shift","activateClosedContourEdit","cancelDrawing","minPoints","shouldHaltDrawing","checkForFirstCrossing","isClosedContour","editCanvasPoints","prevCanvasPoints","crossedLineSegment","startCrossingIndex","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","twoClosestDistanceIndexPairs","lowestIndex","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","editIndex","numPointsToRemove","checkForSecondCrossing","removePointsAfterSecondCrossing","lastLine","didCrossLine","findSnapIndex","lastEditCanvasPoint","editCanvasPointsLessLastOne","snapCanvasPosition","checkAndRemoveCrossesOnEditLine","editIndexCrossed","isEditingClosed","mouseUpClosedContourEditCallback","mouseDragClosedContourEditCallback","deactivateClosedContourEdit","currentEditIndex","snapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","finishEditAndStartNewEdit","augmentedEditCanvasPoints","lowIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","inPlaceDistance","reverseDistance","completeClosedContourEdit","cancelClosedContourEdit","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activateOpenContourEndEdit","lastCanvasPos","aDotb","magA","magB","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","reverse","_getRenderingOptions","renderContour","findOpenUShapedContourVectorToPeakOnRender","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","renderClosedContour","alwaysRenderOpenContourHandles","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","PlanarFreehandROITool","previousPoint","pStart","pEnd","activeAnnotationUID","worldPosIndex","iDelta","jDelta","kDelta","worldPosEnd","canvasPosEnd","curRow","intersectionCounter","drawLinkedTextBox","registerDrawLoop","registerEditLoopCommon","registerClosedContourEditLoop","registerOpenContourEditLoop","registerOpenContourEndEditLoop","registerRenderMethods","annotationsToDisplay","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","touchTapCallback","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","drawArrowSvg","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","canvasPoint3","fromCharCode","midPoint","ret","arg","midPoint2","CobbAngleTool","distanceToLines","isNearFirstLine","isNearSecondLine","_mouseUpCallback","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","mid1","mid2","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","KeyImageTool","canvasPosition","fillRectangle","constraintFn","rectangleCornersIJK","coord","pointInRectangle","fillInsideRectangle","eraseRectangle","eraseInsideRectangle","RectangleScissorsTool","FILL_INSIDE","ERASE_INSIDE","CircleScissorsTool","SphereScissorsTool","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","spacingInNormal","_getEndSliceIndex","startSlice","endSlice","projectionPoints","projectionPointsImageIds","_computeProjectionPoints","sliceIndex","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","newPoint","RectanglePoints","endPos","imageIdIndex","defaultEquals","lpad","string","character","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","permute","perm","array","countNonZeroes","prunedPermutations","stack","flooded","visits","currentArgs","flood","boundaries","job","getArgs","prevArgs","previousArgs","markAsVisited","node","safely","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","f","isEqual","PaintFillTool","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","floodFill","scalarDataPosition","getFramesModified","minJ","maxJ","framesModified","seedIndex3D","getScalarDataPosition","z","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","OverlayMarkerType","ANNOTATED_CUBE","AXES","OrientationMarkerTool","orientationWidget","viewportCorner","vtkOrientationMarkerWidget","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","OVERLAY_MARKER_TYPES","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","polyDataURL","configuration_invalidated","initViewports","cleanUpData","orientationMarkers","orientationMarker","setEnabled","offscreenMultiRenderWindow","getRenderWindow","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","vtkAxesActor","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","response","fetch","arrayBuffer","vtpReader","vtkXMLPolyDataReader","parseAsArrayBuffer","shallowCopy","setActiveScalars","setColorModeToDirectScalars","rotateZ","vtkAnnotatedCubeActor","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","CUBE","AXIS","VTPFILE","referenceVolume","AllBoundsIJK","pointsToUse","extend2DBoundingBoxInViewAxis","accumulator","validToolNames","_validateAnnotations","getBoundsIJKFromRectangleAnnotations","thresholdVolumeByRange","labelmaps","labelmap","outputData","arrayType","volumeLoader","isValidRepresentationConfig","SegmentationRepresentation","isValidLabelmapConfig","getDefaultRepresentationConfig","createLabelmapVolumeForViewport","input","setBrushSizeForToolGroup","viewportsInfoArray","getBrushSizeForToolGroup","brushToolInstance","setBrushThresholdForToolGroup","getBrushThresholdForToolGroup","segmentationIndex","_handleSameSizeVolume","getPoint","callbackOverlap","_handleDifferentSizeVolume","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","addToolState","getToolState","ViewportStatus","dynamicVolumesPlayingMap","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","waitForRendered","frameTimeVectorEnabled","waitForRenderedCount","viewportStatus","RENDERED","_createStackViewportCinePlayContext","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","glMatrix","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","timeouts","isTimeVarying","sample","delay","limit","_getPlayClipTimeouts","playClipAction","newStepIndex","CINE_EVENTS","CLIP_STOPPED","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","stopDynamicCine","cineToolData","clearInterval","_stopClipWithData","dynamicCineElement","volumes","_getVolumesFromViewport","interpolateAnnotation","shouldPreventInterpolation","interpolatedCanvasPoints","requestType","Prefetch","priority","lowEnd","highEnd","arr","getStackData","currentImageIdIndex","getPromiseRemovedHandler","stackData","stackPrefetchData","indicesToRequest","clearFromImageIds","imageIdSet","requestDetails","additionalDetails","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","resetPrefetchDelay","prefetch","stackPrefetch","removeFromList","getImageLoadObject","isLoaded","imageLoadPoolManager","clearRequestStack","nearest","nearestIndex","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","getCoreConfiguration","rendering","targetBuffer","addRequest","onImageUpdated","indexOfCurrentImage","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","getConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","filterRequests","getCachedImageBasedOnImageURI","decodeTimeInMS","loadTimeInMS","sizeInBytes","usage","getMaxCacheSize","cacheFill","fillTime","fillSize","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","dynamicVolume","frames","frameNumbers","maskVolumeId","imageCoordinate","dataInTime","ijkCoords","maskImageData","segScalarData","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","isSameVolume","indexValues","activeScalarData","segPointLPS","segValue","segPointIJK","overlapIJKMinMax","perFrameSum","averageCallback","averageValues","_getTimePointDataMask","coordinate","worldToIndex","allScalarData","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","SUM","currentArray","SUBTRACT","AVERAGE","getPolyDataPointIndexes","linesData","getLines","contours","findStartingPoint","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","ColorbarRangeTextPosition","isRangeValid","isColorbarSizeValid","areColorbarRangesEqual","areColorbarSizesEqual","clamp","ColorbarCanvas","validateProps","colormap","imageRange","container","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_setCanvasSize","showFullImageRange","pointerEvents","isConnected","RGBPoints","rgbPoints","colorsCount","getColorPoint","canvasContext","getContext","isHorizontal","maxValue","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","interpolateVec3","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","ticks","ticksProps","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","_getTicks","roughStep","stepPower","log10","roughtStepNormalized","scaleMax","scaleMin","ticksCount","_getLeftTickInfo","labelMeasure","labelPoint","tickPoints","_getRightTickInfo","_getTopTickInfo","_getBottomTickInfo","maxCanvasPixelValue","rangeWidth","clearRect","textBaseline","strokeStyle","tick","measureText","tickInfo","Top","Left","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","Widget","_containerResizeCallback","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","rootElement","resizeObserver","currentContainer","unobserve","observe","destroy","disconnect","containerSize","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","_mouseOutCallback","hideTicks","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","canvasDelta","local","voiLower","voiUpper","newVoiRange","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","activeColormapName","colormapName","currentVoiRange","onVoiChange","reset","updateTicksBar","colormaps","items","Name","cm","containerWidth","containerHeight","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","manager","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_addCornerstoneEventListener","ptMultiplier","fixedPTWindowWidth","xMultiplier","volumeActor","getRGBTransferFunction","interval","VOI_MODIFIED","onImageRendered","customCallbackHandler","handlerType","customFunction","activeTool","filterToolsWithMoveableHandles","ToolAndAnnotations","toolsWithMoveableHandles","filterToolsWithAnnotationsForElement","filterMoveableAnnotationTools","moveableAnnotationTools","shiftKey","ctrlKey","kb","ShiftCtrl","altKey","ShiftAlt","metaKey","ShiftMeta","CtrlAlt","CtrlMeta","AltMeta","Alt","Meta","getActiveToolForMouseEvent","mouseEvent","getMouseModifier","keyEventListener","defaultMousePrimary","getDefaultMousePrimary","correctBinding","binding","getToolsWithModesForMouseEvent","evtButton","mouseDownAnnotationAction","toolsWithActions","toolModes","actionsConfig","action","getToolsWithActionsForMouseEvent","mouseDown","isPrimaryClick","applicableTools","annotationToolsWithAnnotations","annotationToolsWithMoveableHandles","isMultiSelect","getAnnotationForSelection","toggleAnnotationSelection","toolsWithMovableHandles","mouseDownActivate","mouseDrag","mouseMove","activeAndPassiveTools","toolsWithAnnotations","toolsWithoutAnnotations","toolAndAnnotation","mouseClick","mouseDoubleClick","mouseUp","mouseWheel","getActiveToolForKeyboardEvent","keyDown","setViewportsCursorByToolName","keyUp","CAMERA_MODIFIED","IMAGE_SPACING_CALIBRATED","getActiveToolForTouchEvent","touchEvent","numTouchPoints","getToolsWithModesForTouchEvent","touchStart","touchStartActivate","touchDrag","touchEnd","touchTap","touchPress","addEnabledElement","svgLayer","svgLayerId","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","newNode","viewportUid","renderingEngineUid","dataset","elementHash","_setSvgNodeCache","mouseEventListeners","wheelEventListener","touchEventListeners","imageChangeEventListener","imageRenderedEventDispatcher","cameraModifiedEventDispatcher","imageSpacingCalibratedEventDispatcher","mouseToolEventDispatcher","keyboardToolEventDispatcher","touchToolEventDispatcher","synchronizersFilteredByIds","synchronizer","notDisabled","isDisabled","hasSourceViewport","hasTargetViewport","toolGroupFilteredByIds","tg","_removeViewportFromSynchronizers","getSynchronizersForViewport","sync","_removeViewportFromToolGroup","removeViewports","_removeEnabledElement","foundElementIndex","el","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","cancelActiveManipulations","toolsWithData","_getViewportIndex","ar","_containsViewport","synchronizerId","eventHandler","_viewportOptions","_onEvent","_ignoreFiredEvents","_targetViewports","_sourceViewports","fireEvent","_enabled","_eventName","_eventHandler","_options","_auxiliaryEventNames","auxiliaryEventNames","_hasSourceElements","setOptions","getOptions","addTarget","addSource","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","removeTarget","_getViewportElement","sourceEvent","ex","vp1","vp2","unique","vps","_getUniqueViewports","_remove","disableHandler","elementDisabledEvent","vUid","ELEMENT_DISABLED","Synchronizer","synchronizerIndex","ToolGroup","restoreToolOptions","toolInstanceName","toolDefinition","hasToolName","localToolInstance","instantiatedTool","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","renderingEngines","renderingEngineUIDToUse","vpId","getActivePrimaryMouseButtonTool","vpInfo","setToolMode","TouchBinding","MouseBinding","obj","binding1","binding2","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","_setCursorForViewports","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","toolOptionsForTool","_getCursor","setToolConfiguration","_configuration","getToolConfiguration","configurationPath","newToolGroupId","fnToolFilter","sourceToolInstance","sourceToolOptions","sourceToolMode","toolGroupIndex","removeSegmentationsFromToolGroup","csToolsState","destroyToolGroup","MODES","defaultManager","setAnnotationManager","resetAnnotationManager","HTMLDivElement","ANNOTATION_ADDED","triggerAnnotationAddedForElement","getToolGroupsWithToolName","viewportsToRender","triggerAnnotationAddedForFOR","annotationManagerUID","csToolsInitialized","init","_removeCornerstoneEventListeners","elementEnabledEvent","ELEMENT_ENABLED","removeEnabledElement","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","TOOLS_EVENTS","annotationModifiedListener","annotationSelectionListener","segmentationModifiedListener","segmentationDataModifiedEventListener","segmentationRepresentationModifiedEventListener","segmentationRepresentationRemovedEventListener","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","voiSyncCallback","voiModifiedEvent","invertStateChanged","tProperties","syncInvertState","createVOISynchronizer","zoomPanSyncCallback","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","getSpatialRegistration","sourceId","imageSliceSyncCallback","disabled","imageId1","sourceImagePositionPatient","targetImageIds","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","areViewportsCoplanar","registrationMatrixMat4","useInitialPosition","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","closestImageIdIndex","imageIndexToSet","jumpToSlice","createImageSliceSynchronizer","createStackImageSynchronizer","VideoRedactionTool","viewportUIDsToRender","toolDataCanvasCoordinate","drawRedactionRectSvg","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldToIndexVec3","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex","_getTargetStackUID"],"sourceRoot":""}