{"version":3,"file":"710.bundle.9b2d129f029d82fc5ebb.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/colorPickerDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/getSegmentLabel.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/updateSegmentationLabels.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/SegmentationToolbox.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getPanelModule.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/hydrationUtils.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/generateLabelmaps2DFromImageIdMap.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/init.ts"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-seg';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import { utils } from '@ohif/core';\nimport { metaData, cache, triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/tools';\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\n\nimport { SOPClassHandlerId } from './id';\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\n\nlet loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(instances, servicesManager, extensionManager) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'SEG',\n    loading: false,\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    segments: {},\n    sopClassUids,\n    instance,\n    instances: [instance],\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n  };\n\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\n\n  if (!referencedSeriesSequence) {\n    console.error('ReferencedSeriesSequence is missing for the SEG');\n    return;\n  }\n\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\n\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n\n  displaySet.getReferenceDisplaySet = () => {\n    const { displaySetService } = servicesManager.services;\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\n      displaySet.referencedSeriesInstanceUID\n    );\n\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\n      throw new Error('Referenced DisplaySet is missing for the SEG');\n    }\n\n    const referencedDisplaySet = referencedDisplaySets[0];\n\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\n\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\n    displaySet.referencedVolumeId = referencedVolumeId;\n\n    return referencedDisplaySet;\n  };\n\n  displaySet.load = async ({ headers }) =>\n    await _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(segDisplaySet, servicesManager, extensionManager, headers) {\n  const { SOPInstanceUID } = segDisplaySet;\n  const { segmentationService } = servicesManager.services;\n\n  if (\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExists(segDisplaySet, segmentationService)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  segDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\n      await _loadSegments({\n        extensionManager,\n        servicesManager,\n        segDisplaySet,\n        headers,\n      });\n    }\n\n    const suppressEvents = true;\n    segmentationService\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\n      .then(() => {\n        segDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        segDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nasync function _loadSegments({ extensionManager, servicesManager, segDisplaySet, headers }) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  const { segmentationService, uiNotificationService, displaySetService } =\n    servicesManager.services;\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n    segDisplaySet.referencedDisplaySetInstanceUID\n  );\n  let imageIds;\n\n  if (referencedDisplaySet.isReconstructable) {\n    const cachedReferencedVolume = cache.getVolume(segDisplaySet.referencedVolumeId);\n    imageIds = cachedReferencedVolume.imageIds || cachedReferencedVolume._imageIds;\n  } else {\n    imageIds = referencedDisplaySet.instances.map(instance => instance.imageId);\n  }\n\n  // Todo: what should be defaults here\n  const tolerance = 0.001;\n  const skipOverlapping = true;\n\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\n    const { percentComplete } = evt.detail;\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\n      percentComplete,\n    });\n  });\n\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.generateToolState(\n    imageIds,\n    arrayBuffer,\n    metaData,\n    { skipOverlapping, tolerance, eventTarget, triggerEvent }\n  );\n\n  let usedRecommendedDisplayCIELabValue = true;\n  results.segMetadata.data.forEach((data, i) => {\n    if (i > 0) {\n      data.rgba = data.RecommendedDisplayCIELabValue;\n\n      if (data.rgba) {\n        data.rgba = dicomlabToRGB(data.rgba);\n      } else {\n        usedRecommendedDisplayCIELabValue = false;\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\n      }\n    }\n  });\n\n  /* Skip the warning message as it is annoying on auto segmentations loading.\n  if (!usedRecommendedDisplayCIELabValue) {\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\n    uiNotificationService.show({\n      title: 'DICOM SEG import',\n      message:\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\n      type: 'warning',\n      duration: 5000,\n    });\n  }*/\n\n  Object.assign(segDisplaySet, results);\n}\n\nfunction _segmentationExists(segDisplaySet, segmentationService) {\n  // This should be abstracted with the CornerstoneCacheService\n  return segmentationService.getSegmentation(segDisplaySet.displaySetInstanceUID);\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\n  };\n\n  return [\n    {\n      name: 'dicom-seg',\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import dcmjs from 'dcmjs';\n\n/**\n * Converts a CIELAB color to an RGB color using the dcmjs library.\n * @param cielab - The CIELAB color to convert.\n * @returns The RGB color as an array of three integers between 0 and 255.\n */\nfunction dicomlabToRGB(cielab: number[]): number[] {\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n\n  return rgb;\n}\n\nexport { dicomlabToRGB };\n","import { Types } from '@ohif/core';\n\nconst segProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/seg',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  name: 'Segmentations',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'segDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    segDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SEG',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'Segmentations',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'segDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: segProtocol.id,\n      protocol: segProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { segProtocol };\n","import React from 'react';\nimport { Input, Dialog, ButtonEnums } from '@ohif/ui';\n\nfunction callInputDialog(uiDialogService, label, callback) {\n  const dialogId = 'enter-segment-label';\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        callback(value.label, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Segment',\n        value: { label },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: ButtonEnums.type.secondary },\n          { id: 'save', text: 'Confirm', type: ButtonEnums.type.primary },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          return (\n            <Input\n              label=\"Enter the segment label\"\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              autoFocus\n              className=\"border-primary-main bg-black\"\n              type=\"text\"\n              value={value.label}\n              onChange={event => {\n                event.persist();\n                setValue(value => ({ ...value, label: event.target.value }));\n              }}\n              onKeyPress={event => {\n                if (event.key === 'Enter') {\n                  onSubmitHandler({ value, action: { id: 'save' } });\n                }\n              }}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callInputDialog;\n","import React from 'react';\nimport { Dialog } from '@ohif/ui';\nimport { ChromePicker } from 'react-color';\n\nimport './colorPickerDialog.css';\n\nfunction callColorPickerDialog(uiDialogService, rgbaColor, callback) {\n  const dialogId = 'pick-color';\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        callback(value.rgbaColor, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Segment Color',\n        value: { rgbaColor },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Save', type: 'secondary' },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          const handleChange = color => {\n            setValue({ rgbaColor: color.rgb });\n          };\n\n          return (\n            <ChromePicker\n              color={value.rgbaColor}\n              onChange={handleChange}\n              presetColors={[]}\n              width={300}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callColorPickerDialog;\n","const getSegmentLabel = (segmentation): string => {\n  const segmentationName = segmentation.label.includes('Vessel') ? 'Vessel' : 'Segment';\n  const segmentCount = segmentation.segments.filter(segment => segment).length;\n\n  return segmentationName + ' ' + (segmentCount + 1);\n};\n\nexport default getSegmentLabel;\n","export function updateSegmentationLabels(segmentations, displaySetService) {\n  return segmentations.map(segmentation => {\n    const displaySet = displaySetService.getDisplaySetByUID(segmentation.displaySetInstanceUID);\n\n    let referencedDisplaySet;\n    if (displaySet.Modality === 'SEG') {\n      referencedDisplaySet = displaySetService.getDisplaySetByUID(\n        displaySet.referencedDisplaySetInstanceUID\n      );\n    } else {\n      // In case of newly created segmentations, displaySetInstanceUID in the segmentation is of the referenced displaySet.\n      referencedDisplaySet = displaySet;\n    }\n\n    const { ViewPosition, ImageLaterality } = referencedDisplaySet.instance;\n\n    return {\n      ...segmentation,\n      ...(ImageLaterality &&\n        ViewPosition && {\n          label: segmentation.label.replace(\n            /^.* - Vessel/,\n            `${ImageLaterality} ${ViewPosition} - Vessel`\n          ),\n        }),\n    };\n  });\n}\n","import { createReportAsync } from '@ohif/extension-default';\nimport React, { useEffect, useState, useCallback, useReducer } from 'react';\nimport PropTypes from 'prop-types';\nimport { SegmentationGroupTable, LegacyButtonGroup, LegacyButton } from '@ohif/ui';\n\nimport callInputDialog from './callInputDialog';\nimport callColorPickerDialog from './colorPickerDialog';\nimport { useTranslation } from 'react-i18next';\nimport getSegmentLabel from '../utils/getSegmentLabel';\nimport { updateSegmentationLabels } from '../utils/updateSegmentationLabels';\n\nconst savedStatusReducer = (state, action) => {\n  return {\n    ...state,\n    ...action.payload,\n  };\n};\n\nconst SAVED_STATUS_ICON = {\n  SAVED: 'notifications-success',\n  MODIFIED: 'notifications-warning',\n  ERROR: 'notifications-error',\n};\n\nexport default function PanelSegmentation({\n  servicesManager,\n  commandsManager,\n  extensionManager,\n  configuration,\n}) {\n  const {\n    segmentationService,\n    viewportGridService,\n    uiDialogService,\n    displaySetService,\n    userAuthenticationService,\n    CropDisplayAreaService,\n  } = servicesManager.services;\n\n  const { t } = useTranslation('PanelSegmentation');\n\n  const [selectedSegmentationId, setSelectedSegmentationId] = useState(null);\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\n    segmentationService.getConfiguration()\n  );\n\n  const [segmentations, setSegmentations] = useState(() =>\n    updateSegmentationLabels(segmentationService.getSegmentations(), displaySetService)\n  );\n  const [savedStatusStates, dispatch] = useReducer(savedStatusReducer, {});\n\n  useEffect(() => {\n    // ~~ Subscription\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\n    const subscriptions = [];\n\n    [added, updated, removed].forEach(evt => {\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\n        const segmentations = segmentationService.getSegmentations();\n        const updatedSegmentations = updateSegmentationLabels(segmentations, displaySetService);\n        setSegmentations(updatedSegmentations);\n        setSegmentationConfiguration(segmentationService.getConfiguration());\n      });\n      subscriptions.push(unsubscribe);\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, []);\n\n  useEffect(() => {\n    let changedSegmentations: any[] = [],\n      timerId;\n    const timoutInSeconds = 5;\n\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENTATION_DATA_MODIFIED,\n      ({ segmentation }) => {\n        clearTimeout(timerId);\n        dispatch({ payload: { [segmentation.id]: SAVED_STATUS_ICON.MODIFIED } });\n\n        if (\n          !changedSegmentations.find(\n            changedSegmentation => changedSegmentation.id === segmentation.id\n          )\n        ) {\n          changedSegmentations.push(segmentation);\n        }\n\n        timerId = setTimeout(() => {\n          const datasources = extensionManager.getActiveDataSource();\n\n          const promises = changedSegmentations.map(segmentation =>\n            createReportAsync({\n              servicesManager: servicesManager,\n              getReport: () =>\n                commandsManager.runCommand('storeSegmentation', {\n                  segmentationId: segmentation.id,\n                  dataSource: datasources[0],\n                  skipLabelDialog: true,\n                }),\n              reportType: 'Segmentation',\n              showLoadingModal: false,\n              throwErrors: true,\n            })\n          );\n\n          Promise.allSettled(promises).then(results => {\n            const payload = results.reduce((acc, result, index) => {\n              if (result.value) {\n                changedSegmentations[index].displaySetInstanceUID = result.value[0];\n                displaySetService.getDisplaySetByUID(result.value[0])?.getReferenceDisplaySet();\n              }\n\n              return {\n                ...acc,\n                [changedSegmentations[index].id]:\n                  result.status === 'fulfilled' ? SAVED_STATUS_ICON.SAVED : SAVED_STATUS_ICON.ERROR,\n              };\n            }, {});\n\n            dispatch({ payload });\n\n            const savedSegmentations = Object.keys(payload).filter(\n              id => payload[id] === SAVED_STATUS_ICON.SAVED\n            );\n            changedSegmentations = changedSegmentations.filter(\n              cs => !savedSegmentations.includes(cs.id)\n            );\n          });\n        }, timoutInSeconds * 1000);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  const setSegmentationActive = segmentationId => {\n    setReferencedDisplaySet(segmentationId);\n\n    const isSegmentationActive = segmentations.find(seg => seg.id === segmentationId)?.isActive;\n\n    if (isSegmentationActive) {\n      return;\n    }\n\n    segmentationService.setActiveSegmentationForToolGroup(segmentationId);\n  };\n\n  // Set referenced displaySet of the segmentation to the viewport\n  // if it is not displayed in any of the viewports.\n  const setReferencedDisplaySet = segmentationId => {\n    const segDisplayset = displaySetService.getDisplaySetByUID(segmentationId);\n    if (!segDisplayset) {\n      return;\n    }\n\n    const referencedDisplaySetInstanceUID = segDisplayset.referencedDisplaySetInstanceUID;\n    const { viewports, activeViewportId } = viewportGridService.getState();\n    let referencedImageLoaded = false;\n    viewports.forEach(viewport => {\n      if (viewport.displaySetInstanceUIDs.includes(referencedDisplaySetInstanceUID)) {\n        referencedImageLoaded = true;\n      }\n    });\n\n    if (!referencedImageLoaded) {\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetInstanceUID],\n      });\n    }\n  };\n\n  const getToolGroupIds = segmentationId => {\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(segmentationId);\n\n    return toolGroupIds;\n  };\n\n  const onSegmentationAdd = async () => {\n    commandsManager.runCommand('createEmptySegmentationForViewport');\n  };\n\n  const onSegmentationClick = (segmentationId: string) => {\n    setReferencedDisplaySet(segmentationId);\n    segmentationService.setActiveSegmentationForToolGroup(segmentationId);\n  };\n\n  const onSegmentationDelete = (segmentationId: string) => {\n    setSegmentationActive(segmentationId);\n    segmentationService.remove(segmentationId);\n  };\n\n  const onSegmentAdd = segmentationId => {\n    setSegmentationActive(segmentationId);\n    const label = getSegmentLabel(segmentations.find(seg => seg.id === segmentationId));\n    segmentationService.addSegment(segmentationId, { properties: { label } });\n  };\n\n  const onSegmentClick = (segmentationId, segmentIndex) => {\n    setReferencedDisplaySet(segmentationId);\n    segmentationService.setActiveSegment(segmentationId, segmentIndex);\n\n    const toolGroupIds = getToolGroupIds(segmentationId);\n\n    toolGroupIds.forEach(toolGroupId => {\n      segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\n      segmentationService.jumpToSegmentCenter(segmentationId, segmentIndex, toolGroupId);\n    });\n  };\n\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\n    setSegmentationActive(segmentationId);\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n\n    const segment = segmentation.segments[segmentIndex];\n    const { label } = segment;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.setSegmentLabel(segmentationId, segmentIndex, label);\n    });\n  };\n\n  const onSegmentationEdit = segmentationId => {\n    setSegmentationActive(segmentationId);\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const { label } = segmentation;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.addOrUpdateSegmentation(\n        {\n          id: segmentationId,\n          label,\n        },\n        false, // suppress event\n        true // notYetUpdatedAtSource\n      );\n    });\n  };\n\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\n    setSegmentationActive(segmentationId);\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n\n    const segment = segmentation.segments[segmentIndex];\n    const { color, opacity } = segment;\n\n    const rgbaColor = {\n      r: color[0],\n      g: color[1],\n      b: color[2],\n      a: opacity / 255.0,\n    };\n\n    callColorPickerDialog(uiDialogService, rgbaColor, (newRgbaColor, actionId) => {\n      if (actionId === 'cancel') {\n        return;\n      }\n\n      segmentationService.setSegmentRGBAColor(segmentationId, segmentIndex, [\n        newRgbaColor.r,\n        newRgbaColor.g,\n        newRgbaColor.b,\n        newRgbaColor.a * 255.0,\n      ]);\n    });\n  };\n\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\n    setSegmentationActive(segmentationId);\n    segmentationService.removeSegment(segmentationId, segmentIndex);\n  };\n\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\n    setSegmentationActive(segmentationId);\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const segmentInfo = segmentation.segments[segmentIndex];\n    const isVisible = !segmentInfo.isVisible;\n    const toolGroupIds = getToolGroupIds(segmentationId);\n\n    // Todo: right now we apply the visibility to all tool groups\n    toolGroupIds.forEach(toolGroupId => {\n      segmentationService.setSegmentVisibility(\n        segmentationId,\n        segmentIndex,\n        isVisible,\n        toolGroupId\n      );\n    });\n  };\n\n  const onToggleSegmentLock = (segmentationId, segmentIndex) => {\n    setSegmentationActive(segmentationId);\n    segmentationService.toggleSegmentLocked(segmentationId, segmentIndex);\n  };\n\n  const onToggleSegmentationVisibility = segmentationId => {\n    setSegmentationActive(segmentationId);\n    segmentationService.toggleSegmentationVisibility(segmentationId);\n  };\n\n  const _setSegmentationConfiguration = useCallback(\n    (segmentationId, key, value) => {\n      segmentationService.setConfiguration({\n        segmentationId,\n        [key]: value,\n      });\n    },\n    [segmentationService]\n  );\n\n  const onSegmentationDownload = segmentationId => {\n    setSegmentationActive(segmentationId);\n    commandsManager.runCommand('downloadSegmentation', {\n      segmentationId,\n    });\n  };\n\n  const storeSegmentation = async segmentationId => {\n    setSegmentationActive(segmentationId);\n    const datasources = extensionManager.getActiveDataSource();\n    let displaySetInstanceUIDs;\n\n    try {\n      displaySetInstanceUIDs = await createReportAsync({\n        servicesManager,\n        getReport: () =>\n          commandsManager.runCommand('storeSegmentation', {\n            segmentationId,\n            dataSource: datasources[0],\n          }),\n        reportType: 'Segmentation',\n        throwErrors: true,\n      });\n\n      dispatch({ payload: { [segmentationId]: SAVED_STATUS_ICON.SAVED } });\n    } catch (error) {\n      console.warn(error.message);\n      dispatch({ payload: { [segmentationId]: SAVED_STATUS_ICON.ERROR } });\n    }\n\n    // Show the exported report in the active viewport as read only (similar to SR)\n    if (displaySetInstanceUIDs) {\n      // clear the segmentation that we exported, similar to the storeMeasurement\n      // where we remove the measurements and prompt again the user if they would like\n      // to re-read the measurements in a SR read only viewport\n      segmentationService.remove(segmentationId);\n\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: viewportGridService.getActiveViewportId(),\n        displaySetInstanceUIDs,\n      });\n    }\n  };\n\n  const onSegmentationDownloadRTSS = segmentationId => {\n    setSegmentationActive(segmentationId);\n    commandsManager.runCommand('downloadRTSS', {\n      segmentationId,\n    });\n  };\n\n  return (\n    <>\n      <div className=\"ohif-scrollbar flex min-h-0 flex-auto select-none flex-col justify-between overflow-auto\">\n        <SegmentationGroupTable\n          title={t('Segmentations')}\n          segmentations={segmentations}\n          savedStatusStates={savedStatusStates}\n          disableEditing={configuration.disableEditing}\n          activeSegmentationId={selectedSegmentationId || ''}\n          onSegmentationAdd={onSegmentationAdd}\n          onSegmentationClick={onSegmentationClick}\n          onSegmentationDelete={onSegmentationDelete}\n          onSegmentationDownload={onSegmentationDownload}\n          onSegmentationDownloadRTSS={onSegmentationDownloadRTSS}\n          storeSegmentation={storeSegmentation}\n          onSegmentationEdit={onSegmentationEdit}\n          onSegmentClick={onSegmentClick}\n          onSegmentEdit={onSegmentEdit}\n          onSegmentAdd={onSegmentAdd}\n          onSegmentColorClick={onSegmentColorClick}\n          onSegmentDelete={onSegmentDelete}\n          onToggleSegmentVisibility={onToggleSegmentVisibility}\n          onToggleSegmentLock={onToggleSegmentLock}\n          onToggleSegmentationVisibility={onToggleSegmentationVisibility}\n          showDeleteSegment={true}\n          segmentationConfig={{ initialConfig: segmentationConfiguration }}\n          setRenderOutline={value =>\n            _setSegmentationConfiguration(selectedSegmentationId, 'renderOutline', value)\n          }\n          setOutlineOpacityActive={value =>\n            _setSegmentationConfiguration(selectedSegmentationId, 'outlineOpacity', value)\n          }\n          setRenderFill={value =>\n            _setSegmentationConfiguration(selectedSegmentationId, 'renderFill', value)\n          }\n          setRenderInactiveSegmentations={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderInactiveSegmentations',\n              value\n            )\n          }\n          setOutlineWidthActive={value =>\n            _setSegmentationConfiguration(selectedSegmentationId, 'outlineWidthActive', value)\n          }\n          setFillAlpha={value =>\n            _setSegmentationConfiguration(selectedSegmentationId, 'fillAlpha', value)\n          }\n          setFillAlphaInactive={value =>\n            _setSegmentationConfiguration(selectedSegmentationId, 'fillAlphaInactive', value)\n          }\n          CropDisplayAreaService={CropDisplayAreaService}\n        />\n      </div>\n    </>\n  );\n}\n\nPanelSegmentation.propTypes = {\n  commandsManager: PropTypes.shape({\n    runCommand: PropTypes.func.isRequired,\n  }),\n  servicesManager: PropTypes.shape({\n    services: PropTypes.shape({\n      segmentationService: PropTypes.shape({\n        getSegmentation: PropTypes.func.isRequired,\n        getSegmentations: PropTypes.func.isRequired,\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\n        subscribe: PropTypes.func.isRequired,\n        EVENTS: PropTypes.object.isRequired,\n      }).isRequired,\n    }).isRequired,\n  }).isRequired,\n};\n","import React, { useCallback, useEffect, useState, useReducer } from 'react';\nimport { AdvancedToolbox, InputDoubleRange, useViewportGrid } from '@ohif/ui';\nimport { Types } from '@ohif/extension-cornerstone';\nimport { utilities } from '@cornerstonejs/tools';\nimport { EVENTS, eventTarget } from '@cornerstonejs/core';\n\nconst { segmentation: segmentationUtils } = utilities;\n\nconst TOOL_TYPES = {\n  CIRCULAR_BRUSH: 'CircularBrush',\n  SPHERE_BRUSH: 'SphereBrush',\n  CIRCULAR_ERASER: 'CircularEraser',\n  SPHERE_ERASER: 'SphereEraser',\n  CIRCLE_SHAPE: 'CircleScissor',\n  RECTANGLE_SHAPE: 'RectangleScissor',\n  SPHERE_SHAPE: 'SphereScissor',\n  THRESHOLD_CIRCULAR_BRUSH: 'ThresholdCircularBrush',\n  THRESHOLD_SPHERE_BRUSH: 'ThresholdSphereBrush',\n};\n\nconst ACTIONS = {\n  SET_TOOL_CONFIG: 'SET_TOOL_CONFIG',\n  SET_ACTIVE_TOOL: 'SET_ACTIVE_TOOL',\n};\n\nconst initialState = {\n  Brush: {\n    brushSize: 2,\n    mode: 'CircularBrush', // Can be 'CircularBrush' or 'SphereBrush'\n  },\n  Eraser: {\n    brushSize: 2,\n    mode: 'CircularEraser', // Can be 'CircularEraser' or 'SphereEraser'\n  },\n  Shapes: {\n    brushSize: 15,\n    mode: 'CircleScissor', // E.g., 'CircleScissor', 'RectangleScissor', or 'SphereScissor'\n  },\n  ThresholdBrush: {\n    brushSize: 15,\n    thresholdRange: [-500, 500],\n  },\n  activeTool: null,\n};\n\nfunction toolboxReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.SET_TOOL_CONFIG:\n      const { tool, config } = action.payload;\n      return {\n        ...state,\n        [tool]: {\n          ...state[tool],\n          ...config,\n        },\n      };\n    case ACTIONS.SET_ACTIVE_TOOL:\n      return { ...state, activeTool: action.payload };\n    default:\n      return state;\n  }\n}\n\nfunction SegmentationToolbox({ servicesManager, extensionManager }) {\n  const { toolbarService, segmentationService, toolGroupService } =\n    servicesManager.services as Types.CornerstoneServices;\n\n  const [viewportGrid] = useViewportGrid();\n  const { viewports, activeViewportId } = viewportGrid;\n\n  const [toolsEnabled, setToolsEnabled] = useState(false);\n  const [state, dispatch] = useReducer(toolboxReducer, initialState);\n  const [brushProperties, setBrushProperties] = useState({ min: 2, max: 3, step: 0.01 });\n\n  const updateActiveTool = useCallback(() => {\n    if (!viewports?.size || activeViewportId === undefined) {\n      return;\n    }\n    const viewport = viewports.get(activeViewportId);\n\n    if (!viewport) {\n      return;\n    }\n\n    dispatch({\n      type: ACTIONS.SET_ACTIVE_TOOL,\n      payload: toolGroupService.getActiveToolForViewport(viewport.viewportId),\n    });\n  }, [activeViewportId, viewports, toolGroupService, dispatch]);\n\n  const setToolActive = useCallback(\n    toolName => {\n      toolbarService.recordInteraction({\n        interactionType: 'tool',\n        commands: [\n          {\n            commandName: 'setToolActive',\n            commandOptions: {\n              toolName,\n            },\n          },\n        ],\n      });\n\n      dispatch({ type: ACTIONS.SET_ACTIVE_TOOL, payload: toolName });\n    },\n    [toolbarService, dispatch]\n  );\n\n  const setBrushSizesFromParams = () => {\n    const params = new URLSearchParams(window.location.search);\n    const toolCategories = ['Brush', 'Eraser'];\n    const defaultBrushSizeInMm = +params.get('defaultBrushSize') || 2;\n    let minBrushSizeInMm = +params.get('minBrushSize') || 2;\n    let maxBrushSizeInMm = +params.get('maxBrushSize') || 3;\n\n    const highestPixelSpacing = getPixelToMmConversionFactor(servicesManager);\n    const lowestBrushRadius = highestPixelSpacing / 2;\n\n    if (minBrushSizeInMm < lowestBrushRadius) {\n      minBrushSizeInMm = lowestBrushRadius;\n    }\n    if (maxBrushSizeInMm < lowestBrushRadius) {\n      maxBrushSizeInMm = highestPixelSpacing;\n    }\n\n    setBrushProperties({\n      min: +minBrushSizeInMm.toFixed(2),\n      max: +maxBrushSizeInMm.toFixed(2),\n      step: +((maxBrushSizeInMm - minBrushSizeInMm) / 100).toFixed(2),\n    });\n    toolCategories.forEach(toolCategory => {\n      onBrushSizeChange(defaultBrushSizeInMm, toolCategory);\n    });\n  };\n\n  useEffect(() => {\n    if (getPixelToMmConversionFactor(servicesManager)) {\n      setBrushSizesFromParams();\n      return;\n    }\n\n    const elementEnabledHandler = evt => {\n      const setDefaultBrushSize = () => {\n        setBrushSizesFromParams();\n\n        evt.detail.element.removeEventListener(\n          EVENTS.VOLUME_VIEWPORT_NEW_VOLUME,\n          setDefaultBrushSize\n        );\n        eventTarget.removeEventListener(EVENTS.STACK_VIEWPORT_NEW_STACK, setDefaultBrushSize);\n      };\n\n      evt.detail.element.addEventListener(EVENTS.VOLUME_VIEWPORT_NEW_VOLUME, setDefaultBrushSize);\n      eventTarget.addEventListener(EVENTS.STACK_VIEWPORT_NEW_STACK, setDefaultBrushSize);\n      eventTarget.removeEventListener(EVENTS.ELEMENT_ENABLED, elementEnabledHandler);\n    };\n\n    const viewportElement = getActiveViewportElement(servicesManager, extensionManager);\n    if (viewportElement) {\n      elementEnabledHandler({ detail: { element: viewportElement } });\n      return;\n    }\n\n    eventTarget.addEventListener(EVENTS.ELEMENT_ENABLED, elementEnabledHandler);\n  }, []);\n\n  /**\n   * sets the tools enabled IF there are segmentations\n   */\n  useEffect(() => {\n    const events = [\n      segmentationService.EVENTS.SEGMENTATION_ADDED,\n      segmentationService.EVENTS.SEGMENTATION_UPDATED,\n      segmentationService.EVENTS.SEGMENTATION_REMOVED,\n    ];\n\n    const unsubscriptions = [];\n\n    events.forEach(event => {\n      const { unsubscribe } = segmentationService.subscribe(event, () => {\n        const segmentations = segmentationService.getSegmentations();\n\n        const activeSegmentation = segmentations?.find(seg => seg.isActive);\n\n        setToolsEnabled(activeSegmentation?.segmentCount > 0);\n      });\n\n      unsubscriptions.push(unsubscribe);\n    });\n\n    updateActiveTool();\n\n    return () => {\n      unsubscriptions.forEach(unsubscribe => unsubscribe());\n    };\n  }, [activeViewportId, viewports, segmentationService, updateActiveTool]);\n\n  /**\n   * Update the active tool when the toolbar state changes\n   */\n  useEffect(() => {\n    const { unsubscribe } = toolbarService.subscribe(\n      toolbarService.EVENTS.TOOL_BAR_STATE_MODIFIED,\n      () => {\n        updateActiveTool();\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [toolbarService, updateActiveTool]);\n\n  useEffect(() => {\n    // if the active tool is not a brush tool then do nothing\n    if (!Object.values(TOOL_TYPES).includes(state.activeTool)) {\n      return;\n    }\n\n    // if the tool is Segmentation and it is enabled then do nothing\n    if (toolsEnabled) {\n      return;\n    }\n\n    // if the tool is Segmentation and it is disabled, then switch\n    // back to the window level tool to not confuse the user when no\n    // segmentation is active or when there is no segment in the segmentation\n    setToolActive('WindowLevel');\n  }, [toolsEnabled, state.activeTool, setToolActive]);\n\n  const updateBrushSize = useCallback(\n    (toolName, brushSize) => {\n      toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\n        segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize, toolName);\n      });\n    },\n    [toolGroupService]\n  );\n\n  const onBrushSizeChange = useCallback(\n    (valueAsStringOrNumber, toolCategory) => {\n      const value = Number(valueAsStringOrNumber);\n\n      _getToolNamesFromCategory(toolCategory).forEach(toolName => {\n        updateBrushSize(toolName, value);\n      });\n\n      dispatch({\n        type: ACTIONS.SET_TOOL_CONFIG,\n        payload: {\n          tool: toolCategory,\n          config: { brushSize: value },\n        },\n      });\n    },\n    [toolGroupService, dispatch]\n  );\n\n  const handleRangeChange = useCallback(\n    newRange => {\n      if (\n        newRange[0] === state.ThresholdBrush.thresholdRange[0] &&\n        newRange[1] === state.ThresholdBrush.thresholdRange[1]\n      ) {\n        return;\n      }\n\n      const toolNames = _getToolNamesFromCategory('ThresholdBrush');\n\n      toolNames.forEach(toolName => {\n        toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\n          const toolGroup = toolGroupService.getToolGroup(toolGroupId);\n          toolGroup.setToolConfiguration(toolName, {\n            strategySpecificConfiguration: {\n              THRESHOLD_INSIDE_CIRCLE: {\n                threshold: newRange,\n              },\n            },\n          });\n        });\n      });\n\n      dispatch({\n        type: ACTIONS.SET_TOOL_CONFIG,\n        payload: {\n          tool: 'ThresholdBrush',\n          config: { thresholdRange: newRange },\n        },\n      });\n    },\n    [toolGroupService, dispatch, state.ThresholdBrush.thresholdRange]\n  );\n\n  return (\n    <AdvancedToolbox\n      title=\"Segmentation Tools\"\n      items={[\n        {\n          name: 'Brush',\n          icon: 'icon-tool-brush',\n          disabled: !toolsEnabled,\n          active:\n            state.activeTool === TOOL_TYPES.CIRCULAR_BRUSH ||\n            state.activeTool === TOOL_TYPES.SPHERE_BRUSH,\n          onClick: () => setToolActive(TOOL_TYPES.CIRCULAR_BRUSH),\n          options: [\n            {\n              name: 'Radius (mm)',\n              id: 'brush-radius',\n              type: 'range',\n              min: brushProperties.min,\n              max: brushProperties.max,\n              value: state.Brush.brushSize,\n              step: brushProperties.step,\n              onChange: value => onBrushSizeChange(value, 'Brush'),\n            },\n            {\n              name: 'Mode',\n              type: 'radio',\n              id: 'brush-mode',\n              value: state.Brush.mode,\n              values: [\n                { value: TOOL_TYPES.CIRCULAR_BRUSH, label: 'Circle' },\n                { value: TOOL_TYPES.SPHERE_BRUSH, label: 'Sphere' },\n              ],\n              onChange: value => setToolActive(value),\n            },\n          ],\n        },\n        {\n          name: 'Eraser',\n          icon: 'icon-tool-eraser',\n          disabled: !toolsEnabled,\n          active:\n            state.activeTool === TOOL_TYPES.CIRCULAR_ERASER ||\n            state.activeTool === TOOL_TYPES.SPHERE_ERASER,\n          onClick: () => setToolActive(TOOL_TYPES.CIRCULAR_ERASER),\n          options: [\n            {\n              name: 'Radius (mm)',\n              type: 'range',\n              id: 'eraser-radius',\n              min: brushProperties.min,\n              max: brushProperties.max,\n              value: state.Eraser.brushSize,\n              step: brushProperties.step,\n              onChange: value => onBrushSizeChange(value, 'Eraser'),\n            },\n            {\n              name: 'Mode',\n              type: 'radio',\n              id: 'eraser-mode',\n              value: state.Eraser.mode,\n              values: [\n                { value: TOOL_TYPES.CIRCULAR_ERASER, label: 'Circle' },\n                { value: TOOL_TYPES.SPHERE_ERASER, label: 'Sphere' },\n              ],\n              onChange: value => setToolActive(value),\n            },\n          ],\n        },\n        {\n          name: 'Shapes',\n          icon: 'icon-tool-shape',\n          disabled: !toolsEnabled,\n          active:\n            state.activeTool === TOOL_TYPES.CIRCLE_SHAPE ||\n            state.activeTool === TOOL_TYPES.RECTANGLE_SHAPE ||\n            state.activeTool === TOOL_TYPES.SPHERE_SHAPE,\n          onClick: () => setToolActive(TOOL_TYPES.CIRCLE_SHAPE),\n          options: [\n            {\n              name: 'Mode',\n              type: 'radio',\n              value: state.Shapes.mode,\n              id: 'shape-mode',\n              values: [\n                { value: TOOL_TYPES.CIRCLE_SHAPE, label: 'Circle' },\n                { value: TOOL_TYPES.RECTANGLE_SHAPE, label: 'Rectangle' },\n                { value: TOOL_TYPES.SPHERE_SHAPE, label: 'Sphere' },\n              ],\n              onChange: value => setToolActive(value),\n            },\n          ],\n        },\n        {\n          name: 'Threshold Tool',\n          icon: 'icon-tool-threshold',\n          disabled: !toolsEnabled,\n          active:\n            state.activeTool === TOOL_TYPES.THRESHOLD_CIRCULAR_BRUSH ||\n            state.activeTool === TOOL_TYPES.THRESHOLD_SPHERE_BRUSH,\n          onClick: () => setToolActive(TOOL_TYPES.THRESHOLD_CIRCULAR_BRUSH),\n          options: [\n            {\n              name: 'Radius (mm)',\n              id: 'threshold-radius',\n              type: 'range',\n              min: 0.5,\n              max: 99.5,\n              value: state.ThresholdBrush.brushSize,\n              step: 0.5,\n              onChange: value => onBrushSizeChange(value, 'ThresholdBrush'),\n            },\n            {\n              name: 'Mode',\n              type: 'radio',\n              id: 'threshold-mode',\n              value: state.activeTool,\n              values: [\n                { value: TOOL_TYPES.THRESHOLD_CIRCULAR_BRUSH, label: 'Circle' },\n                { value: TOOL_TYPES.THRESHOLD_SPHERE_BRUSH, label: 'Sphere' },\n              ],\n              onChange: value => setToolActive(value),\n            },\n            {\n              type: 'custom',\n              id: 'segmentation-threshold-range',\n              children: () => {\n                return (\n                  <div>\n                    <div className=\"bg-secondary-light h-[1px]\"></div>\n                    <div className=\"mt-1 text-[13px] text-white\">Threshold</div>\n                    <InputDoubleRange\n                      values={state.ThresholdBrush.thresholdRange}\n                      onChange={handleRangeChange}\n                      minValue={-1000}\n                      maxValue={1000}\n                      step={1}\n                      showLabel={true}\n                      allowNumberEdit={true}\n                      showAdjustmentArrows={false}\n                    />\n                  </div>\n                );\n              },\n            },\n          ],\n        },\n      ]}\n    />\n  );\n}\n\nfunction _getToolNamesFromCategory(category) {\n  let toolNames = [];\n  switch (category) {\n    case 'Brush':\n      toolNames = ['CircularBrush', 'SphereBrush'];\n      break;\n    case 'Eraser':\n      toolNames = ['CircularEraser', 'SphereEraser'];\n      break;\n    case 'ThresholdBrush':\n      toolNames = ['ThresholdCircularBrush', 'ThresholdSphereBrush'];\n      break;\n    default:\n      break;\n  }\n\n  return toolNames;\n}\n\nfunction getPixelToMmConversionFactor(servicesManager) {\n  const { viewportGridService, cornerstoneViewportService } = servicesManager.services;\n  const { activeViewportId } = viewportGridService.getState();\n  const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);\n  const imageData = viewport?.getImageData();\n\n  if (!imageData) {\n    return;\n  }\n\n  const { spacing } = imageData;\n  return Math.max(spacing[0], spacing[1]);\n}\n\nfunction getActiveViewportElement(servicesManager, extensionManager) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n  const { getEnabledElement } = utilityModule.exports;\n  const { viewportGridService } = servicesManager.services;\n\n  const { activeViewportId } = viewportGridService.getState();\n  const { element } = getEnabledElement(activeViewportId) || {};\n  return element;\n}\n\nexport default SegmentationToolbox;\n","import React from 'react';\n\nimport { useAppConfig } from '@state';\nimport PanelSegmentation from './panels/PanelSegmentation';\nimport SegmentationToolbox from './panels/SegmentationToolbox';\n\nconst getPanelModule = ({ commandsManager, servicesManager, extensionManager, configuration }) => {\n  const { customizationService } = servicesManager.services;\n\n  const wrappedPanelSegmentation = configuration => {\n    const [appConfig] = useAppConfig();\n\n    const disableEditingForMode = customizationService.get('segmentation.disableEditing');\n\n    return (\n      <PanelSegmentation\n        commandsManager={commandsManager}\n        servicesManager={servicesManager}\n        extensionManager={extensionManager}\n        configuration={{\n          ...configuration,\n          disableEditing: appConfig.disableEditing || disableEditingForMode?.value,\n        }}\n      />\n    );\n  };\n\n  const wrappedPanelSegmentationWithTools = configuration => {\n    const [appConfig] = useAppConfig();\n    return (\n      <>\n        <SegmentationToolbox\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          configuration={{\n            ...configuration,\n          }}\n        />\n        <PanelSegmentation\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          configuration={{\n            ...configuration,\n          }}\n        />\n      </>\n    );\n  };\n\n  return [\n    {\n      name: 'panelSegmentation',\n      iconName: 'tab-segmentation',\n      iconLabel: 'Segmentation',\n      label: 'Segmentation',\n      component: wrappedPanelSegmentation,\n    },\n    {\n      name: 'panelSegmentationWithTools',\n      iconName: 'tab-segmentation',\n      iconLabel: 'Segmentation',\n      label: 'Segmentation',\n      component: wrappedPanelSegmentationWithTools,\n    },\n  ];\n};\n\nexport default getPanelModule;\n","import { Enums, cache, eventTarget } from '@cornerstonejs/core';\n\n/**\n * Updates the viewports in preparation for rendering segmentations.\n * Evaluates each viewport to determine which need modifications,\n * then for those viewports, changes them to a volume type and ensures\n * they are ready for segmentation rendering.\n *\n * @param {Object} params - Parameters for the function.\n * @param params.viewportId - ID of the viewport to be updated.\n * @param params.loadFn - Function to load the segmentation data.\n * @param params.servicesManager - The services manager.\n * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\n *\n * @returns Returns true upon successful update of viewports for segmentation rendering.\n */\nasync function updateViewportsForSegmentationRendering({\n  viewportId,\n  loadFn,\n  servicesManager,\n  referencedDisplaySetInstanceUID,\n}: {\n  viewportId: string;\n  loadFn: () => Promise<string>;\n  servicesManager: any;\n  referencedDisplaySetInstanceUID?: string;\n}) {\n  const {\n    cornerstoneViewportService,\n    segmentationService,\n    viewportGridService,\n    displaySetService,\n  } = servicesManager.services;\n\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\n  const targetViewportId = viewport.viewportOptions.viewportId;\n\n  referencedDisplaySetInstanceUID =\n    referencedDisplaySetInstanceUID || viewport?.displaySetInstanceUIDs[0];\n\n  const updatedViewports = getUpdatedViewportsForSegmentation({\n    servicesManager,\n    viewportId,\n    referencedDisplaySetInstanceUID,\n  });\n\n  // create Segmentation callback which needs to be waited until\n  // the volume is created (if coming from stack)\n  const createSegmentation = async () => {\n    const segmentationId = await loadFn();\n    segmentationService.hydrateSegmentation(segmentationId);\n  };\n\n  // the reference volume that is used to draw the segmentation. so check if the\n  // volume exists in the cache (the target Viewport is already a volume viewport)\n  const volumeExists = Array.from(cache._volumeCache.keys()).some(volumeId =>\n    volumeId.includes(referencedDisplaySetInstanceUID)\n  );\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n    referencedDisplaySetInstanceUID\n  );\n\n  updatedViewports.forEach(async viewport => {\n    viewport.viewportOptions = {\n      ...viewport.viewportOptions,\n      viewportType: referencedDisplaySet.isReconstructable ? 'volume' : 'stack',\n      needsRerendering: true,\n    };\n    const viewportId = viewport.viewportId;\n\n    const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n    const prevCamera = csViewport.getCamera();\n\n    // only run the createSegmentation for the targetViewportId when volume cache is available\n    // since the rest will get handled by cornerstoneViewportService\n    if (volumeExists && viewportId === targetViewportId) {\n      await createSegmentation();\n      return;\n    }\n    // TODO: Read from _imageCache and create segmentation when applicable\n\n    const newViewportEvent = referencedDisplaySet.isReconstructable\n      ? Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME\n      : Enums.Events.STACK_VIEWPORT_NEW_STACK;\n\n    const eventTriggerer = referencedDisplaySet.isReconstructable\n      ? csViewport.element\n      : eventTarget;\n\n    const createNewSegmentationOnNewViewport = async evt => {\n      const isTheActiveViewportVolumeMounted = evt.detail.volumeActors?.find(ac =>\n        ac.uid.includes(referencedDisplaySetInstanceUID)\n      );\n\n      // Note: make sure to re-grab the viewport since it might have changed\n      // during the time it took for the volume to be mounted, for instance\n      // the stack viewport has been changed to a volume viewport\n      const volumeViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n      volumeViewport.setCamera(prevCamera);\n\n      eventTriggerer.removeEventListener(newViewportEvent, createNewSegmentationOnNewViewport);\n\n      if (referencedDisplaySet.isReconstructable && !isTheActiveViewportVolumeMounted) {\n        // it means it is one of those other updated viewports so just update the camera\n        return;\n      }\n\n      if (viewportId === targetViewportId) {\n        await createSegmentation();\n      }\n    };\n\n    eventTriggerer.addEventListener(newViewportEvent, createNewSegmentationOnNewViewport);\n  });\n\n  // Set the displaySets for the viewports that require to be updated\n  viewportGridService.setDisplaySetsForViewports(updatedViewports);\n\n  return true;\n}\n\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\n  const { viewports, activeViewportId } = viewportGridService.getState();\n  const targetViewportId = viewportId || activeViewportId;\n\n  const viewport = viewports.get(targetViewportId);\n\n  return viewport;\n};\n\n/**\n * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\n * This function evaluates viewports based on their compatibility with the provided segmentation's\n * frame of reference UID and appends them to the updated list if they should render the segmentation.\n *\n * @param {Object} params - Parameters for the function.\n * @param params.viewportId - the ID of the viewport to be updated.\n * @param params.servicesManager - The services manager\n * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\n *\n * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\n */\nfunction getUpdatedViewportsForSegmentation({\n  viewportId,\n  servicesManager,\n  referencedDisplaySetInstanceUID,\n}) {\n  const { hangingProtocolService, displaySetService, segmentationService, viewportGridService } =\n    servicesManager.services;\n\n  const { viewports } = viewportGridService.getState();\n\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\n  const targetViewportId = viewport.viewportOptions.viewportId;\n\n  const displaySetInstanceUIDs = viewports.get(targetViewportId).displaySetInstanceUIDs;\n\n  const referenceDisplaySetInstanceUID =\n    referencedDisplaySetInstanceUID || displaySetInstanceUIDs[0];\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(referenceDisplaySetInstanceUID);\n  const segmentationFrameOfReferenceUID = referencedDisplaySet.instances[0].FrameOfReferenceUID;\n\n  const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n    targetViewportId,\n    referenceDisplaySetInstanceUID\n  );\n\n  viewports.forEach((viewport, viewportId) => {\n    if (\n      targetViewportId === viewportId ||\n      updatedViewports.find(v => v.viewportId === viewportId)\n    ) {\n      return;\n    }\n\n    const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\n      viewport.displaySetInstanceUIDs,\n      segmentationFrameOfReferenceUID\n    );\n\n    if (shouldDisplaySeg) {\n      updatedViewports.push({\n        viewportId,\n        displaySetInstanceUIDs: viewport.displaySetInstanceUIDs,\n        viewportOptions: {\n          viewportType: viewport.viewportType,\n          needsRerendering: true,\n        },\n      });\n    }\n  });\n  return updatedViewports;\n}\n\nexport {\n  updateViewportsForSegmentationRendering,\n  getUpdatedViewportsForSegmentation,\n  getTargetViewport,\n};\n","import { cache } from '@cornerstonejs/core';\n\nconst generateLabelmaps2DFromImageIdMap = imageIdReferenceMap => {\n  const labelmaps2D = [],\n    referencedImages = [],\n    segmentsOnLabelmap3D = new Set();\n  Array.from(imageIdReferenceMap.entries()).forEach((entry, index) => {\n    referencedImages.push(cache.getImage(entry[0]));\n\n    const segmentationImage = cache.getImage(entry[1]);\n    const { rows, columns } = segmentationImage;\n    const pixelData = segmentationImage.getPixelData();\n    const segmentsOnLabelmap = [];\n\n    for (let i = 0; i < pixelData.length; i++) {\n      const segment = pixelData[i];\n      if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n        segmentsOnLabelmap.push(segment);\n      }\n    }\n\n    if (!segmentsOnLabelmap.length) {\n      segmentsOnLabelmap.push(1);\n    }\n\n    labelmaps2D[index] = {\n      segmentsOnLabelmap,\n      pixelData,\n      rows,\n      columns,\n    };\n\n    segmentsOnLabelmap.forEach(segmentIndex => {\n      segmentsOnLabelmap3D.add(segmentIndex);\n    });\n  });\n\n  const labelmapObj = {\n    segmentsOnLabelmap: Array.from(segmentsOnLabelmap3D),\n    labelmaps2D,\n  };\n\n  return { referencedImages, labelmapObj };\n};\n\nexport default generateLabelmaps2DFromImageIdMap;\n","import dcmjs from 'dcmjs';\nimport { createReportDialogPrompt } from '@ohif/extension-default';\nimport { ServicesManager, Types } from '@ohif/core';\nimport { cache, metaData } from '@cornerstonejs/core';\nimport {\n  segmentation as cornerstoneToolsSegmentation,\n  Enums as cornerstoneToolsEnums,\n} from '@cornerstonejs/tools';\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\nimport { classes, DicomMetadataStore } from '@ohif/core';\n\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport {\n  updateViewportsForSegmentationRendering,\n  getUpdatedViewportsForSegmentation,\n  getTargetViewport,\n} from './utils/hydrationUtils';\nimport generateLabelmaps2DFromImageIdMap from './utils/generateLabelmaps2DFromImageIdMap';\nimport getSegmentLabel from './utils/getSegmentLabel';\n\nconst { datasetToBlob } = dcmjs.data;\n\nconst {\n  Cornerstone3D: {\n    Segmentation: { generateLabelMaps2DFrom3D, generateSegmentation },\n  },\n} = adaptersSEG;\n\nconst {\n  Cornerstone3D: {\n    RTSS: { generateRTSSFromSegmentations },\n  },\n} = adaptersRT;\n\nconst { downloadDICOMData } = helpers;\n\nconst commandsModule = ({\n  servicesManager,\n  extensionManager,\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\n  const {\n    uiNotificationService,\n    segmentationService,\n    uiDialogService,\n    displaySetService,\n    viewportGridService,\n  } = (servicesManager as ServicesManager).services;\n\n  const actions = {\n    /**\n     * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\n     * This function evaluates viewports based on their compatibility with the provided segmentation's\n     * frame of reference UID and appends them to the updated list if they should render the segmentation.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.viewportId - the ID of the viewport to be updated.\n     * @param params.servicesManager - The services manager\n     * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\n     *\n     * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\n     */\n    getUpdatedViewportsForSegmentation,\n    /**\n     * Creates an empty segmentation for a specified viewport.\n     * It first checks if the display set associated with the viewport is reconstructable.\n     * If not, it raises a notification error. Otherwise, it creates a new segmentation\n     * for the display set after handling the necessary steps for making the viewport\n     * a volume viewport first\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.viewportId - the target viewport ID.\n     *\n     */\n    createEmptySegmentationForViewport: async ({ viewportId }) => {\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\n      // Todo: add support for multiple display sets\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\n\n      updateViewportsForSegmentationRendering({\n        viewportId,\n        servicesManager,\n        loadFn: async () => {\n          const currentSegmentations = segmentationService.getSegmentations();\n          const segmentationId = await segmentationService.createSegmentationForDisplaySet(\n            displaySetInstanceUID,\n            { label: `Segmentation ${currentSegmentations.length + 1}` }\n          );\n\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\n\n          await segmentationService.addSegmentationRepresentationToToolGroup(\n            toolGroupId,\n            segmentationId\n          );\n\n          // Add only one segment for now\n          segmentationService.addSegment(segmentationId, {\n            toolGroupId,\n            segmentIndex: 1,\n            properties: {\n              label: getSegmentLabel(segmentationService.getSegmentation(segmentationId)),\n            },\n          });\n\n          return segmentationId;\n        },\n      });\n    },\n    /**\n     * Loads segmentations for a specified viewport.\n     * The function prepares the viewport for rendering, then loads the segmentation details.\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentations - Array of segmentations to be loaded.\n     * @param params.viewportId - the target viewport ID.\n     *\n     */\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\n      updateViewportsForSegmentationRendering({\n        viewportId,\n        servicesManager,\n        loadFn: async () => {\n          // Todo: handle adding more than one segmentation\n          const viewport = getTargetViewport({ viewportId, viewportGridService });\n          const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\n\n          const segmentation = segmentations[0];\n          const segmentationId = segmentation.id;\n          const label = segmentation.label;\n          const segments = segmentation.segments;\n\n          delete segmentation.segments;\n\n          await segmentationService.createSegmentationForDisplaySet(displaySetInstanceUID, {\n            segmentationId,\n            label,\n          });\n\n          if (segmentation.scalarData) {\n            const labelmapVolume = segmentationService.getLabelmapVolume(segmentationId);\n            labelmapVolume.scalarData.set(segmentation.scalarData);\n          }\n\n          segmentationService.addOrUpdateSegmentation(segmentation);\n\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\n          await segmentationService.addSegmentationRepresentationToToolGroup(\n            toolGroupId,\n            segmentationId\n          );\n\n          segments.forEach(segment => {\n            if (segment === null) {\n              return;\n            }\n            segmentationService.addSegment(segmentationId, {\n              segmentIndex: segment.segmentIndex,\n              toolGroupId,\n              properties: {\n                color: segment.color,\n                label: segment.label,\n                opacity: segment.opacity,\n                isLocked: segment.isLocked,\n                visibility: segment.isVisible,\n                active: segmentation.activeSegmentIndex === segment.segmentIndex,\n              },\n            });\n          });\n\n          if (segmentation.centroidsIJK) {\n            segmentationService.setCentroids(segmentation.id, segmentation.centroidsIJK);\n          }\n\n          return segmentationId;\n        },\n      });\n    },\n    /**\n     * Loads segmentation display sets for a specified viewport.\n     * Depending on the modality of the display set (SEG or RTSTRUCT),\n     * it chooses the appropriate service function to create\n     * the segmentation for the display set.\n     * The function then prepares the viewport for rendering segmentation.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.viewportId - ID of the viewport where the segmentation display sets should be loaded.\n     * @param params.displaySets - Array of display sets to be loaded for segmentation.\n     *\n     */\n    loadSegmentationDisplaySetsForViewport: async ({ viewportId, displaySets }) => {\n      // Todo: handle adding more than one segmentation\n      const displaySet = displaySets[0];\n\n      updateViewportsForSegmentationRendering({\n        viewportId,\n        servicesManager,\n        referencedDisplaySetInstanceUID: displaySet.referencedDisplaySetInstanceUID,\n        loadFn: async () => {\n          const segDisplaySet = displaySet;\n          const suppressEvents = false;\n          const serviceFunction =\n            segDisplaySet.Modality === 'SEG'\n              ? 'createSegmentationForSEGDisplaySet'\n              : 'createSegmentationForRTDisplaySet';\n\n          const boundFn = segmentationService[serviceFunction].bind(segmentationService);\n          const segmentationId = await boundFn(segDisplaySet, null, suppressEvents);\n\n          return segmentationId;\n        },\n      });\n    },\n    /**\n     * Generates a segmentation from a given segmentation ID.\n     * This function retrieves the associated segmentation and\n     * its referenced volume, extracts label maps from the\n     * segmentation volume, and produces segmentation data\n     * alongside associated metadata.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be generated.\n     * @param params.options - Optional configuration for the generation process.\n     *\n     * @returns Returns the generated segmentation data.\n     */\n    generateSegmentation: ({ segmentationId, options = {} }) => {\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\n      const segmentationLabelmapData = segmentation.representationData.LABELMAP;\n\n      let referencedImages, labelmapObj;\n      if (segmentation.representationData.LABELMAP.referencedVolumeId) {\n        const { referencedVolumeId } = segmentationLabelmapData;\n\n        const segmentationVolume = cache.getVolume(segmentationId);\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        referencedImages = referencedVolume.getCornerstoneImages();\n\n        labelmapObj = generateLabelMaps2DFrom3D(segmentationVolume);\n      } else {\n        const { imageIdReferenceMap } = segmentationLabelmapData;\n\n        ({ referencedImages, labelmapObj } =\n          generateLabelmaps2DFromImageIdMap(imageIdReferenceMap));\n      }\n\n      // Generate fake metadata as an example\n      labelmapObj.metadata = [];\n\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      labelmapObj.segmentsOnLabelmap.forEach(segmentIndex => {\n        // segmentation service already has a color for each segment\n        const segment = segmentationInOHIF?.segments[segmentIndex];\n        const { label, color } = segment;\n\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\n          color.slice(0, 3).map(value => value / 255)\n        ).map(value => Math.round(value));\n\n        const segmentMetadata = {\n          SegmentNumber: segmentIndex.toString(),\n          SegmentLabel: label,\n          SegmentAlgorithmType: 'MANUAL',\n          SegmentAlgorithmName: 'OHIF Brush',\n          RecommendedDisplayCIELabValue,\n          SegmentedPropertyCategoryCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n          SegmentedPropertyTypeCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n        };\n        labelmapObj.metadata[segmentIndex] = segmentMetadata;\n      });\n\n      const generatedSegmentation = generateSegmentation(\n        referencedImages,\n        labelmapObj,\n        metaData,\n        options\n      );\n\n      return generatedSegmentation;\n    },\n    /**\n     * Downloads a segmentation based on the provided segmentation ID.\n     * This function retrieves the associated segmentation and\n     * uses it to generate the corresponding DICOM dataset, which\n     * is then downloaded with an appropriate filename.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\n     *\n     */\n    downloadSegmentation: ({ segmentationId }) => {\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      const generatedSegmentation = actions.generateSegmentation({\n        segmentationId,\n      });\n\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\n    },\n    /**\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\n     * and in its absence, defaults to 'Research Derived Series'.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be stored.\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\n     *\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\n     * otherwise throws an error.\n     */\n    storeSegmentation: async ({ segmentationId, dataSource, skipLabelDialog = false }) => {\n      const segmentation = segmentationService.getSegmentation(segmentationId);\n\n      if (!segmentation) {\n        throw new Error('No segmentation found');\n      }\n      const { label, displaySetInstanceUID } = segmentation;\n\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n      const shouldOverWrite = displaySet && displaySet.Modality === 'SEG';\n\n      let promptResult: { action?: number; value?: string } = {};\n\n      if (!(skipLabelDialog || shouldOverWrite)) {\n        promptResult = await createReportDialogPrompt(uiDialogService, {\n          extensionManager,\n        });\n\n        if (promptResult.action !== 1 && !promptResult.value) {\n          return;\n        }\n      }\n\n      const SeriesDescription = promptResult.value || label || 'Research Derived Series';\n      segmentation.label = SeriesDescription;\n\n      const generatedData = actions.generateSegmentation({\n        segmentationId,\n        options: {\n          SeriesDescription,\n          // Use SeriesInstanceUID, SOPInstanceUID, SeriesNumber, Manufacturer and SeriesDate\n          // if displaySet of the segmentation already exists.\n          // Study level and patient metadata will be used automatically.\n          ...(shouldOverWrite && {\n            SeriesInstanceUID: displaySet.SeriesInstanceUID,\n            SOPInstanceUID: displaySet.instances[0].SOPInstanceUID,\n            SeriesNumber: displaySet.SeriesNumber,\n            Manufacturer: displaySet.instances[0].Manufacturer,\n            SeriesDate: displaySet.SeriesDate,\n          }),\n        },\n      });\n\n      if (!generatedData || !generatedData.dataset) {\n        throw new Error('Error during segmentation generation');\n      }\n\n      const { dataset: naturalizedReport } = generatedData;\n\n      await dataSource.store.dicom(naturalizedReport);\n\n      // The \"Mode\" route listens for DicomMetadataStore changes\n      // When a new instance is added, it listens and\n      // automatically calls makeDisplaySets\n\n      // add the information for where we stored it to the instance as well\n      naturalizedReport.wadoRoot = dataSource.getConfig().wadoRoot;\n\n      return naturalizedReport;\n    },\n    /**\n     * Converts segmentations into RTSS for download.\n     * This sample function retrieves all segentations and passes to\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\n     * converts dataset to downloadable blob.\n     *\n     */\n    downloadRTSS: ({ segmentationId }) => {\n      const segmentations = segmentationService.getSegmentation(segmentationId);\n      const vtkUtils = {\n        vtkImageMarchingSquares,\n        vtkDataArray,\n        vtkImageData,\n      };\n\n      const RTSS = generateRTSSFromSegmentations(\n        segmentations,\n        classes.MetadataProvider,\n        DicomMetadataStore,\n        cache,\n        cornerstoneToolsEnums,\n        vtkUtils\n      );\n\n      try {\n        const reportBlob = datasetToBlob(RTSS);\n\n        //Create a URL for the binary.\n        const objectUrl = URL.createObjectURL(reportBlob);\n        window.location.assign(objectUrl);\n      } catch (e) {\n        console.warn(e);\n      }\n    },\n  };\n\n  const definitions = {\n    getUpdatedViewportsForSegmentation: {\n      commandFn: actions.getUpdatedViewportsForSegmentation,\n    },\n    loadSegmentationDisplaySetsForViewport: {\n      commandFn: actions.loadSegmentationDisplaySetsForViewport,\n    },\n    loadSegmentationsForViewport: {\n      commandFn: actions.loadSegmentationsForViewport,\n    },\n    createEmptySegmentationForViewport: {\n      commandFn: actions.createEmptySegmentationForViewport,\n    },\n    generateSegmentation: {\n      commandFn: actions.generateSegmentation,\n    },\n    downloadSegmentation: {\n      commandFn: actions.downloadSegmentation,\n    },\n    storeSegmentation: {\n      commandFn: actions.storeSegmentation,\n    },\n    downloadRTSS: {\n      commandFn: actions.downloadRTSS,\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n  };\n};\n\nexport default commandsModule;\n","import { id } from './id';\nimport React from 'react';\n\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport getPanelModule from './getPanelModule';\nimport getCommandsModule from './commandsModule';\nimport preRegistration from './init';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\n});\n\nconst OHIFCornerstoneSEGViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n  preRegistration,\n\n  /**\n   * PanelModule should provide a list of panels that will be available in OHIF\n   * for Modes to consume and render. Each panel is defined by a {name,\n   * iconName, iconLabel, label, component} object. Example of a panel module\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\n   */\n  getPanelModule,\n  getCommandsModule,\n\n  getViewportModule({ servicesManager, extensionManager }) {\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\n      return (\n        <OHIFCornerstoneSEGViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          commandsManager={commandsManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n  getHangingProtocolModule,\n};\n\nexport default extension;\n","import { addTool, BrushTool } from '@cornerstonejs/tools';\n\nexport default function init({ configuration = {} }): void {\n  addTool(BrushTool);\n}\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","getReferenceDisplaySet","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","length","Error","referencedDisplaySet","referencedVolumeURI","referencedVolumeId","load","async","headers","segDisplaySet","segmentationService","getSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","utilityModule","getModuleEntry","uiNotificationService","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","getDisplaySetByUID","imageIds","cachedReferencedVolume","cache","getVolume","_imageIds","map","imageId","tolerance","skipOverlapping","eventTarget","addEventListener","Enums","Events","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","EVENTS","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","generateToolState","metaData","triggerEvent","usedRecommendedDisplayCIELabValue","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","x","Math","round","CONSTANTS","assign","_loadSegments","suppressEvents","createSegmentationForSEGDisplaySet","then","catch","_load","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","uiDialogService","label","callback","dialogId","onSubmitHandler","action","value","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","title","noCloseButton","onClose","actions","text","type","ButtonEnums","secondary","primary","onSubmit","body","setValue","React","Input","labelClassName","autoFocus","className","onChange","event","persist","target","onKeyPress","key","rgbaColor","ChromePicker","color","rgb","presetColors","width","segmentation","includes","filter","segment","updateSegmentationLabels","segmentations","ViewPosition","ImageLaterality","replace","savedStatusReducer","state","payload","SAVED_STATUS_ICON","PanelSegmentation","commandsManager","configuration","viewportGridService","userAuthenticationService","CropDisplayAreaService","t","useTranslation","selectedSegmentationId","setSelectedSegmentationId","useState","segmentationConfiguration","setSegmentationConfiguration","getConfiguration","setSegmentations","getSegmentations","savedStatusStates","dispatch","useReducer","useEffect","added","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","subscriptions","unsubscribe","subscribe","updatedSegmentations","push","unsub","timerId","changedSegmentations","SEGMENTATION_DATA_MODIFIED","clearTimeout","find","changedSegmentation","setTimeout","datasources","getActiveDataSource","promises","createReportAsync","getReport","runCommand","segmentationId","dataSource","skipLabelDialog","reportType","showLoadingModal","throwErrors","allSettled","reduce","acc","result","index","status","savedSegmentations","cs","timoutInSeconds","setSegmentationActive","setReferencedDisplaySet","isSegmentationActive","seg","isActive","setActiveSegmentationForToolGroup","segDisplayset","activeViewportId","getState","referencedImageLoaded","viewport","displaySetInstanceUIDs","setDisplaySetsForViewport","viewportId","getToolGroupIds","getToolGroupIdsWithSegmentation","_setSegmentationConfiguration","useCallback","setConfiguration","SegmentationGroupTable","disableEditing","activeSegmentationId","onSegmentationAdd","onSegmentationClick","onSegmentationDelete","remove","onSegmentationDownload","onSegmentationDownloadRTSS","storeSegmentation","warn","message","getActiveViewportId","onSegmentationEdit","callInputDialog","actionId","addOrUpdateSegmentation","onSegmentClick","segmentIndex","setActiveSegment","jumpToSegmentCenter","onSegmentEdit","setSegmentLabel","onSegmentAdd","getSegmentLabel","addSegment","onSegmentColorClick","opacity","r","g","b","a","callColorPickerDialog","newRgbaColor","setSegmentRGBAColor","onSegmentDelete","removeSegment","onToggleSegmentVisibility","isVisible","setSegmentVisibility","onToggleSegmentLock","toggleSegmentLocked","onToggleSegmentationVisibility","toggleSegmentationVisibility","showDeleteSegment","segmentationConfig","initialConfig","setRenderOutline","setOutlineOpacityActive","setRenderFill","setRenderInactiveSegmentations","setOutlineWidthActive","setFillAlpha","setFillAlphaInactive","propTypes","PropTypes","isRequired","segmentationUtils","utilities","TOOL_TYPES","CIRCULAR_BRUSH","SPHERE_BRUSH","CIRCULAR_ERASER","SPHERE_ERASER","CIRCLE_SHAPE","RECTANGLE_SHAPE","SPHERE_SHAPE","THRESHOLD_CIRCULAR_BRUSH","THRESHOLD_SPHERE_BRUSH","ACTIONS","SET_TOOL_CONFIG","SET_ACTIVE_TOOL","initialState","Brush","brushSize","mode","Eraser","Shapes","ThresholdBrush","thresholdRange","activeTool","toolboxReducer","tool","config","_getToolNamesFromCategory","category","toolNames","getPixelToMmConversionFactor","cornerstoneViewportService","getCornerstoneViewport","imageData","getImageData","spacing","max","toolbarService","toolGroupService","viewportGrid","useViewportGrid","toolsEnabled","setToolsEnabled","brushProperties","setBrushProperties","min","step","updateActiveTool","size","undefined","get","getActiveToolForViewport","setToolActive","toolName","recordInteraction","interactionType","commands","commandName","commandOptions","setBrushSizesFromParams","params","URLSearchParams","window","location","search","defaultBrushSizeInMm","minBrushSizeInMm","maxBrushSizeInMm","highestPixelSpacing","lowestBrushRadius","toFixed","toolCategory","onBrushSizeChange","elementEnabledHandler","setDefaultBrushSize","element","removeEventListener","VOLUME_VIEWPORT_NEW_VOLUME","STACK_VIEWPORT_NEW_STACK","ELEMENT_ENABLED","viewportElement","getEnabledElement","getActiveViewportElement","events","unsubscriptions","activeSegmentation","segmentCount","TOOL_BAR_STATE_MODIFIED","values","updateBrushSize","setBrushSizeForToolGroup","valueAsStringOrNumber","Number","handleRangeChange","newRange","getToolGroup","setToolConfiguration","strategySpecificConfiguration","THRESHOLD_INSIDE_CIRCLE","threshold","AdvancedToolbox","items","icon","disabled","active","onClick","options","children","InputDoubleRange","minValue","maxValue","showLabel","allowNumberEdit","showAdjustmentArrows","getPanelModule","customizationService","iconName","iconLabel","component","appConfig","useAppConfig","disableEditingForMode","SegmentationToolbox","updateViewportsForSegmentationRendering","loadFn","getTargetViewport","targetViewportId","updatedViewports","getUpdatedViewportsForSegmentation","createSegmentation","hydrateSegmentation","volumeExists","Array","from","_volumeCache","some","volumeId","needsRerendering","csViewport","prevCamera","getCamera","newViewportEvent","eventTriggerer","createNewSegmentationOnNewViewport","isTheActiveViewportVolumeMounted","volumeActors","ac","uid","setCamera","setDisplaySetsForViewports","hangingProtocolService","referenceDisplaySetInstanceUID","segmentationFrameOfReferenceUID","FrameOfReferenceUID","getViewportsRequireUpdate","v","shouldRenderSegmentation","imageIdReferenceMap","labelmaps2D","segmentsOnLabelmap3D","Set","entries","entry","getImage","segmentationImage","pixelData","getPixelData","segmentsOnLabelmap","add","labelmapObj","datasetToBlob","generateLabelMaps2DFrom3D","generateSegmentation","RTSS","generateRTSSFromSegmentations","adaptersRT","downloadDICOMData","helpers","commandsModule","createEmptySegmentationForViewport","currentSegmentations","createSegmentationForDisplaySet","addSegmentationRepresentationToToolGroup","loadSegmentationsForViewport","scalarData","getLabelmapVolume","set","isLocked","visibility","activeSegmentIndex","centroidsIJK","setCentroids","loadSegmentationDisplaySetsForViewport","serviceFunction","boundFn","bind","cornerstoneToolsSegmentation","segmentationLabelmapData","representationData","LABELMAP","segmentationVolume","getCornerstoneImages","generateLabelmaps2DFromImageIdMap","metadata","segmentationInOHIF","rgb2DICOMLAB","slice","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","SegmentAlgorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","generatedSegmentation","dataset","shouldOverWrite","promptResult","createReportDialogPrompt","generatedData","Manufacturer","naturalizedReport","store","dicom","getConfig","downloadRTSS","vtkUtils","vtkImageMarchingSquares","vtkDataArray","vtkImageData","classes","MetadataProvider","DicomMetadataStore","cornerstoneToolsEnums","reportBlob","objectUrl","URL","createObjectURL","e","definitions","commandFn","Component","OHIFCornerstoneSEGViewport","props","fallback","preRegistration","addTool","BrushTool","getCommandsModule","getViewportModule","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}